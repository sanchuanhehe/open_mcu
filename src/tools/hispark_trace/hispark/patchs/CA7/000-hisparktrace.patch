diff -uNr old/CA7/source/cmsis-core/cmsis_cp15.h new/CA7/source/cmsis-core/cmsis_cp15.h
--- old/CA7/source/cmsis-core/cmsis_cp15.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/cmsis-core/cmsis_cp15.h	2023-05-25 15:09:49.000000000 +0800
@@ -31,6 +31,12 @@
 #ifndef __CMSIS_CP15_H
 #define __CMSIS_CP15_H
 
+#ifdef HISPARK_TRACE
+#ifndef   __STATIC_FORCEINLINE
+  #define __STATIC_FORCEINLINE                   static inline __attribute__((always_inline))
+#endif
+#endif
+
 /** \brief  Get ACTLR
     \return               Auxiliary Control register value
  */
@@ -273,7 +279,7 @@
 
 #if (defined(__CORTEX_A) && (__CORTEX_A == 7U) && \
     defined(__TIM_PRESENT) && (__TIM_PRESENT == 1U)) || \
-    defined(DOXYGEN)
+    defined(DOXYGEN) || defined(HISPARK_TRACE)
 
 /** \brief  Set CNTFRQ
 
@@ -459,7 +465,9 @@
 /** \brief  Set CCSIDR
     \deprecated CCSIDR itself is read-only. Use __set_CSSELR to select cache level instead.
  */
+#ifndef HISPARK_TRACE 
 CMSIS_DEPRECATED
+#endif
 __STATIC_FORCEINLINE void __set_CCSIDR(uint32_t value)
 {
   __set_CSSELR(value);
diff -uNr old/CA7/source/cmsis-core/cmsis_gcc.h new/CA7/source/cmsis-core/cmsis_gcc.h
--- old/CA7/source/cmsis-core/cmsis_gcc.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/cmsis-core/cmsis_gcc.h	2023-05-25 15:09:49.000000000 +0800
@@ -301,7 +301,12 @@
 {
   uint32_t result;
 
+#ifdef CORE_CA7
+  result = 0;  /* Cortex-A doesn't support xpsr register */
+#else
   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+#endif
+
   return(result);
 }
 
@@ -2167,7 +2172,34 @@
 #endif /* (__ARM_FEATURE_DSP == 1) */
 /*@} end of group CMSIS_SIMD_intrinsics */
 
-
+#ifdef HISPARK_TRACE
+#define __STRINGIFY(x) #x
+#define __set_CP(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \
+    __ASM volatile ("MCR " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
+                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
+                    __STRINGIFY(opcode_2)                                         \
+                    : : "r" (src) )
+
+/* C语言实现MRC指令 */
+#define __get_CP(coproc, opcode_1, dst, CRn, CRm, opcode_2)                               \
+  ({                                                                              \
+    __ASM volatile ("MRC " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
+                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
+                    __STRINGIFY(opcode_2)                                         \
+                    : "=r" (dst) );                                             \
+  })
+
+#define __get_CP64(cp, op1, Rt, CRm)         \
+({\
+    __ASM volatile("MRRC " __STRINGIFY(p##cp) ", " __STRINGIFY(op1) ", %Q0, %R0," __STRINGIFY(c##CRm)  : "=r" (Rt) : : "memory" );\
+})
+
+#define __set_CP64(cp, op1, Rt, CRm) \
+({\
+    __ASM volatile("MCRR "__STRINGIFY(p##cp) ", " __STRINGIFY(op1) ", %Q0, %R0, " __STRINGIFY(c##CRm) : : "r" (Rt) : "memory" );\
+})
+#include "cmsis_cp15.h"
+#endif
 #pragma GCC diagnostic pop
 
 #endif /* __CMSIS_GCC_H */
diff -uNr old/CA7/source/cmsis-core/core_ca.h new/CA7/source/cmsis-core/core_ca.h
--- old/CA7/source/cmsis-core/core_ca.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/cmsis-core/core_ca.h	2023-05-25 15:09:49.000000000 +0800
@@ -35,6 +35,12 @@
 #ifndef __CORE_CA_H_GENERIC
 #define __CORE_CA_H_GENERIC
 
+#ifdef HISPARK_TRACE
+#include <stdint.h>
+
+#define NVIC_DisableIRQ(x) (void)0
+#define NVIC_EnableIRQ(x) (void)0
+#endif
 
 /*******************************************************************************
  *                 CMSIS definitions
@@ -739,6 +745,13 @@
 #define L2C_310           ((L2C_310_TypeDef *)L2C_310_BASE) /*!< \brief L2C_310 register set access pointer */
 #endif
 
+#ifdef HISPARK_TRACE
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  return (0UL);                                                     /* Function successful */
+}
+#endif
+
 #if (__GIC_PRESENT == 1U) || defined(DOXYGEN)
     
 /** \brief  Structure type to access the Generic Interrupt Controller Distributor (GICD)
@@ -950,6 +963,7 @@
 */
 __STATIC_FORCEINLINE void __L1C_MaintainDCacheSetWay(uint32_t level, uint32_t maint)
 {
+#ifndef HISPARK_TRACE
   uint32_t Dummy;
   uint32_t ccsidr;
   uint32_t num_sets;
@@ -985,6 +999,7 @@
     }
   }
   __DMB();
+#endif
 }
 
 /** \brief  Clean and Invalidate the entire data or unified cache
@@ -992,6 +1007,7 @@
 * \param [in] op 0 - invalidate, 1 - clean, otherwise - invalidate and clean
 */
 __STATIC_FORCEINLINE void L1C_CleanInvalidateCache(uint32_t op) {
+#ifndef HISPARK_TRACE
   uint32_t clidr;
   uint32_t cache_type;
   clidr =  __get_CLIDR();
@@ -1003,6 +1019,7 @@
       __L1C_MaintainDCacheSetWay(i, op);
     }
   }
+#endif
 }
 
 /** \brief  Clean and Invalidate the entire data or unified cache
@@ -1010,7 +1027,9 @@
 * \param [in] op 0 - invalidate, 1 - clean, otherwise - invalidate and clean
 * \deprecated Use generic L1C_CleanInvalidateCache instead.
 */
+#ifndef HISPARK_TRACE
 CMSIS_DEPRECATED
+#endif
 __STATIC_FORCEINLINE void __L1C_CleanInvalidateCache(uint32_t op) {
   L1C_CleanInvalidateCache(op);
 }
@@ -1473,7 +1492,7 @@
       //Set priority
       GIC_SetPriority((IRQn_Type)i, priority_field/2U);
       //Set target list to CPU0
-      GIC_SetTarget((IRQn_Type)i, 1U);
+      GIC_SetTarget((IRQn_Type)i, 0xFFFFU);
   }
   //Enable distributor
   GIC_EnableDistributor();
@@ -2578,20 +2597,26 @@
 */
 __STATIC_INLINE void MMU_Enable(void)
 {
+  #if defined(HISPARK_TRACE)
+  #else
   // Set M bit 0 to enable the MMU
   // Set AFE bit to enable simplified access permissions model
   // Clear TRE bit to disable TEX remap and A bit to disable strict alignment fault checking
   __set_SCTLR( (__get_SCTLR() & ~(1 << 28) & ~(1 << 1)) | 1 | (1 << 29));
   __ISB();
+  #endif
 }
 
 /** \brief  Disable MMU
 */
 __STATIC_INLINE void MMU_Disable(void)
 {
+  #if defined(HISPARK_TRACE)
+  #else
   // Clear M bit 0 to disable the MMU
   __set_SCTLR( __get_SCTLR() & ~1);
   __ISB();
+  #endif
 }
 
 /** \brief  Invalidate entire unified TLB
@@ -2599,9 +2624,12 @@
 
 __STATIC_INLINE void MMU_InvalidateTLB(void)
 {
+  #if defined(HISPARK_TRACE)
+  #else
   __set_TLBIALL(0);
   __DSB();     //ensure completion of the invalidation
   __ISB();     //ensure instruction fetch path sees new state
+  #endif
 }
 
 
diff -uNr old/CA7/source/daplink/cmsis-dap/DAP.c new/CA7/source/daplink/cmsis-dap/DAP.c
--- old/CA7/source/daplink/cmsis-dap/DAP.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/DAP.c	2023-06-09 15:33:13.058970800 +0800
@@ -35,7 +35,12 @@
 #include "DAP.h"
 #include "info.h"
 #include "dap_strings.h"
-
+#if defined(HISPARK_TRACE)
+#include "DAP_vendor_ex.h"
+#include "debug.h"
+#include "msg_queue.h"
+#include "swd_jtag_config.h"
+#endif
 
 #if (DAP_PACKET_SIZE < 64U)
 #error "Minimum Packet Size is 64!"
@@ -56,6 +61,10 @@
 #define MAX_SWJ_CLOCK(delay_cycles) \
   ((CPU_CLOCK/2U) / (IO_PORT_WRITE_CYCLES + delay_cycles))
 
+#if defined (HISPARK_TRACE)
+#define CLOCK_DELAY(swj_clock) \
+ (((CPU_CLOCK/2U) / swj_clock) - IO_PORT_WRITE_CYCLES)
+#endif
 
          DAP_Data_t DAP_Data;           // DAP Data
 volatile uint8_t    DAP_TransferAbort;  // Transfer Abort Flag
@@ -63,6 +72,12 @@
 
 static const char DAP_FW_Ver [] = DAP_FW_VER;
 
+#if defined (HISPARK_TRACE)
+#if TARGET_DEVICE_FIXED
+static const char TargetDeviceVendor [] = TARGET_DEVICE_VENDOR;
+static const char TargetDeviceName   [] = TARGET_DEVICE_NAME;
+#endif
+#endif
 
 
 // Get DAP Information
@@ -87,10 +102,24 @@
       memcpy(info, DAP_FW_Ver, length);
       break;
     case DAP_ID_DEVICE_VENDOR:
-      length = DAP_GetTargetDeviceVendorString((char *)info);
+#if defined(HISPARK_TRACE)
+#if TARGET_DEVICE_FIXED
+      length = (uint8_t)sizeof(TargetDeviceVendor);
+      memcpy(info, TargetDeviceVendor, length);
+#endif
+#else
+    length = DAP_GetTargetDeviceVendorString((char *)info);
+#endif
       break;
     case DAP_ID_DEVICE_NAME:
+#if defined(HISPARK_TRACE)
+#if TARGET_DEVICE_FIXED
+      length = (uint8_t)sizeof(TargetDeviceName);
+      memcpy(info, TargetDeviceName, length);
+#endif
+#else
       length = DAP_GetTargetDeviceNameString((char *)info);
+#endif
       break;
     case DAP_ID_BOARD_VENDOR:
       length = DAP_GetTargetBoardVendorString((char *)info);
@@ -253,6 +282,14 @@
       break;
   }
 
+#ifdef HISPARK_TRACE
+  MsgBuf msg;
+  msg.type = MSG_TYPE_DEBUG_PORT_SET;
+  msg.bufLen = sizeof(DAP_Data.debug_port);
+  memcpy(msg.buf, &DAP_Data.debug_port, sizeof(DAP_Data.debug_port));
+  MSGQ_SendMsg(&msg);
+#endif
+
   *response = (uint8_t)port;
   return ((1U << 16) | 1U);
 }
@@ -418,7 +455,6 @@
 static uint32_t DAP_SWJ_Clock(const uint8_t *request, uint8_t *response) {
 #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
   uint32_t clock;
-  uint32_t delay;
 
   clock = (uint32_t)(*(request+0) <<  0) |
           (uint32_t)(*(request+1) <<  8) |
@@ -432,6 +468,16 @@
 
   DAP_Data.nominal_clock = clock;
 
+#ifdef HISPARK_TRACE
+  MsgBuf msg;
+  msg.type = MSG_TYPE_CLK_CFG;
+  msg.bufLen = sizeof(clock);
+  memcpy(msg.buf, &clock, sizeof(clock));
+  MSGQ_SendMsg(&msg);
+
+  SwdJtagClockLevelSet(clock);
+#endif
+
   Set_DAP_Clock_Delay(clock);
 
   *response = DAP_OK;
@@ -1821,7 +1867,6 @@
 void DAP_Setup(void) {
 
   // Default settings
-  DAP_Data.debug_port  = 0U;
   DAP_Data.nominal_clock = DAP_DEFAULT_SWJ_CLOCK;
   DAP_Data.transfer.idle_cycles = 0U;
   DAP_Data.transfer.retry_count = 100U;
@@ -1832,7 +1877,8 @@
   DAP_Data.swd_conf.data_phase  = 0U;
 #endif
 #if (DAP_JTAG != 0)
-  DAP_Data.jtag_dev.count = 0U;
+  DAP_Data.jtag_dev.count = 1U;
+  DAP_Data.jtag_dev.ir_length[0] = 4, /* ir length is 4 */
 #endif
 
   // Sets DAP_Data.fast_clock and DAP_Data.clock_delay.
diff -uNr old/CA7/source/daplink/cmsis-dap/DAP.h new/CA7/source/daplink/cmsis-dap/DAP.h
--- old/CA7/source/daplink/cmsis-dap/DAP.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/DAP.h	2023-06-09 15:33:33.462015400 +0800
@@ -113,6 +113,17 @@
 #define ID_DAP_VendorExFirst            0xA0U
 #define ID_DAP_VendorExLast             0xFEU
 
+#ifdef HISPARK_TRACE
+#define ID_DAP_VENDOR_VAR_MONITOR       0xAAU
+#define ID_DAP_VENDOR_READ_VAR          0xABU
+#define ID_DAP_VENDOR_WRITE_VAR         0xACU
+#define ID_DAP_VENDOR_STOP_VARMONITOR   0xADU
+#define ID_DAP_VENDOR_PAUSE_VARMONITOR  0xAEU
+
+#define VARMONITOR_PAUCE          0x0
+#define VARMONITOR_RESUME         0x1
+#endif /* #ifdef HISPARK_TRACE */
+
 #define ID_DAP_Invalid                  0xFFU
 
 // DAP Status Code
@@ -235,12 +246,18 @@
 
 #include <stddef.h>
 #include <stdint.h>
+#ifdef STM32MP153Dxx
+#include "stm32mp153dxx_ca7.h"
+#endif
 #include "cmsis_compiler.h"
 
 // DAP Data structure
 typedef struct {
   uint8_t     debug_port;                       // Debug Port
   uint8_t     fast_clock;                       // Fast Clock Flag
+#ifdef HISPARK_TRACE
+  uint32_t    clock_level;                      // clock_level
+#endif /* #ifdef HISPARK_TRACE */
   uint8_t     padding[2];
   uint32_t   clock_delay;                       // Clock Delay
   uint32_t nominal_clock;                       // Nominal requested clock frequency in Hertz.
@@ -285,6 +302,7 @@
 extern void     SWD_Sequence    (uint32_t info,  const uint8_t *swdo, uint8_t *swdi);
 extern void     JTAG_Sequence   (uint32_t info,  const uint8_t *tdi,  uint8_t *tdo);
 extern void     JTAG_IR         (uint32_t ir);
+extern uint8_t  JTAG_RESET (void);
 extern uint32_t JTAG_ReadIDCode (void);
 extern void     JTAG_WriteAbort (uint32_t data);
 extern uint8_t  JTAG_Transfer   (uint32_t request, uint32_t *data);
diff -uNr old/CA7/source/daplink/cmsis-dap/debug_cm.h new/CA7/source/daplink/cmsis-dap/debug_cm.h
--- old/CA7/source/daplink/cmsis-dap/debug_cm.h	2022-02-05 13:12:28.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/debug_cm.h	2023-06-09 15:46:20.991985600 +0800
@@ -31,6 +31,11 @@
 #define SWD_REG_W         (0<<1)
 #define SWD_REG_ADR(a)    (a & 0x0c)
 
+// JTAG register access
+#define JTAG_REG_R         (1<<1)
+#define JTAG_REG_W         (0<<1)
+#define JTAG_REG_ADR(a)    (a & 0x0c)
+
 // Abort Register definitions
 #define DAPABORT       0x00000001  // DAP Abort
 #define STKCMPCLR      0x00000002  // Clear STICKYCMP Flag (SW Only)
@@ -165,4 +170,14 @@
 // Data Watchpoint and Trace unit
 #define DWT_PCSR       0xe000101c  // DWT PC Sampling Register
 
+typedef enum {
+    CONNECT_NORMAL,
+    CONNECT_UNDER_RESET,
+} JTAG_SWD_CONNECT_TYPE;
+
+typedef enum {
+    FLASHALGO_RETURN_BOOL,
+    FLASHALGO_RETURN_POINTER
+} flash_algo_return_t;
+
 #endif
diff -uNr old/CA7/source/daplink/cmsis-dap/JTAG_DP.c new/CA7/source/daplink/cmsis-dap/JTAG_DP.c
--- old/CA7/source/daplink/cmsis-dap/JTAG_DP.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/JTAG_DP.c	2023-06-09 15:33:49.711543900 +0800
@@ -27,7 +27,9 @@
 
 #include "DAP_config.h"
 #include "DAP.h"
-
+#ifdef HISPARK_TRACE
+#include "swd_jtag_config.h"
+#endif /* #ifdef HISPARK_TRACE */
 
 // JTAG Macros
 
@@ -36,45 +38,262 @@
 #define PIN_TMS_SET PIN_SWDIO_TMS_SET
 #define PIN_TMS_CLR PIN_SWDIO_TMS_CLR
 
-#define JTAG_CYCLE_TCK()                \
-  PIN_TCK_CLR();                        \
-  PIN_DELAY();                          \
-  PIN_TCK_SET();                        \
-  PIN_DELAY()
-
-#define JTAG_CYCLE_TDI(tdi)             \
-  PIN_TDI_OUT(tdi);                     \
-  PIN_TCK_CLR();                        \
-  PIN_DELAY();                          \
-  PIN_TCK_SET();                        \
-  PIN_DELAY()
-
-#define JTAG_CYCLE_TDO(tdo)             \
-  PIN_TCK_CLR();                        \
-  PIN_DELAY();                          \
-  tdo = PIN_TDO_IN();                   \
-  PIN_TCK_SET();                        \
-  PIN_DELAY()
-
-#define JTAG_CYCLE_TDIO(tdi,tdo)        \
-  PIN_TDI_OUT(tdi);                     \
-  PIN_TCK_CLR();                        \
-  PIN_DELAY();                          \
-  tdo = PIN_TDO_IN();                   \
-  PIN_TCK_SET();                        \
-  PIN_DELAY()
+#ifdef HISPARK_TRACE
+inline static void JTAGDP_DELAY_LEVEL_0(void)
+{
+    __NOP(); __NOP();
+}
 
-#define PIN_DELAY() PIN_DELAY_SLOW(DAP_Data.clock_delay)
+inline static void JTAGDP_DELAY_LEVEL_1(void)
+{
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();
+}
 
+inline static void JTAGDP_DELAY_LEVEL_2(void)
+{
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
 
-#if (DAP_JTAG != 0)
+inline static void JTAGDP_DELAY_LEVEL_3(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
+
+inline static void JTAGDP_DELAY_LEVEL_4(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP(); __NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
+
+inline static void JTAGDP_DELAY_LEVEL_5(void)
+{
+    volatile uint32_t cnt = 1;
+    while(cnt) {
+        cnt--;
+   }
+}
+
+inline static void JTAGDP_DELAY_LEVEL_6(void)
+{
+    volatile uint32_t cnt = 2;
+    while(cnt) {
+        cnt--;
+   }
+}
+
+inline static void JTAGDP_DELAY_LEVEL_7(void)
+{
+    volatile uint32_t cnt = 3;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void JTAGDP_DELAY_LEVEL_8(void)
+{
+    volatile uint32_t cnt = 5;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void JTAGDP_DELAY_LEVEL_9(void)
+{
+    volatile uint32_t cnt = 15;
+    while(cnt) {
+        cnt--;
+   }
+}
+
+inline static void JTAGDP_DELAY_LEVEL_LOW(uint32_t delay)
+{
+    volatile uint32_t cnt = delay;
+    while(cnt) {
+        cnt--;
+   }
+}
+#endif /* #ifdef HISPARK_TRACE */
 
+#define JTAG_CYCLE_TCK()                  \
+    PIN_TCK_CLR();                        \
+    PIN_DELAY();                          \
+    PIN_TCK_SET();                        \
+    PIN_DELAY()
+
+#define JTAG_CYCLE_TDI(tdi)               \
+    PIN_TDI_OUT(tdi);                     \
+    PIN_TCK_CLR();                        \
+    PIN_DELAY();                          \
+    PIN_TCK_SET();                        \
+    PIN_DELAY()
+
+#define JTAG_CYCLE_TDO(tdo)               \
+    PIN_TCK_CLR();                        \
+    PIN_DELAY();                          \
+    tdo = PIN_TDO_IN();                   \
+    PIN_TCK_SET();                        \
+    PIN_DELAY()
+
+#define JTAG_CYCLE_TDIO(tdi,tdo)          \
+    PIN_TDI_OUT(tdi);                     \
+    PIN_TCK_CLR();                        \
+    PIN_DELAY();                          \
+    tdo = PIN_TDO_IN();                   \
+    PIN_TCK_SET();                        \
+    PIN_DELAY()
+
+#ifdef HISPARK_TRACE
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_6()
+#else
+#define PIN_DELAY() PIN_DELAY_SLOW(DAP_Data.clock_delay)
+#endif /* #ifdef HISPARK_TRACE */
+
+#if (DAP_JTAG != 0)
 
 // Generate JTAG Sequence
 //   info:   sequence information
 //   tdi:    pointer to TDI generated data
 //   tdo:    pointer to TDO captured data
 //   return: none
+#ifdef HISPARK_TRACE
+#define JTAG_SequenceFunction(speed)                                                      \
+static void JTAG_Sequence_##speed (uint32_t info, const uint8_t *tdi, uint8_t *tdo)       \
+{                                                                                         \
+    uint32_t i_val;                                                                       \
+    uint32_t o_val;                                                                       \
+    uint32_t bit;                                                                         \
+    uint32_t n, k;                                                                        \
+                                                                                          \
+    n = info & JTAG_SEQUENCE_TCK;                                                         \
+    if (n == 0U) {                                                                        \
+        n = 64U;                                                                          \
+    }                                                                                     \
+                                                                                          \
+    if (info & JTAG_SEQUENCE_TMS) {                                                       \
+        PIN_TMS_SET();                                                                    \
+    } else {                                                                              \
+        PIN_TMS_CLR();                                                                    \
+    }                                                                                     \
+                                                                                          \
+    while (n) {                                                                           \
+        i_val = *tdi++;                                                                   \
+        o_val = 0U;                                                                       \
+        for (k = 8U; k && n; k--, n--) {                                                  \
+            JTAG_CYCLE_TDIO(i_val, bit);                                                  \
+            i_val >>= 1;                                                                  \
+            o_val >>= 1;                                                                  \
+            o_val  |= bit << 7;                                                           \
+        }                                                                                 \
+        o_val >>= k;                                                                      \
+        if (info & JTAG_SEQUENCE_TDO) {                                                   \
+            *tdo++ = (uint8_t)o_val;                                                      \
+        }                                                                                 \
+    }                                                                                     \
+}
+#else /* #ifdef HISPARK_TRACE */
 void JTAG_Sequence (uint32_t info, const uint8_t *tdi, uint8_t *tdo) {
   uint32_t i_val;
   uint32_t o_val;
@@ -107,151 +326,220 @@
     }
   }
 }
-
+#endif /* #ifdef HISPARK_TRACE */
 
 // JTAG Set IR
 //   ir:     IR value
 //   return: none
-#define JTAG_IR_Function(speed) /**/                                            \
-static void JTAG_IR_##speed (uint32_t ir) {                                     \
-  uint32_t n;                                                                   \
-                                                                                \
-  PIN_TMS_SET();                                                                \
-  JTAG_CYCLE_TCK();                         /* Select-DR-Scan */                \
-  JTAG_CYCLE_TCK();                         /* Select-IR-Scan */                \
-  PIN_TMS_CLR();                                                                \
-  JTAG_CYCLE_TCK();                         /* Capture-IR */                    \
-  JTAG_CYCLE_TCK();                         /* Shift-IR */                      \
-                                                                                \
-  PIN_TDI_OUT(1U);                                                              \
-  for (n = DAP_Data.jtag_dev.ir_before[DAP_Data.jtag_dev.index]; n; n--) {      \
-    JTAG_CYCLE_TCK();                       /* Bypass before data */            \
-  }                                                                             \
-  for (n = DAP_Data.jtag_dev.ir_length[DAP_Data.jtag_dev.index] - 1U; n; n--) { \
-    JTAG_CYCLE_TDI(ir);                     /* Set IR bits (except last) */     \
-    ir >>= 1;                                                                   \
-  }                                                                             \
-  n = DAP_Data.jtag_dev.ir_after[DAP_Data.jtag_dev.index];                      \
-  if (n) {                                                                      \
-    JTAG_CYCLE_TDI(ir);                     /* Set last IR bit */               \
-    PIN_TDI_OUT(1U);                                                            \
-    for (--n; n; n--) {                                                         \
-      JTAG_CYCLE_TCK();                     /* Bypass after data */             \
-    }                                                                           \
-    PIN_TMS_SET();                                                              \
-    JTAG_CYCLE_TCK();                       /* Bypass & Exit1-IR */             \
-  } else {                                                                      \
-    PIN_TMS_SET();                                                              \
-    JTAG_CYCLE_TDI(ir);                     /* Set last IR bit & Exit1-IR */    \
-  }                                                                             \
-                                                                                \
-  JTAG_CYCLE_TCK();                         /* Update-IR */                     \
-  PIN_TMS_CLR();                                                                \
-  JTAG_CYCLE_TCK();                         /* Idle */                          \
-  PIN_TDI_OUT(1U);                                                              \
+#define JTAG_IR_Function(speed)                                                   \
+static void JTAG_IR_##speed (uint32_t ir)                                         \
+{                                                                                 \
+    uint32_t n;                                                                   \
+                                                                                  \
+    PIN_TMS_SET();                                                                \
+    JTAG_CYCLE_TCK();                         /* Select-DR-Scan */                \
+    JTAG_CYCLE_TCK();                         /* Select-IR-Scan */                \
+    PIN_TMS_CLR();                                                                \
+    JTAG_CYCLE_TCK();                         /* Capture-IR */                    \
+    JTAG_CYCLE_TCK();                         /* Shift-IR */                      \
+                                                                                  \
+    PIN_TDI_OUT(1U);                                                              \
+    for (n = DAP_Data.jtag_dev.ir_before[DAP_Data.jtag_dev.index]; n; n--) {      \
+        JTAG_CYCLE_TCK();                       /* Bypass before data */          \
+    }                                                                             \
+    for (n = DAP_Data.jtag_dev.ir_length[DAP_Data.jtag_dev.index] - 1U; n; n--) { \
+        JTAG_CYCLE_TDI(ir);                     /* Set IR bits (except last) */   \
+        ir >>= 1;                                                                 \
+    }                                                                             \
+    n = DAP_Data.jtag_dev.ir_after[DAP_Data.jtag_dev.index];                      \
+    if (n) {                                                                      \
+        JTAG_CYCLE_TDI(ir);                     /* Set last IR bit */             \
+        PIN_TDI_OUT(1U);                                                          \
+        for (--n; n; n--) {                                                       \
+            JTAG_CYCLE_TCK();                     /* Bypass after data */         \
+        }                                                                         \
+        PIN_TMS_SET();                                                            \
+        JTAG_CYCLE_TCK();                       /* Bypass & Exit1-IR */           \
+    } else {                                                                      \
+        PIN_TMS_SET();                                                            \
+        JTAG_CYCLE_TDI(ir);                     /* Set last IR bit & Exit1-IR */  \
+    }                                                                             \
+                                                                                  \
+    JTAG_CYCLE_TCK();                         /* Update-IR */                     \
+    PIN_TMS_CLR();                                                                \
+    JTAG_CYCLE_TCK();                         /* Idle */                          \
+    PIN_TDI_OUT(1U);                                                              \
 }
 
-
 // JTAG Transfer I/O
 //   request: A[3:2] RnW APnDP
 //   data:    DATA[31:0]
 //   return:  ACK[2:0]
-#define JTAG_TransferFunction(speed)        /**/                                \
-static uint8_t JTAG_Transfer##speed (uint32_t request, uint32_t *data) {        \
-  uint32_t ack;                                                                 \
-  uint32_t bit;                                                                 \
-  uint32_t val;                                                                 \
-  uint32_t n;                                                                   \
-                                                                                \
-  PIN_TMS_SET();                                                                \
-  JTAG_CYCLE_TCK();                         /* Select-DR-Scan */                \
-  PIN_TMS_CLR();                                                                \
-  JTAG_CYCLE_TCK();                         /* Capture-DR */                    \
-  JTAG_CYCLE_TCK();                         /* Shift-DR */                      \
-                                                                                \
-  for (n = DAP_Data.jtag_dev.index; n; n--) {                                   \
-    JTAG_CYCLE_TCK();                       /* Bypass before data */            \
-  }                                                                             \
-                                                                                \
-  JTAG_CYCLE_TDIO(request >> 1, bit);       /* Set RnW, Get ACK.0 */            \
-  ack  = bit << 1;                                                              \
-  JTAG_CYCLE_TDIO(request >> 2, bit);       /* Set A2,  Get ACK.1 */            \
-  ack |= bit << 0;                                                              \
-  JTAG_CYCLE_TDIO(request >> 3, bit);       /* Set A3,  Get ACK.2 */            \
-  ack |= bit << 2;                                                              \
-                                                                                \
-  if (ack != DAP_TRANSFER_OK) {                                                 \
-    /* Exit on error */                                                         \
-    PIN_TMS_SET();                                                              \
-    JTAG_CYCLE_TCK();                       /* Exit1-DR */                      \
-    goto exit;                                                                  \
-  }                                                                             \
-                                                                                \
-  if (request & DAP_TRANSFER_RnW) {                                             \
-    /* Read Transfer */                                                         \
-    val = 0U;                                                                   \
-    for (n = 31U; n; n--) {                                                     \
-      JTAG_CYCLE_TDO(bit);                  /* Get D0..D30 */                   \
-      val  |= bit << 31;                                                        \
-      val >>= 1;                                                                \
-    }                                                                           \
-    n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;                 \
-    if (n) {                                                                    \
-      JTAG_CYCLE_TDO(bit);                  /* Get D31 */                       \
-      for (--n; n; n--) {                                                       \
-        JTAG_CYCLE_TCK();                   /* Bypass after data */             \
-      }                                                                         \
-      PIN_TMS_SET();                                                            \
-      JTAG_CYCLE_TCK();                     /* Bypass & Exit1-DR */             \
-    } else {                                                                    \
-      PIN_TMS_SET();                                                            \
-      JTAG_CYCLE_TDO(bit);                  /* Get D31 & Exit1-DR */            \
-    }                                                                           \
-    val |= bit << 31;                                                           \
-    if (data) { *data = val; }                                                  \
-  } else {                                                                      \
-    /* Write Transfer */                                                        \
-    val = *data;                                                                \
-    for (n = 31U; n; n--) {                                                     \
-      JTAG_CYCLE_TDI(val);                  /* Set D0..D30 */                   \
-      val >>= 1;                                                                \
-    }                                                                           \
-    n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;                 \
-    if (n) {                                                                    \
-      JTAG_CYCLE_TDI(val);                  /* Set D31 */                       \
-      for (--n; n; n--) {                                                       \
-        JTAG_CYCLE_TCK();                   /* Bypass after data */             \
-      }                                                                         \
-      PIN_TMS_SET();                                                            \
-      JTAG_CYCLE_TCK();                     /* Bypass & Exit1-DR */             \
-    } else {                                                                    \
-      PIN_TMS_SET();                                                            \
-      JTAG_CYCLE_TDI(val);                  /* Set D31 & Exit1-DR */            \
-    }                                                                           \
-  }                                                                             \
-                                                                                \
-exit:                                                                           \
-  JTAG_CYCLE_TCK();                         /* Update-DR */                     \
-  PIN_TMS_CLR();                                                                \
-  JTAG_CYCLE_TCK();                         /* Idle */                          \
-  PIN_TDI_OUT(1U);                                                              \
-                                                                                \
-  /* Capture Timestamp */                                                       \
-  if (request & DAP_TRANSFER_TIMESTAMP) {                                       \
-    DAP_Data.timestamp = TIMESTAMP_GET();                                       \
-  }                                                                             \
-                                                                                \
-  /* Idle cycles */                                                             \
-  n = DAP_Data.transfer.idle_cycles;                                            \
-  while (n--) {                                                                 \
-    JTAG_CYCLE_TCK();                       /* Idle */                          \
-  }                                                                             \
-                                                                                \
-  return ((uint8_t)ack);                                                        \
+#define JTAG_TransferFunction(speed)                                              \
+static uint8_t JTAG_Transfer##speed (uint32_t request, uint32_t *data)            \
+{                                                                                 \
+    uint32_t ack;                                                                 \
+    uint32_t bit;                                                                 \
+    uint32_t val;                                                                 \
+    uint32_t n;                                                                   \
+                                                                                  \
+    PIN_TMS_SET();                                                                \
+    JTAG_CYCLE_TCK();                         /* Select-DR-Scan */                \
+    PIN_TMS_CLR();                                                                \
+    JTAG_CYCLE_TCK();                         /* Capture-DR */                    \
+    JTAG_CYCLE_TCK();                         /* Shift-DR */                      \
+                                                                                  \
+    for (n = DAP_Data.jtag_dev.index; n; n--) {                                   \
+        JTAG_CYCLE_TCK();                       /* Bypass before data */          \
+    }                                                                             \
+                                                                                  \
+    JTAG_CYCLE_TDIO(request >> 1, bit);       /* Set RnW, Get ACK.0 */            \
+    ack  = bit << 1;                                                              \
+    JTAG_CYCLE_TDIO(request >> 2, bit);       /* Set A2,  Get ACK.1 */            \
+    ack |= bit << 0;                                                              \
+    JTAG_CYCLE_TDIO(request >> 3, bit);       /* Set A3,  Get ACK.2 */            \
+    ack |= bit << 2;                                                              \
+                                                                                  \
+    if (ack != DAP_TRANSFER_OK) {                                                 \
+        /* Exit on error */                                                       \
+        PIN_TMS_SET();                                                            \
+        JTAG_CYCLE_TCK();                     /* Exit1-DR */                      \
+        goto exit;                                                                \
+    }                                                                             \
+                                                                                  \
+    if (request & DAP_TRANSFER_RnW) {                                             \
+        /* Read Transfer */                                                       \
+        val = 0U;                                                                 \
+        for (n = 31U; n; n--) {                                                   \
+            JTAG_CYCLE_TDO(bit);               /* Get D0..D30 */                  \
+            val  |= bit << 31;                                                    \
+            val >>= 1;                                                            \
+        }                                                                         \
+        n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;               \
+        if (n) {                                                                  \
+            JTAG_CYCLE_TDO(bit);              /* Get D31 */                       \
+            for (--n; n; n--) {                                                   \
+                JTAG_CYCLE_TCK();             /* Bypass after data */             \
+            }                                                                     \
+            PIN_TMS_SET();                                                        \
+            JTAG_CYCLE_TCK();                 /* Bypass & Exit1-DR */             \
+        } else {                                                                  \
+            PIN_TMS_SET();                                                        \
+            JTAG_CYCLE_TDO(bit);              /* Get D31 & Exit1-DR */            \
+        }                                                                         \
+        val |= bit << 31;                                                         \
+        if (data) {                                                               \
+            *data = val;                                                          \
+        }                                                                         \
+    } else {                                                                      \
+        /* Write Transfer */                                                      \
+        val = *data;                                                              \
+        for (n = 31U; n; n--) {                                                   \
+            JTAG_CYCLE_TDI(val);              /* Set D0..D30 */                   \
+            val >>= 1;                                                            \
+        }                                                                         \
+        n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;               \
+        if (n) {                                                                  \
+            JTAG_CYCLE_TDI(val);              /* Set D31 */                       \
+            for (--n; n; n--) {                                                   \
+                JTAG_CYCLE_TCK();             /* Bypass after data */             \
+            }                                                                     \
+            PIN_TMS_SET();                                                        \
+            JTAG_CYCLE_TCK();                 /* Bypass & Exit1-DR */             \
+        } else {                                                                  \
+            PIN_TMS_SET();                                                        \
+            JTAG_CYCLE_TDI(val);              /* Set D31 & Exit1-DR */            \
+        }                                                                         \
+    }                                                                             \
+                                                                                  \
+exit:                                                                             \
+    JTAG_CYCLE_TCK();                         /* Update-DR */                     \
+    PIN_TMS_CLR();                                                                \
+    JTAG_CYCLE_TCK();                         /* Idle */                          \
+    PIN_TDI_OUT(1U);                                                              \
+                                                                                  \
+    /* Capture Timestamp */                                                       \
+    if (request & DAP_TRANSFER_TIMESTAMP) {                                       \
+        DAP_Data.timestamp = TIMESTAMP_GET();                                     \
+    }                                                                             \
+                                                                                  \
+    /* Idle cycles */                                                             \
+    n = DAP_Data.transfer.idle_cycles;                                            \
+    while (n--) {                                                                 \
+        JTAG_CYCLE_TCK();                     /* Idle */                          \
+    }                                                                             \
+                                                                                  \
+    return ((uint8_t)ack);                                                        \
 }
 
+#ifdef HISPARK_TRACE
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_0()
+JTAG_SequenceFunction(Level0)
+JTAG_IR_Function(Level0)
+JTAG_TransferFunction(Level0)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_1()
+JTAG_SequenceFunction(Level1)
+JTAG_IR_Function(Level1)
+JTAG_TransferFunction(Level1)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_2()
+JTAG_SequenceFunction(Level2)
+JTAG_IR_Function(Level2)
+JTAG_TransferFunction(Level2)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_3()
+JTAG_SequenceFunction(Level3)
+JTAG_IR_Function(Level3)
+JTAG_TransferFunction(Level3)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_4()
+JTAG_SequenceFunction(Level4)
+JTAG_IR_Function(Level4)
+JTAG_TransferFunction(Level4)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_5()
+JTAG_SequenceFunction(Level5)
+JTAG_IR_Function(Level5)
+JTAG_TransferFunction(Level5)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_6()
+JTAG_SequenceFunction(Level6)
+JTAG_IR_Function(Level6)
+JTAG_TransferFunction(Level6)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_7()
+JTAG_SequenceFunction(Level7)
+JTAG_IR_Function(Level7)
+JTAG_TransferFunction(Level7)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_8()
+JTAG_SequenceFunction(Level8)
+JTAG_IR_Function(Level8)
+JTAG_TransferFunction(Level8)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_9()
+JTAG_SequenceFunction(Level9)
+JTAG_IR_Function(Level9)
+JTAG_TransferFunction(Level9)
 
 #undef  PIN_DELAY
+#define PIN_DELAY() JTAGDP_DELAY_LEVEL_LOW(DAP_Data.clock_delay)
+JTAG_SequenceFunction(LevelLow)
+JTAG_IR_Function(LevelLow)
+JTAG_TransferFunction(LevelLow)
+#else /* #ifdef HISPARK_TRACE */
+#undef  PIN_DELAY
 #define PIN_DELAY() PIN_DELAY_FAST()
 JTAG_IR_Function(Fast)
 JTAG_TransferFunction(Fast)
@@ -260,40 +548,41 @@
 #define PIN_DELAY() PIN_DELAY_SLOW(DAP_Data.clock_delay)
 JTAG_IR_Function(Slow)
 JTAG_TransferFunction(Slow)
-
+#endif /* #ifdef HISPARK_TRACE */
 
 // JTAG Read IDCODE register
 //   return: value read
-uint32_t JTAG_ReadIDCode (void) {
-  uint32_t bit;
-  uint32_t val;
-  uint32_t n;
+uint32_t JTAG_ReadIDCode (void) 
+{
+    uint32_t bit;
+    uint32_t val;
+    uint32_t n;
 
-  PIN_TMS_SET();
-  JTAG_CYCLE_TCK();                         /* Select-DR-Scan */
-  PIN_TMS_CLR();
-  JTAG_CYCLE_TCK();                         /* Capture-DR */
-  JTAG_CYCLE_TCK();                         /* Shift-DR */
+    PIN_TMS_SET();
+    JTAG_CYCLE_TCK();                         /* Select-DR-Scan */
+    PIN_TMS_CLR();
+    JTAG_CYCLE_TCK();                         /* Capture-DR */
+    JTAG_CYCLE_TCK();                         /* Shift-DR */
 
-  for (n = DAP_Data.jtag_dev.index; n; n--) {
-    JTAG_CYCLE_TCK();                       /* Bypass before data */
-  }
+    for (n = DAP_Data.jtag_dev.index; n; n--) {
+        JTAG_CYCLE_TCK();                       /* Bypass before data */
+    }
 
-  val = 0U;
-  for (n = 31U; n; n--) {
-    JTAG_CYCLE_TDO(bit);                    /* Get D0..D30 */
-    val  |= bit << 31;
-    val >>= 1;
-  }
-  PIN_TMS_SET();
-  JTAG_CYCLE_TDO(bit);                      /* Get D31 & Exit1-DR */
-  val |= bit << 31;
-
-  JTAG_CYCLE_TCK();                         /* Update-DR */
-  PIN_TMS_CLR();
-  JTAG_CYCLE_TCK();                         /* Idle */
+    val = 0U;
+    for (n = 31U; n; n--) {
+        JTAG_CYCLE_TDO(bit);                    /* Get D0..D30 */
+        val  |= bit << 31;
+        val >>= 1;
+    }
+    PIN_TMS_SET();
+    JTAG_CYCLE_TDO(bit);                      /* Get D31 & Exit1-DR */
+    val |= bit << 31;
 
-  return (val);
+    JTAG_CYCLE_TCK();                         /* Update-DR */
+    PIN_TMS_CLR();
+    JTAG_CYCLE_TCK();                         /* Idle */
+
+    return (val);
 }
 
 
@@ -301,70 +590,199 @@
 //   data:   value to write
 //   return: none
 void JTAG_WriteAbort (uint32_t data) {
-  uint32_t n;
+    uint32_t n;
 
-  PIN_TMS_SET();
-  JTAG_CYCLE_TCK();                         /* Select-DR-Scan */
-  PIN_TMS_CLR();
-  JTAG_CYCLE_TCK();                         /* Capture-DR */
-  JTAG_CYCLE_TCK();                         /* Shift-DR */
+    PIN_TMS_SET();
+    JTAG_CYCLE_TCK();                         /* Select-DR-Scan */
+    PIN_TMS_CLR();
+    JTAG_CYCLE_TCK();                         /* Capture-DR */
+    JTAG_CYCLE_TCK();                         /* Shift-DR */
 
-  for (n = DAP_Data.jtag_dev.index; n; n--) {
-    JTAG_CYCLE_TCK();                       /* Bypass before data */
-  }
+    for (n = DAP_Data.jtag_dev.index; n; n--) {
+        JTAG_CYCLE_TCK();                       /* Bypass before data */
+    }
 
-  PIN_TDI_OUT(0U);
-  JTAG_CYCLE_TCK();                         /* Set RnW=0 (Write) */
-  JTAG_CYCLE_TCK();                         /* Set A2=0 */
-  JTAG_CYCLE_TCK();                         /* Set A3=0 */
-
-  for (n = 31U; n; n--) {
-    JTAG_CYCLE_TDI(data);                   /* Set D0..D30 */
-    data >>= 1;
-  }
-  n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;
-  if (n) {
-    JTAG_CYCLE_TDI(data);                   /* Set D31 */
-    for (--n; n; n--) {
-      JTAG_CYCLE_TCK();                     /* Bypass after data */
+    PIN_TDI_OUT(0U);
+    JTAG_CYCLE_TCK();                         /* Set RnW=0 (Write) */
+    JTAG_CYCLE_TCK();                         /* Set A2=0 */
+    JTAG_CYCLE_TCK();                         /* Set A3=0 */
+
+    for (n = 31U; n; n--) {
+        JTAG_CYCLE_TDI(data);                   /* Set D0..D30 */
+        data >>= 1;
+    }
+    n = DAP_Data.jtag_dev.count - DAP_Data.jtag_dev.index - 1U;
+    if (n) {
+        JTAG_CYCLE_TDI(data);                   /* Set D31 */
+        for (--n; n; n--) {
+            JTAG_CYCLE_TCK();                     /* Bypass after data */
+        }
+        PIN_TMS_SET();
+        JTAG_CYCLE_TCK();                       /* Bypass & Exit1-DR */
+    } else {
+        PIN_TMS_SET();
+        JTAG_CYCLE_TDI(data);                   /* Set D31 & Exit1-DR */
     }
-    PIN_TMS_SET();
-    JTAG_CYCLE_TCK();                       /* Bypass & Exit1-DR */
-  } else {
-    PIN_TMS_SET();
-    JTAG_CYCLE_TDI(data);                   /* Set D31 & Exit1-DR */
-  }
 
-  JTAG_CYCLE_TCK();                         /* Update-DR */
-  PIN_TMS_CLR();
-  JTAG_CYCLE_TCK();                         /* Idle */
-  PIN_TDI_OUT(1U);
+    JTAG_CYCLE_TCK();                         /* Update-DR */
+    PIN_TMS_CLR();
+    JTAG_CYCLE_TCK();                         /* Idle */
+    PIN_TDI_OUT(1U);
 }
 
+#ifdef HISPARK_TRACE
+// Generate JTAG Sequence
+//   info:   sequence information
+//   tdi:    pointer to TDI generated data
+//   tdo:    pointer to TDO captured data
+//   return: none
+void JTAG_Sequence(uint32_t info, const uint8_t *tdi, uint8_t *tdo)
+{ 
+    switch (DAP_Data.clock_level) {
+        case SWD_JTAG_CLOCK_LEVEL_0:
+            JTAG_Sequence_Level0(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_1:
+            JTAG_Sequence_Level1(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_2:
+            JTAG_Sequence_Level2(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_3:
+            JTAG_Sequence_Level3(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_4:
+            JTAG_Sequence_Level4(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_5:
+            JTAG_Sequence_Level5(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_6:
+            JTAG_Sequence_Level6(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_7:
+            JTAG_Sequence_Level7(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_8:
+            JTAG_Sequence_Level8(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_9:
+            JTAG_Sequence_Level9(info, tdi, tdo);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_LOW:
+            JTAG_Sequence_LevelLow(info, tdi, tdo);
+            break;
+        default:
+            JTAG_Sequence_Level5(info, tdi, tdo);
+            break;
+    }
+}
+#endif /* #ifdef HISPARK_TRACE */
+
+uint8_t  JTAG_RESET (void)
+{
+    PIN_TMS_SET();
+    for (int i = 0; i < 8; i++) {
+        JTAG_CYCLE_TCK();
+    }
+    PIN_TMS_CLR();
+    JTAG_CYCLE_TCK();
+    PIN_TDI_OUT(1U);
+    return 0;
+}
 
 // JTAG Set IR
 //   ir:     IR value
 //   return: none
-void JTAG_IR (uint32_t ir) {
-  if (DAP_Data.fast_clock) {
-    JTAG_IR_Fast(ir);
-  } else {
-    JTAG_IR_Slow(ir);
-  }
+void JTAG_IR (uint32_t ir) 
+{
+#ifdef HISPARK_TRACE
+    switch (DAP_Data.clock_level) {
+        case SWD_JTAG_CLOCK_LEVEL_0:
+            JTAG_IR_Level0(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_1:
+            JTAG_IR_Level1(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_2:
+            JTAG_IR_Level2(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_3:
+            JTAG_IR_Level3(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_4:
+            JTAG_IR_Level4(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_5:
+            JTAG_IR_Level5(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_6:
+            JTAG_IR_Level6(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_7:
+            JTAG_IR_Level7(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_8:
+            JTAG_IR_Level8(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_9:
+            JTAG_IR_Level9(ir);
+            break;
+        case SWD_JTAG_CLOCK_LEVEL_LOW:
+            JTAG_IR_LevelLow(ir);
+            break;
+        default:
+            JTAG_IR_Level5(ir);
+            break;
+    }
+#else /* #ifdef HISPARK_TRACE */
+   if (DAP_Data.fast_clock) {
+     JTAG_IR_Fast(ir);
+   } else {
+     JTAG_IR_Slow(ir);
+   }
+#endif /* #ifdef HISPARK_TRACE */
 }
 
-
 // JTAG Transfer I/O
 //   request: A[3:2] RnW APnDP
 //   data:    DATA[31:0]
 //   return:  ACK[2:0]
-uint8_t  JTAG_Transfer(uint32_t request, uint32_t *data) {
-  if (DAP_Data.fast_clock) {
-    return JTAG_TransferFast(request, data);
-  } else {
-    return JTAG_TransferSlow(request, data);
-  }
+uint8_t  JTAG_Transfer(uint32_t request, uint32_t *data)
+{
+#ifdef HISPARK_TRACE
+    switch (DAP_Data.clock_level) {
+        case SWD_JTAG_CLOCK_LEVEL_0:
+            return JTAG_TransferLevel0(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_1:
+            return JTAG_TransferLevel1(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_2:
+            return JTAG_TransferLevel2(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_3:
+            return JTAG_TransferLevel3(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_4:
+            return JTAG_TransferLevel4(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_5:
+            return JTAG_TransferLevel5(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_6:
+            return JTAG_TransferLevel6(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_7:
+            return JTAG_TransferLevel7(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_8:
+            return JTAG_TransferLevel8(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_9:
+            return JTAG_TransferLevel9(request, data);
+        case SWD_JTAG_CLOCK_LEVEL_LOW:
+            return JTAG_TransferLevelLow(request, data);
+        default:
+            return JTAG_TransferLevel5(request, data);
+    }
+#else /* #ifdef HISPARK_TRACE */
+   if (DAP_Data.fast_clock) {
+     return JTAG_TransferFast(request, data);
+   } else {
+     return JTAG_TransferSlow(request, data);
+   }
+#endif /* #ifdef HISPARK_TRACE */
 }
-
-
-#endif  /* (DAP_JTAG != 0) */
+#endif  /* (DAP_JTAG != 0) */
\ No newline at end of file
diff -uNr old/CA7/source/daplink/cmsis-dap/SW_DP.c new/CA7/source/daplink/cmsis-dap/SW_DP.c
--- old/CA7/source/daplink/cmsis-dap/SW_DP.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/SW_DP.c	2023-05-25 15:09:49.000000000 +0800
@@ -27,6 +27,9 @@
 
 #include "DAP_config.h"
 #include "DAP.h"
+#ifdef HISPARK_TRACE
+#include "swd_jtag_config.h"
+#endif /* #ifdef HISPARK_TRACE */
 
 #if defined(__CC_ARM)
 #pragma push
@@ -38,16 +41,216 @@
 #endif
 
 // SW Macros
-
 #define PIN_SWCLK_SET PIN_SWCLK_TCK_SET
 #define PIN_SWCLK_CLR PIN_SWCLK_TCK_CLR
 
-#define SW_CLOCK_CYCLE()                \
-  PIN_SWCLK_CLR();                      \
-  PIN_DELAY();                          \
-  PIN_SWCLK_SET();                      \
-  PIN_DELAY()
+#ifdef HISPARK_TRACE
+inline static void SWDP_DELAY_LEVEL_0(void)
+{
+   __NOP(); __NOP();
+}
+
+inline static void SWDP_DELAY_LEVEL_1(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();
+}
+
+inline static void SWDP_DELAY_LEVEL_2(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
+
+inline static void SWDP_DELAY_LEVEL_3(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
+
+inline static void SWDP_DELAY_LEVEL_4(void)
+{
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+    __NOP();__NOP();__NOP();
+}
+
+inline static void SWDP_DELAY_LEVEL_5(void)
+{
+    volatile uint32_t cnt = 1;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void SWDP_DELAY_LEVEL_6(void)
+{
+    volatile uint32_t cnt = 2;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void SWDP_DELAY_LEVEL_7(void)
+{
+    volatile uint32_t cnt = 3;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void SWDP_DELAY_LEVEL_8(void)
+{
+    volatile uint32_t cnt = 5;
+    while(cnt) {
+        cnt--;
+    }
+}
+
+inline static void SWDP_DELAY_LEVEL_9(void)
+{
+    volatile uint32_t cnt = 11;
+    while(cnt) {
+        cnt--;
+    };
+}
+
+inline static void SWDP_DELAY_LEVEL_LOW(uint32_t delay)
+{
+    volatile uint32_t cnt = 15;
+    while(cnt) {
+        cnt--;
+    }
+}
+#endif /* #ifdef HISPARK_TRACE */
+
+#define SW_CLOCK_CYCLE()                  \
+    PIN_SWCLK_CLR();                      \
+                                          \
+    PIN_DELAY();                          \
+    PIN_SWCLK_SET();                      \
+                                          \
+    PIN_DELAY()
+
+#ifdef HISPARK_TRACE
+#define SW_WRITE_BIT(bit)                 \
+    PIN_SWDIO_OUT(bit);                   \
+    PIN_SWCLK_CLR();                      \
+    __NOP();                              \
+    PIN_DELAY();                          \
+    PIN_SWCLK_SET();                      \
+    __NOP();                              \
+    PIN_DELAY()
+
+#define SW_READ_BIT(bit)                  \
+    PIN_SWCLK_CLR();                      \
+                                          \
+    PIN_DELAY();                          \
+    bit = PIN_SWDIO_IN();                 \
+    PIN_SWCLK_SET();                      \
+    PIN_DELAY()
 
+#define PIN_DELAY() SWDP_DELAY_LEVEL_6()
+#else /* #ifdef HISPARK_TRACE */
 #define SW_WRITE_BIT(bit)               \
   PIN_SWDIO_OUT(bit);                   \
   PIN_SWCLK_CLR();                      \
@@ -63,6 +266,7 @@
   PIN_DELAY()
 
 #define PIN_DELAY() PIN_DELAY_SLOW(DAP_Data.clock_delay)
+#endif /* #ifdef HISPARK_TRACE */
 
 
 // Generate SWJ Sequence
@@ -70,26 +274,27 @@
 //   data:   pointer to sequence bit data
 //   return: none
 #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
-__WEAK void SWJ_Sequence (uint32_t count, const uint8_t *data) {
-  uint32_t val;
-  uint32_t n;
-
-  val = 0U;
-  n = 0U;
-  while (count--) {
-    if (n == 0U) {
-      val = *data++;
-      n = 8U;
-    }
-    if (val & 1U) {
-      PIN_SWDIO_TMS_SET();
-    } else {
-      PIN_SWDIO_TMS_CLR();
+__WEAK void SWJ_Sequence (uint32_t count, const uint8_t *data) 
+{
+    uint32_t val;
+    uint32_t n;
+
+    val = 0U;
+    n = 0U;
+    while (count--) {
+        if (n == 0U) {
+            val = *data++;
+            n = 8U;
+        }
+        if (val & 1U) {
+            PIN_SWDIO_TMS_SET();
+        } else {
+            PIN_SWDIO_TMS_CLR();
+        }
+        SW_CLOCK_CYCLE();
+        val >>= 1;
+        n--;
     }
-    SW_CLOCK_CYCLE();
-    val >>= 1;
-    n--;
-  }
 }
 #endif
 
@@ -100,47 +305,181 @@
 //   swdi:   pointer to SWDIO captured data
 //   return: none
 #if (DAP_SWD != 0)
-__WEAK void SWD_Sequence (uint32_t info, const uint8_t *swdo, uint8_t *swdi) {
-  uint32_t val;
-  uint32_t bit;
-  uint32_t n, k;
-
-  n = info & SWD_SEQUENCE_CLK;
-  if (n == 0U) {
-    n = 64U;
-  }
+__WEAK void SWD_Sequence (uint32_t info, const uint8_t *swdo, uint8_t *swdi) 
+{
+    uint32_t val;
+    uint32_t bit;
+    uint32_t n, k;
 
-  if (info & SWD_SEQUENCE_DIN) {
-    while (n) {
-      val = 0U;
-      for (k = 8U; k && n; k--, n--) {
-        SW_READ_BIT(bit);
-        val >>= 1;
-        val  |= bit << 7;
-      }
-      val >>= k;
-      *swdi++ = (uint8_t)val;
+    n = info & SWD_SEQUENCE_CLK;
+    if (n == 0U) {
+        n = 64U;
     }
-  } else {
-    while (n) {
-      val = *swdo++;
-      for (k = 8U; k && n; k--, n--) {
-        SW_WRITE_BIT(val);
-        val >>= 1;
-      }
+
+    if (info & SWD_SEQUENCE_DIN) {
+        while (n) {
+            val = 0U;
+            for (k = 8U; k && n; k--, n--) {
+                SW_READ_BIT(bit);
+                val >>= 1;
+                val  |= bit << 7;
+            }
+            val >>= k;
+            *swdi++ = (uint8_t)val;
+        }
+    } else {
+        while (n) {
+            val = *swdo++;
+            for (k = 8U; k && n; k--, n--) {
+                SW_WRITE_BIT(val);
+                val >>= 1;
+            }
+        }
     }
-  }
 }
 #endif
 
-
 #if (DAP_SWD != 0)
 
-
 // SWD Transfer I/O
 //   request: A[3:2] RnW APnDP
 //   data:    DATA[31:0]
 //   return:  ACK[2:0]
+#ifdef HISPARK_TRACE
+#define SWD_TransferFunction(speed)                                                 \
+static uint8_t SWD_Transfer##speed (uint32_t request, uint32_t *data)               \
+{                                                                                   \
+    uint32_t ack;                                                                   \
+    uint32_t bit;                                                                   \
+    uint32_t val;                                                                   \
+    uint32_t parity;                                                                \
+                                                                                    \
+    uint32_t n;                                                                     \
+    PIN_SWDIO_OUT_ENABLE();                                                         \
+                                                                                    \
+    /* Packet Request */                                                            \
+    parity = 0U;                                                                    \
+    SW_WRITE_BIT(1U);                     /* Start Bit */                           \
+    bit = request >> 0;                                                             \
+    SW_WRITE_BIT(bit);                    /* APnDP Bit */                           \
+    parity += bit;                                                                  \
+    bit = request >> 1;                                                             \
+    SW_WRITE_BIT(bit);                    /* RnW Bit */                             \
+    parity += bit;                                                                  \
+    bit = request >> 2;                                                             \
+    SW_WRITE_BIT(bit);                    /* A2 Bit */                              \
+    parity += bit;                                                                  \
+    bit = request >> 3;                                                             \
+    SW_WRITE_BIT(bit);                    /* A3 Bit */                              \
+    parity += bit;                                                                  \
+    SW_WRITE_BIT(parity);                 /* Parity Bit */                          \
+    __NOP();__NOP();                                                                \
+    SW_WRITE_BIT(0U);                     /* Stop Bit */                            \
+    __NOP();__NOP();                                                                \
+    SW_WRITE_BIT(1U);                     /* Park Bit */                            \
+    __NOP();__NOP();                                                                \
+                                                                                    \
+    PIN_SWDIO_OUT_DISABLE();                                                        \
+    /* Turnaround */                                                                \
+    for (n = DAP_Data.swd_conf.turnaround; n; n--) {                                \
+        SW_CLOCK_CYCLE();                                                           \
+    }                                                                               \
+                                                                                    \
+    /* Acknowledge response */                                                      \
+    SW_READ_BIT(bit);                                                               \
+    __NOP();                                                                        \
+    ack  = bit << 0;                                                                \
+    SW_READ_BIT(bit);                                                               \
+    ack |= bit << 1;                                                                \
+    SW_READ_BIT(bit);                                                               \
+    ack |= bit << 2;                                                                \
+    if (ack == DAP_TRANSFER_OK) {         /* OK response */                         \
+        /* Data transfer */                                                         \
+        if (request & DAP_TRANSFER_RnW) {                                           \
+            /* Read data */                                                         \
+            val = 0U;                                                               \
+            parity = 0U;                                                            \
+            for (n = 32U; n; n--) {                                                 \
+                SW_READ_BIT(bit);         /* Read RDATA[0:31] */                    \
+                parity += bit;                                                      \
+                val >>= 1;                                                          \
+                val  |= bit << 31;                                                  \
+            }                                                                       \
+            SW_READ_BIT(bit);             /* Read Parity */                         \
+            __NOP();__NOP();__NOP();                                                \
+            if ((parity ^ bit) & 1U) {                                              \
+                ack = DAP_TRANSFER_ERROR;                                           \
+            }                                                                       \
+            if (data) { *data = val; }                                              \
+            /* Turnaround */                                                        \
+            for (n = DAP_Data.swd_conf.turnaround; n; n--) {                        \
+                SW_CLOCK_CYCLE();                                                   \
+                __NOP();__NOP();                                                    \
+            }                                                                       \
+            PIN_SWDIO_OUT_ENABLE();                                                 \
+        } else {                                                                    \
+            /* Turnaround */                                                        \
+            for (n = DAP_Data.swd_conf.turnaround; n; n--) {                        \
+                SW_CLOCK_CYCLE();                                                   \
+                __NOP();__NOP();                                                    \
+            }                                                                       \
+            PIN_SWDIO_OUT_ENABLE();                                                 \
+            /* Write data */                                                        \
+            val = *data;                                                            \
+            parity = 0U;                                                            \
+            for (n = 32U; n; n--) {                                                 \
+                SW_WRITE_BIT(val);              /* Write WDATA[0:31] */             \
+                parity += val;                                                      \
+                val >>= 1;                                                          \
+            }                                                                       \
+            SW_WRITE_BIT(parity);             /* Write Parity Bit */                \
+        }                                                                           \
+        /* Capture Timestamp */                                                     \
+        if (request & DAP_TRANSFER_TIMESTAMP) {                                     \
+            DAP_Data.timestamp = TIMESTAMP_GET();                                   \
+        }                                                                           \
+        /* Idle cycles */                                                           \
+        n = DAP_Data.transfer.idle_cycles;                                          \
+        if (n) {                                                                    \
+            PIN_SWDIO_OUT(0U);                                                      \
+            for (; n; n--) {                                                        \
+                SW_CLOCK_CYCLE();                                                   \
+            }                                                                       \
+        }                                                                           \
+        PIN_SWDIO_OUT(1U);                                                          \
+        return ((uint8_t)ack);                                                      \
+    }                                                                               \
+                                                                                    \
+    if ((ack == DAP_TRANSFER_WAIT) || (ack == DAP_TRANSFER_FAULT)) {                \
+        /* WAIT or FAULT response */                                                \
+        if (DAP_Data.swd_conf.data_phase && ((request & DAP_TRANSFER_RnW) != 0U)) { \
+            for (n = 32U+1U; n; n--) {                                              \
+                SW_CLOCK_CYCLE();           /* Dummy Read RDATA[0:31] + Parity */   \
+            }                                                                       \
+        }                                                                           \
+        /* Turnaround */                                                            \
+        for (n = DAP_Data.swd_conf.turnaround; n; n--) {                            \
+            SW_CLOCK_CYCLE();                                                       \
+        }                                                                           \
+        PIN_SWDIO_OUT_ENABLE();                                                     \
+        if (DAP_Data.swd_conf.data_phase && ((request & DAP_TRANSFER_RnW) == 0U)) { \
+            PIN_SWDIO_OUT(0U);                                                      \
+            for (n = 32U+1U; n; n--) {                                              \
+                SW_CLOCK_CYCLE();           /* Dummy Write WDATA[0:31] + Parity */  \
+            }                                                                       \
+        }                                                                           \
+        PIN_SWDIO_OUT(1U);                                                          \
+        return ((uint8_t)ack);                                                      \
+    }                                                                               \
+    /* Protocol error */                                                            \
+    for (n = DAP_Data.swd_conf.turnaround + 32U + 1U; n; n--) {                     \
+        SW_CLOCK_CYCLE();                   /* Back off data phase */               \
+    }                                                                               \
+    PIN_SWDIO_OUT_ENABLE();                                                         \
+    PIN_SWDIO_OUT(1U);                                                              \
+    return ((uint8_t)ack);                                                          \
+}
+#else /* #ifdef HISPARK_TRACE */
 #define SWD_TransferFunction(speed)     /**/                                    \
 static uint8_t SWD_Transfer##speed (uint32_t request, uint32_t *data) {         \
   uint32_t ack;                                                                 \
@@ -267,7 +606,54 @@
   PIN_SWDIO_OUT(1U);                                                            \
   return ((uint8_t)ack);                                                        \
 }
+#endif /* #ifdef HISPARK_TRACE */
+
+#ifdef HISPARK_TRACE
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_0()
+SWD_TransferFunction(Level0)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_1()
+SWD_TransferFunction(Level1)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_2()
+SWD_TransferFunction(Level2)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_3()
+SWD_TransferFunction(Level3)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_4()
+SWD_TransferFunction(Level4)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_5()
+SWD_TransferFunction(Level5)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_6()
+SWD_TransferFunction(Level6)
 
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_7()
+SWD_TransferFunction(Level7)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_8()
+SWD_TransferFunction(Level8)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_9()
+SWD_TransferFunction(Level9)
+
+#undef  PIN_DELAY
+#define PIN_DELAY() SWDP_DELAY_LEVEL_LOW(DAP_Data.clock_delay)
+SWD_TransferFunction(LevelLow)
+#else /* #ifdef HISPARK_TRACE */
 
 #undef  PIN_DELAY
 #define PIN_DELAY() PIN_DELAY_FAST()
@@ -277,23 +663,51 @@
 #define PIN_DELAY() PIN_DELAY_SLOW(DAP_Data.clock_delay)
 SWD_TransferFunction(Slow)
 
+#endif /* #ifdef HISPARK_TRACE */
 
 // SWD Transfer I/O
 //   request: A[3:2] RnW APnDP
 //   data:    DATA[31:0]
 //   return:  ACK[2:0]
 __WEAK uint8_t  SWD_Transfer(uint32_t request, uint32_t *data) {
+#ifdef HISPARK_TRACE
+  switch (DAP_Data.clock_level) {
+	    case SWD_JTAG_CLOCK_LEVEL_0:
+	    	return SWD_TransferLevel0(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_1:
+	    	return SWD_TransferLevel1(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_2:
+	    	return SWD_TransferLevel2(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_3:
+	    	return SWD_TransferLevel3(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_4:
+	    	return SWD_TransferLevel4(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_5:
+	    	return SWD_TransferLevel5(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_6:
+	    	return SWD_TransferLevel6(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_7:
+	    	    	return SWD_TransferLevel7(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_8:
+	    	    	return SWD_TransferLevel8(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_9:
+	    	    	return SWD_TransferLevel9(request, data);
+	    case SWD_JTAG_CLOCK_LEVEL_LOW:
+	    	return SWD_TransferLevelLow(request, data);
+	    default:
+	    	return SWD_TransferLevel6(request, data);
+	}
+#else /* #ifdef HISPARK_TRACE */
   if (DAP_Data.fast_clock) {
     return SWD_TransferFast(request, data);
   } else {
     return SWD_TransferSlow(request, data);
   }
+#endif /* #ifdef HISPARK_TRACE */
 }
 
-
 #endif  /* (DAP_SWD != 0) */
 
-
 #if defined(__CC_ARM)
 #pragma pop
 #elif defined(__GNUC__) && !defined(__ARMCC_VERSION)
diff -uNr old/CA7/source/daplink/cmsis-dap/SWO.c new/CA7/source/daplink/cmsis-dap/SWO.c
--- old/CA7/source/daplink/cmsis-dap/SWO.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cmsis-dap/SWO.c	2023-05-25 15:09:49.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2021 ARM Limited. All rights reserved.
+ * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -17,8 +17,8 @@
  *
  * ----------------------------------------------------------------------
  *
- * $Date:        29. March 2021
- * $Revision:    V2.0.1
+ * $Date:        1. December 2017
+ * $Revision:    V2.0.0
  *
  * Project:      CMSIS-DAP Source
  * Title:        SWO.c CMSIS-DAP SWO I/O
@@ -32,8 +32,6 @@
 #endif
 #if (SWO_STREAM != 0)
 #include "cmsis_os2.h"
-#define   osObjectsExternal
-#include "osObjects.h"
 #endif
 
 #if (SWO_STREAM != 0)
@@ -44,11 +42,15 @@
 
 #if (SWO_UART != 0)
 
+#ifndef  SWO_USART_PORT
+#define  SWO_USART_PORT 0           /* USART Port Number */
+#endif
+
 // USART Driver
 #define _USART_Driver_(n)  Driver_USART##n
 #define  USART_Driver_(n) _USART_Driver_(n)
-extern ARM_DRIVER_USART    USART_Driver_(SWO_UART_DRIVER);
-#define pUSART           (&USART_Driver_(SWO_UART_DRIVER))
+extern ARM_DRIVER_USART    USART_Driver_(SWO_USART_PORT);
+#define pUSART           (&USART_Driver_(SWO_USART_PORT))
 
 static uint8_t USART_Ready = 0U;
 
@@ -148,10 +150,10 @@
   }
 }
 
-// Enable or disable SWO Mode (UART)
+// Enable or disable UART SWO Mode
 //   enable: enable flag
 //   return: 1 - Success, 0 - Error
-__WEAK uint32_t SWO_Mode_UART (uint32_t enable) {
+__WEAK uint32_t SWO_MODE_UART (uint32_t enable) {
   int32_t status;
 
   USART_Ready = 0U;
@@ -175,7 +177,7 @@
   return (1U);
 }
 
-// Configure SWO Baudrate (UART)
+// Configure UART SWO Baudrate
 //   baudrate: requested baudrate
 //   return:   actual baudrate or 0 when not configured
 __WEAK uint32_t SWO_Baudrate_UART (uint32_t baudrate) {
@@ -221,10 +223,10 @@
   return (baudrate);
 }
 
-// Control SWO Capture (UART)
+// Control UART SWO Capture
 //   active: active flag
 //   return: 1 - Success, 0 - Error
-__WEAK uint32_t SWO_Control_UART (uint32_t active) {
+__WEAK uint32_t SWO_CONTROL_UART (uint32_t active) {
   int32_t status;
 
   if (active) {
@@ -250,7 +252,7 @@
   return (1U);
 }
 
-// Start SWO Capture (UART)
+// Start UART SWO Capture
 //   buf: pointer to buffer for capturing
 //   num: number of bytes to capture
 __WEAK void SWO_Capture_UART (uint8_t *buf, uint32_t num) {
@@ -258,7 +260,7 @@
   pUSART->Receive(buf, num);
 }
 
-// Get SWO Pending Trace Count (UART)
+// Get UART SWO Pending Trace Count
 //   return: number of pending trace data bytes
 __WEAK uint32_t SWO_GetCount_UART (void) {
   uint32_t count;
@@ -276,36 +278,36 @@
 
 #if (SWO_MANCHESTER != 0)
 
-// Enable or disable SWO Mode (Manchester)
+// Enable or disable Manchester SWO Mode
 //   enable: enable flag
 //   return: 1 - Success, 0 - Error
-__WEAK uint32_t SWO_Mode_Manchester (uint32_t enable) {
+__WEAK uint32_t Manchester_SWO_Mode (uint32_t enable) {
   return (0U);
 }
 
-// Configure SWO Baudrate (Manchester)
+// Configure Manchester SWO Baudrate
 //   baudrate: requested baudrate
 //   return:   actual baudrate or 0 when not configured
 __WEAK uint32_t SWO_Baudrate_Manchester (uint32_t baudrate) {
   return (0U);
 }
 
-// Control SWO Capture (Manchester)
+// Control Manchester SWO Capture
 //   active: active flag
 //   return: 1 - Success, 0 - Error
-__WEAK uint32_t SWO_Control_Manchester (uint32_t active) {
+__WEAK uint32_t Manchester_SWO_Control (uint32_t active) {
   return (0U);
 }
 
-// Start SWO Capture (Manchester)
+// Start Manchester SWO Capture
 //   buf: pointer to buffer for capturing
 //   num: number of bytes to capture
-__WEAK void SWO_Capture_Manchester (uint8_t *buf, uint32_t num) {
+__WEAK void Manchester_SWO_Capture (uint8_t *buf, uint32_t num) {
 }
 
-// Get SWO Pending Trace Count (Manchester)
+// Get Manchester SWO Pending Trace Count
 //   return: number of pending trace data bytes
-__WEAK uint32_t SWO_GetCount_Manchester (void) {
+__WEAK uint32_t Manchester_SWO_GetCount (void) {
 }
 
 #endif  /* (SWO_MANCHESTER != 0) */
@@ -349,13 +351,13 @@
 #if (SWO_UART != 0)
         case DAP_SWO_UART:
           TraceStatus = DAP_SWO_CAPTURE_ACTIVE;
-          SWO_Capture_UART(&TraceBuf[index_i], 1U);
+          UART_SWO_Capture(&TraceBuf[index_i], 1U);
           break;
 #endif
 #if (SWO_MANCHESTER != 0)
         case DAP_SWO_MANCHESTER:
           TraceStatus = DAP_SWO_CAPTURE_ACTIVE;
-          SWO_Capture_Manchester(&TraceBuf[index_i], 1U);
+          Manchester_SWO_Capture(&TraceBuf[index_i], 1U);
           break;
 #endif
         default:
@@ -377,12 +379,12 @@
       switch (TraceMode) {
 #if (SWO_UART != 0)
         case DAP_SWO_UART:
-          count += SWO_GetCount_UART();
+          count += UART_SWO_GetCount();
           break;
 #endif
 #if (SWO_MANCHESTER != 0)
         case DAP_SWO_MANCHESTER:
-          count += SWO_GetCount_Manchester();
+          count += Manchester_SWO_GetCount();
           break;
 #endif
         default:
@@ -469,12 +471,12 @@
   switch (TraceMode) {
 #if (SWO_UART != 0)
     case DAP_SWO_UART:
-      SWO_Mode_UART(0U);
+      SWO_MODE_UART(0U);
       break;
 #endif
 #if (SWO_MANCHESTER != 0)
     case DAP_SWO_MANCHESTER:
-      SWO_Mode_Manchester(0U);
+      Manchester_SWO_Mode(0U);
       break;
 #endif
     default:
@@ -487,12 +489,12 @@
       break;
 #if (SWO_UART != 0)
     case DAP_SWO_UART:
-      result = SWO_Mode_UART(1U);
+      result = SWO_MODE_UART(1U);
       break;
 #endif
 #if (SWO_MANCHESTER != 0)
     case DAP_SWO_MANCHESTER:
-      result = SWO_Mode_Manchester(1U);
+      result = Manchester_SWO_Mode(1U);
       break;
 #endif
     default:
@@ -533,12 +535,12 @@
   switch (TraceMode) {
 #if (SWO_UART != 0)
     case DAP_SWO_UART:
-      baudrate = SWO_Baudrate_UART(baudrate);
+      baudrate = SWO_BAUDRATE_UART(baudrate);
       break;
 #endif
 #if (SWO_MANCHESTER != 0)
     case DAP_SWO_MANCHESTER:
-      baudrate = SWO_Baudrate_Manchester(baudrate);
+      baudrate = Manchester_SWO_Baudrate(baudrate);
       break;
 #endif
     default:
@@ -577,12 +579,12 @@
     switch (TraceMode) {
 #if (SWO_UART != 0)
       case DAP_SWO_UART:
-        result = SWO_Control_UART(active);
+        result = SWO_CONTROL_UART(active);
         break;
 #endif
 #if (SWO_MANCHESTER != 0)
       case DAP_SWO_MANCHESTER:
-        result = SWO_Control_Manchester(active);
+        result = Manchester_SWO_Control(active);
         break;
 #endif
       default:
diff -uNr old/CA7/source/daplink/compiler.h new/CA7/source/daplink/compiler.h
--- old/CA7/source/daplink/compiler.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/compiler.h	2023-05-25 15:09:49.000000000 +0800
@@ -37,7 +37,11 @@
 // The special value '__COUNTER__' is used to create a unique value to
 // append to 'compiler_assert_' to create a unique token.  This prevents
 // conflicts resulting from the same enum being declared multiple times.
+#if defined(HISPARK_TRACE)
+#define COMPILER_ASSERT(e)
+#else
 #define COMPILER_ASSERT(e) enum { COMPILER_CONCAT(compiler_assert_, __COUNTER__) = 1/((e) ? 1 : 0) }
+#endif
 
 // Macros to disable optimisation of a function.
 #if (defined(__ICCARM__))
diff -uNr old/CA7/source/daplink/cortex_m.c new/CA7/source/daplink/cortex_m.c
--- old/CA7/source/daplink/cortex_m.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cortex_m.c	2023-05-25 15:09:49.000000000 +0800
@@ -23,5 +23,7 @@
 
 __WEAK void SystemReset(void)
 {
-    NVIC_SystemReset();
+#ifndef HISPARK_TRACE    
+	NVIC_SystemReset();
+#endif	
 }
diff -uNr old/CA7/source/daplink/cortex_m.h new/CA7/source/daplink/cortex_m.h
--- old/CA7/source/daplink/cortex_m.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/cortex_m.h	2023-05-25 15:09:49.000000000 +0800
@@ -34,15 +34,21 @@
 
 __STATIC_FORCEINLINE cortex_int_state_t cortex_int_get_and_disable(void)
 {
+#ifdef HISPARK_TRACE
+    cortex_int_state_t state = 0;
+#else
     cortex_int_state_t state;
     state = __get_PRIMASK();
+#endif	
     __disable_irq();
     return state;
 }
 
 __STATIC_FORCEINLINE void cortex_int_restore(cortex_int_state_t state)
 {
+#ifndef HISPARK_TRACE
     __set_PRIMASK(state);
+#endif
 }
 
 __STATIC_FORCEINLINE bool cortex_in_isr(void)
diff -uNr old/CA7/source/daplink/daplink_debug.h new/CA7/source/daplink/daplink_debug.h
--- old/CA7/source/daplink/daplink_debug.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/daplink_debug.h	2023-05-25 15:09:49.000000000 +0800
@@ -26,6 +26,11 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdint.h>
+#if defined (HISPARK_TRACE)
+#include "cmsis_os2.h"
+#include "rl_usb.h"
+#include "util.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -37,9 +42,56 @@
 
 #if defined (DAPLINK_DEBUG)
 
+#if defined (HISPARK_TRACE)
+static const char error_msg[] = "\r\n<OVERFLOW>\r\n";
+
+static inline uint32_t daplink_debug(uint8_t *buf, uint32_t size)
+{
+    uint32_t total_free;
+    uint32_t write_free;
+    uint32_t error_len = strlen(error_msg);
+    total_free = USBD_CDC_ACM_DataFree();
+
+    if (total_free < error_len) {
+        // No space
+        return 0;
+    }
+
+    // Size available for writing
+    write_free = total_free - error_len;
+    size = MIN(write_free, size);
+    USBD_CDC_ACM_DataSend(buf, size);
+
+    if (write_free == size) {
+        USBD_CDC_ACM_DataSend((uint8_t *)error_msg, error_len);
+    }
+
+    return size;
+}
+
+static char daplink_debug_buf[128] = {0};
+static inline uint32_t daplink_debug_print(const char *format, ...)
+{
+    uint32_t ret;
+    int32_t r = 0;
+    va_list arg;
+    ret = 1;
+    va_start(arg, format);
+    r = vsnprintf(daplink_debug_buf, sizeof(daplink_debug_buf), format, arg);
+
+    if (r >= sizeof(daplink_debug_buf)) {
+        r = snprintf(daplink_debug_buf, sizeof(daplink_debug_buf), "<Error - string length %i exceeds print buffer>\r\n", r);
+        ret = 0;
+    }
+
+    va_end(arg);
+    daplink_debug((uint8_t *)daplink_debug_buf, r);
+    return ret;
+}
+#else
 uint32_t daplink_debug_print(const char *format, ...);
 uint32_t daplink_debug(uint8_t *data, uint32_t size);
-
+#endif
 #else
 
 static inline uint32_t daplink_debug_print(const char *format, ...)
@@ -57,8 +109,8 @@
 #define debug_msg(fmt, args...) daplink_debug_print(fmt, ## args);
 #define debug_data(buf, size) daplink_debug(buf, size);
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
+
+#endif
diff -uNr old/CA7/source/daplink/daplink.h new/CA7/source/daplink/daplink.h
--- old/CA7/source/daplink/daplink.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/daplink.h	2023-05-25 15:09:49.000000000 +0800
@@ -66,6 +66,9 @@
 #define DAPLINK_HIC_ID_STM32F723IE  0x9796990D // reserving for future use
 #define DAPLINK_HIC_ID_LPC55XX      0x4C504355 // 'LPC\x55'
 #define DAPLINK_HIC_ID_M48SSIDAE    0x97969921
+#ifdef HISPARK_TRACE
+#define DAPLINK_HIC_ID_STM32MP153   0x97969949
+#endif
 #define DAPLINK_HIC_ID_PSOC5        0x2E127069
 #define DAPLINK_HIC_ID_NRF52820     0x6E052820 // 'n\x05\x28\x20'
 //@}
diff -uNr old/CA7/source/daplink/drag-n-drop/file_stream.c new/CA7/source/daplink/drag-n-drop/file_stream.c
--- old/CA7/source/daplink/drag-n-drop/file_stream.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/file_stream.c	2023-05-25 15:09:49.000000000 +0800
@@ -30,6 +30,12 @@
 #include "compiler.h"
 #include "validation.h"
 
+#ifdef HISPARK_TRACE
+#include "target_lib_manager.h"
+#include "factory_manager.h"
+#include "config_storage_update.h"
+#endif /* #ifdef HISPARK_TRACE */
+
 typedef enum {
     STREAM_STATE_CLOSED,
     STREAM_STATE_OPEN,
@@ -53,6 +59,12 @@
     uint8_t vector_buf[FLASH_DECODER_MIN_SIZE];
     uint8_t buf_pos;
     uint32_t flash_addr;
+#ifdef HISPARK_TRACE
+    uint8_t name_buf[TARGET_LIB_IMAGE_NAME_MAX_LEN];
+    uint8_t name_len;
+    uint8_t name_buf_pos;
+    uint8_t image_flag;
+#endif /* #ifdef HISPARK_TRACE */
 } bin_state_t;
 
 typedef struct {
@@ -151,7 +163,6 @@
     if (ERROR_SUCCESS != status) {
         state = STREAM_STATE_ERROR;
     }
-
     return status;
 }
 
@@ -218,6 +229,20 @@
 
 static error_t write_bin(void *state, const uint8_t *data, uint32_t size)
 {
+#ifdef HISPARK_TRACE
+    error_t status;
+    bin_state_t *bin_state = (bin_state_t *)state;
+    flash_decoder_type_t flash_type;
+    uint32_t size_left;
+    uint32_t copy_size;
+    uint32_t start_addr;
+    const flash_intf_t *flash_intf;
+    int32_t end_addr = 0;
+    flash_decoder_head_t info;
+    TargetFlashInfo targetFlashInfo;
+
+    if (bin_state->buf_pos < FLASH_DECODER_MIN_SIZE || bin_state->image_flag == 1) {
+#else 
     error_t status;
     bin_state_t *bin_state = (bin_state_t *)state;
 
@@ -227,6 +252,7 @@
         uint32_t copy_size;
         uint32_t start_addr;
         const flash_intf_t *flash_intf;
+#endif /* #ifdef HISPARK_TRACE */
         // Buffer Data
         size_left = FLASH_DECODER_MIN_SIZE - bin_state->buf_pos;
         copy_size = MIN(size_left, size);
@@ -247,6 +273,47 @@
             return ERROR_FD_UNSUPPORTED_UPDATE;
         }
 
+#ifdef HISPARK_TRACE
+        if (FLASH_DECODER_TYPE_TARGET_ALGO == flash_type ||
+            FLASH_DECODER_TYPE_TARGET_IMAGE == flash_type) {
+            memcpy(&info, bin_state->vector_buf, sizeof(info));
+            targetFlashInfo.regioninfo = info.region_info;
+            targetFlashInfo.flashID = info.vendor_flash_algo;
+            targetFlashInfo.fileSize = info.size;
+            targetFlashInfo.modelID = info.vendor_model;
+            targetFlashInfo.vendorID = info.vendor;
+            targetFlashInfo.version = info.version;
+            targetFlashInfo.fileCrc32 = info.crc_value;
+            targetFlashInfo.oldNamelen = info.nameLen;
+            targetFlashInfo.targetAddr = info.targetAddr;
+            targetFlashInfo.maxLoads = info.maxLoads;
+
+            if (FLASH_DECODER_TYPE_TARGET_ALGO == flash_type) {
+                if (FactoryStatusGet() == FACTORY_FLAG_IS_SET) {
+                    FactoryAlgoChange(targetFlashInfo);
+                } else {
+                    TargetLibAlgoAdd(targetFlashInfo);
+                }
+            } else {
+                bin_state->image_flag = 1;
+                size_left = info.nameLen - bin_state->name_buf_pos;
+                copy_size = MIN(size_left, size);
+                memcpy(bin_state->name_buf + bin_state->name_buf_pos, data, copy_size);
+                bin_state->name_buf_pos += copy_size;
+                if (bin_state->name_buf_pos < info.nameLen) {
+                    return ERROR_SUCCESS;
+                }
+                if (FactoryStatusGet() == FACTORY_FLAG_IS_SET) {
+                    FactoryImageChange(targetFlashInfo, bin_state->name_buf, info.nameLen);
+                } else {
+                    TargetLibImageAdd(targetFlashInfo, bin_state->name_buf, info.nameLen);
+                }
+                bin_state->image_flag = 0;
+                data += copy_size;
+                size -= copy_size;
+            }
+        }
+#endif /* #ifdef HISPARK_TRACE */
         // Determine flash addresss
         status = flash_decoder_get_flash(flash_type, 0, false, &start_addr, &flash_intf);
 
@@ -261,17 +328,25 @@
         if (ERROR_SUCCESS != status) {
             return status;
         }
-
+#ifdef HISPARK_TRACE
+        if (flash_type == FLASH_DECODER_TYPE_TARGET) {
+             bin_state->flash_addr += bin_state->buf_pos;
+        }
+#else /* #ifdef HISPARK_TRACE */
         bin_state->flash_addr += bin_state->buf_pos;
+#endif /* #ifdef HISPARK_TRACE */
     }
 
     // Write data
+#ifdef HISPARK_TRACE
+    end_addr = ConfigLoadEndAddrGet();
+    size = (end_addr - bin_state->flash_addr) > size ? size : (end_addr - bin_state->flash_addr);
+#endif /* #ifdef HISPARK_TRACE */
     status = flash_decoder_write(bin_state->flash_addr, data, size);
 
     if (ERROR_SUCCESS != status) {
         return status;
     }
-
     bin_state->flash_addr += size;
     // There is no way to determine the end of a binary
     // file so any point could be the end
diff -uNr old/CA7/source/daplink/drag-n-drop/flash_decoder.c new/CA7/source/daplink/drag-n-drop/flash_decoder.c
--- old/CA7/source/daplink/drag-n-drop/flash_decoder.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/flash_decoder.c	2023-05-25 15:09:49.000000000 +0800
@@ -31,6 +31,14 @@
 #include "target_board.h"
 #include "cmsis_compiler.h"
 
+#ifdef HISPARK_TRACE
+#include "target_lib_manager.h"
+#include "config_storage_update.h"
+#include "factory_manager.h"
+#include "offline_sys_config.h"
+#include "status.h"
+#endif /* #ifdef HISPARK_TRACE */
+
 // Set to 1 to enable debugging
 #define DEBUG_FLASH_DECODER     0
 
@@ -65,6 +73,57 @@
     return 0;   // Return 0 if image is compatible
 }
 
+#ifdef HISPARK_TRACE
+flash_decoder_type_t flash_decoder_detect_type(const uint8_t *data, uint32_t size, uint32_t addr, bool addr_valid)
+{
+    flash_decoder_head_t info;
+    util_assert(size >= FLASH_DECODER_MIN_SIZE);
+
+    // Check if this is a daplink image
+    memcpy(&info, data, sizeof(info));
+    if(!addr_valid){ //reset until we know the binary type
+        flash_type_target_bin = false;
+    }
+
+    if (info.magic_head == FLASH_DECODER_MAGIC_HEAD) {
+        ConfigLoadCurrentFileSizeSet(info.size);
+        if (FLASH_DECODER_FILE_TYPE_IF == info.file_type) {
+            // Interface update
+            return FLASH_DECODER_TYPE_INTERFACE;
+        } else if (FLASH_DECODER_FILE_TYPE_BL == info.file_type) {
+            // Bootloader update
+            return FLASH_DECODER_TYPE_BOOTLOADER;
+        } else if (FLASH_DECODER_FILE_TYPE_TARGET_ALGO == info.file_type){
+            return FLASH_DECODER_TYPE_TARGET_ALGO;
+        } else if (FLASH_DECODER_FILE_TYPE_TARGET_IMAGE == info.file_type){
+            return FLASH_DECODER_TYPE_TARGET_IMAGE;
+        } else if (FLASH_DECODER_FILE_TYPE_TARGET == info.file_type){
+            if(!addr_valid){ //binary is a bin type
+                flash_type_target_bin = true;
+            }
+            return FLASH_DECODER_TYPE_TARGET;
+        } else {
+            return FLASH_DECODER_TYPE_UNKNOWN;
+        }
+    }
+
+    // Check if a valid vector table for the target can be found
+    if (validate_bin_nvic(data)) {
+        if(!addr_valid){ //binary is a bin type
+            flash_type_target_bin = true;
+        }
+        return FLASH_DECODER_TYPE_TARGET;
+    }
+
+    // If an address is specified then the data can be decoded
+    if (addr_valid) {
+        // TODO - future improvement - make sure address is within target's flash
+        return FLASH_DECODER_TYPE_TARGET;
+    }
+
+    return FLASH_DECODER_TYPE_UNKNOWN;
+}
+#else /* #ifdef HISPARK_TRACE */
 flash_decoder_type_t flash_decoder_detect_type(const uint8_t *data, uint32_t size, uint32_t addr, bool addr_valid)
 {
     daplink_info_t info;
@@ -102,7 +161,158 @@
 
     return FLASH_DECODER_TYPE_UNKNOWN;
 }
+#endif /* #ifdef HISPARK_TRACE */
 
+#ifdef HISPARK_TRACE
+error_t flash_decoder_get_flash(flash_decoder_type_t type, uint32_t addr, bool addr_valid, uint32_t *start_addr, const flash_intf_t **flash_intf)
+{
+    error_t status = ERROR_SUCCESS;
+    uint32_t flash_start_local;
+    const flash_intf_t *flash_intf_local = 0;
+    int endAddr = 0;
+    uint32_t file_len = 0;
+    DapLinkStatus daplinkStatus;
+
+    if ((0 == start_addr) || (0 == flash_intf)) {
+        util_assert(0);
+        return ERROR_INTERNAL;
+    }
+
+    *start_addr = 0;
+    *flash_intf = 0;
+    flash_start_local = 0;
+    flash_intf_local = 0;
+
+    if (daplink_is_bootloader()) {
+        if (FLASH_DECODER_TYPE_INTERFACE == type) {
+            if (addr_valid && (DAPLINK_ROM_IF_START != addr)) {
+                // Address is wrong so display error message
+                status = ERROR_FD_INTF_UPDT_ADDR_WRONG;
+            } else {
+                // Setup for update
+                flash_start_local = DAPLINK_ROM_IF_START;
+                flash_intf_local = flash_intf_iap_protected;
+            }
+        } else if (FLASH_DECODER_TYPE_TARGET == type) {
+            if (addr_valid && (DAPLINK_ROM_IF_START != addr)) {
+                // Address is wrong so display error message
+                status = ERROR_FD_INTF_UPDT_ADDR_WRONG;
+            } else {
+                // "Target" update in this case would be a 3rd party interface application
+                flash_start_local = DAPLINK_ROM_IF_START;
+                flash_intf_local = flash_intf_iap_protected;
+            }
+        } else {
+            status = ERROR_FD_UNSUPPORTED_UPDATE;
+        }
+    } else if (daplink_is_interface()) {
+        file_len = ConfigLoadCurrentFileSizeGet();
+        if (FLASH_DECODER_TYPE_BOOTLOADER == type) {
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_BOOT);
+            if (addr_valid && (DAPLINK_ROM_BL_START != addr)) {
+                // Address is wrong so display error message
+                status = ERROR_FD_BL_UPDT_ADDR_WRONG;
+            } else {
+                // Setup for update
+                flash_start_local = DAPLINK_ROM_BL_START;
+                flash_intf_local = flash_intf_iap_protected;
+                endAddr = flash_start_local + (CONFIG_STORAGE_MAX_BOOT_SIZE > file_len ? file_len : CONFIG_STORAGE_MAX_BOOT_SIZE);
+                ConfigLoadEndAddrSet(endAddr);
+            }
+        } else if (FLASH_DECODER_TYPE_TARGET == type) {
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_TARGET);
+            if (g_board_info.target_cfg) {
+                region_info_t * region = g_board_info.target_cfg->flash_regions;
+                for (; region->start != 0 || region->end != 0; ++region) {
+                    if (kRegionIsDefault == region->flags) {
+                        flash_start_local = region->start;
+                        endAddr = region->end;
+                        ConfigLoadEndAddrSet(endAddr);
+                        break;
+                    }
+                }
+                flash_intf_local = flash_intf_target;
+            } else {
+                status = ERROR_FD_UNSUPPORTED_UPDATE;
+            }
+        } else if (FLASH_DECODER_TYPE_TARGET_IMAGE == type) {
+            DapLinkStatusGet(&daplinkStatus);
+            daplinkStatus.imageStoreStatus = IMAGE_STORE_IDLE;
+            DapLinkStatusSet(&daplinkStatus);
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_IMAGE);
+            if (FactoryStatusGet() == FACTORY_FLAG_IS_SET) {
+                flash_start_local = FactoryLibStartAddrGet(TARGET_LIB_TYPE_IMAGE);
+            } else {
+                flash_start_local = TargetLibStartAddrGet(TARGET_LIB_TYPE_IMAGE);
+            }
+            endAddr = flash_start_local + (CONFIG_STORAGE_ONE_IMAGE_MAX_SIZE > file_len ? file_len : CONFIG_STORAGE_ONE_IMAGE_MAX_SIZE);
+            ConfigLoadEndAddrSet(endAddr);
+            if (addr_valid && (flash_start_local != addr)) {
+                flash_start_local = 0;
+                status = ERROR_FD_BL_UPDT_ADDR_WRONG;
+            } else {
+                flash_intf_local = flash_intf_iap_protected;
+            }
+        }else if (FLASH_DECODER_TYPE_TARGET_ALGO == type) {
+            DapLinkStatusGet(&daplinkStatus);
+            daplinkStatus.algoStoreStatus = ALGORITHM_STORE_IDLE;
+            DapLinkStatusSet(&daplinkStatus);
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_ALGO);
+            flash_start_local = TargetLibStartAddrGet(TARGET_LIB_TYPE_ALGO);
+            endAddr = flash_start_local + (CONFIG_STORAGE_ONE_ALGO_MAX_SIZE > file_len ? file_len : CONFIG_STORAGE_ONE_ALGO_MAX_SIZE);
+            ConfigLoadEndAddrSet(endAddr);
+            if (addr_valid && (flash_start_local != addr)) {
+                flash_start_local = 0;
+                status = ERROR_FD_BL_UPDT_ADDR_WRONG;
+            } else {
+                flash_intf_local = flash_intf_iap_protected;
+            }
+        } else if (FLASH_DECODER_TYPE_INTERFACE == type) {
+            DapLinkStatusGet(&daplinkStatus);
+            daplinkStatus.fwUpgradeStatus = FIRMWARE_UPGRADE_IDLE;
+            DapLinkStatusSet(&daplinkStatus);
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_INTERFACE);
+            if (addr_valid && (DAPLINK_ROM_IF_START_A != addr) && (DAPLINK_ROM_IF_START_B != addr)) {
+                // Address is wrong so display error message
+                status = ERROR_FD_INTF_UPDT_ADDR_WRONG;
+            } else {
+                // Setup for update
+                if (SysStartFlagGet() == CONFIG_STRAT_FLAG_A) {
+                    flash_start_local = DAPLINK_ROM_IF_START_B;
+                } else {
+                    flash_start_local = DAPLINK_ROM_IF_START_A;
+                }
+                endAddr = flash_start_local + (CONFIG_STORAGE_MAX_INFACR_SIZE > file_len ? file_len : CONFIG_STORAGE_MAX_INFACR_SIZE);
+                ConfigLoadEndAddrSet(endAddr);
+                flash_intf_local = flash_intf_iap_protected;
+            }
+        }else {
+            ConfigLoadTypeSet(CONFIG_LOAD_TYPE_UNKNOW);
+            status = ERROR_FD_UNSUPPORTED_UPDATE;
+        }
+    } else {
+        status = ERROR_FD_UNSUPPORTED_UPDATE;
+    }
+
+    // Don't allow bootloader updates unless automation is allowed
+    if (!config_get_automation_allowed() && (FLASH_DECODER_TYPE_BOOTLOADER == type)) {
+        status = ERROR_FD_UNSUPPORTED_UPDATE;
+    }
+
+    if (ERROR_SUCCESS != status) {
+        return status;
+    }
+
+    if (0 == flash_intf_local) {
+        util_assert(0);
+        return ERROR_INTERNAL;
+    }
+
+    *start_addr = flash_start_local;
+    *flash_intf = flash_intf_local;
+    return status;
+}
+#else /* #ifdef HISPARK_TRACE */
 error_t flash_decoder_get_flash(flash_decoder_type_t type, uint32_t addr, bool addr_valid, uint32_t *start_addr, const flash_intf_t **flash_intf)
 {
     error_t status = ERROR_SUCCESS;
@@ -189,6 +399,7 @@
     *flash_intf = flash_intf_local;
     return status;
 }
+#endif /* #ifdef HISPARK_TRACE */
 
 error_t flash_decoder_validate_target_image(flash_decoder_type_t type, const uint8_t *data, uint32_t size)
 {
@@ -286,6 +497,9 @@
         if (flash_type_known) {
             const flash_intf_t *flash_intf;
             uint32_t flash_start_addr;
+#ifdef HISPARK_TRACE
+            TargetAlgoLibInfo tempAlgoInfo;
+#endif
             status = flash_decoder_get_flash(flash_type, initial_addr, true, &flash_start_addr, &flash_intf);
 
             if (ERROR_SUCCESS != status) {
@@ -306,6 +520,14 @@
             flash_decoder_printf("    flash_start_addr=0x%x\r\n", flash_start_addr);
             // Initialize flash manager
             util_assert(!flash_initialized);
+#ifdef HISPARK_TRACE
+            TargetLibCurrentAlgoGet(&tempAlgoInfo);
+            if (flash_type == FLASH_DECODER_TYPE_TARGET &&
+                tempAlgoInfo.fileStatus != TARGET_LIB_FILE_STATUS_NORMAL) {
+                state = DECODER_STATE_ERROR;
+                return ERROR_INTERNAL;
+            }
+#endif
             status = flash_manager_init(flash_intf);
             flash_decoder_printf("    flash_manager_init ret %i\r\n", status);
 
@@ -318,6 +540,24 @@
         }
 
         // If flash has been initalized then write out buffered data
+#ifdef HISPARK_TRACE
+        if (flash_initialized) {
+            if (flash_type == FLASH_DECODER_TYPE_TARGET) {
+
+                status = flash_manager_data(initial_addr, flash_buf, flash_buf_pos);
+                flash_decoder_printf("    Flushing buffer initial_addr=0x%x, flash_buf_pos=%i, flash_manager_data ret=%i\r\n",
+                                    initial_addr, flash_buf_pos, status);
+
+                if (ERROR_SUCCESS != status) {
+                    state = DECODER_STATE_ERROR;
+                    return status;
+                }
+            }
+        }
+        if (size == 0) {
+            return status;
+        }
+#else /* #ifdef HISPARK_TRACE */
         if (flash_initialized) {
             status = flash_manager_data(initial_addr, flash_buf, flash_buf_pos);
             flash_decoder_printf("    Flushing buffer initial_addr=0x%x, flash_buf_pos=%i, flash_manager_data ret=%i\r\n",
@@ -328,6 +568,7 @@
                 return status;
             }
         }
+#endif /* #ifdef HISPARK_TRACE */
     }
 
     // Write data as normal if flash has been initialized
@@ -356,7 +597,11 @@
 error_t flash_decoder_close(void)
 {
     error_t status = ERROR_SUCCESS;
+#ifdef HISPARK_TRACE
+
+#else /* #ifdef HISPARK_TRACE */
     decoder_state_t prev_state = state;
+#endif /* #ifdef HISPARK_TRACE */
     flash_decoder_printf("flash_decoder_close()\r\n");
 
     if (DECODER_STATE_CLOSED == state) {
@@ -370,12 +615,15 @@
         status = flash_manager_uninit();
         flash_decoder_printf("    flash_manager_uninit ret %i\r\n", status);
     }
+#ifdef HISPARK_TRACE
 
+#else /* #ifdef HISPARK_TRACE */
     if ((DECODER_STATE_DONE != prev_state) &&
             (flash_type != FLASH_DECODER_TYPE_TARGET) &&
             (status == ERROR_SUCCESS)) {
         status = ERROR_IAP_UPDT_INCOMPLETE;
     }
+#endif /* #ifdef HISPARK_TRACE */
 
     return status;
 }
@@ -385,6 +633,14 @@
     uint32_t end_addr=0;
 
     switch (flash_type) {
+#ifdef HISPARK_TRACE
+        case FLASH_DECODER_TYPE_BOOTLOADER:
+        case FLASH_DECODER_TYPE_INTERFACE:
+        case FLASH_DECODER_TYPE_TARGET_IMAGE:
+        case FLASH_DECODER_TYPE_TARGET_ALGO:
+            end_addr = ConfigLoadEndAddrGet();
+            break;
+#else /* #ifdef HISPARK_TRACE */
         case FLASH_DECODER_TYPE_BOOTLOADER:
             end_addr = DAPLINK_ROM_BL_START + DAPLINK_ROM_BL_SIZE;
             break;
@@ -392,7 +648,7 @@
         case FLASH_DECODER_TYPE_INTERFACE:
             end_addr = DAPLINK_ROM_IF_START + DAPLINK_ROM_IF_SIZE;
             break;
-
+#endif /* #ifdef HISPARK_TRACE */
         case FLASH_DECODER_TYPE_TARGET:
             //only if we are sure it is a bin for the target; without check unordered hex files will cause to terminate flashing
             if (flash_type_target_bin && g_board_info.target_cfg) {
diff -uNr old/CA7/source/daplink/drag-n-drop/flash_decoder.h new/CA7/source/daplink/drag-n-drop/flash_decoder.h
--- old/CA7/source/daplink/drag-n-drop/flash_decoder.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/flash_decoder.h	2023-05-25 15:09:49.000000000 +0800
@@ -35,13 +35,44 @@
 // Enough space for 12 vectors
 #define FLASH_DECODER_MIN_SIZE      0x30
 
+#ifdef HISPARK_TRACE
+#define FLASH_DECODER_MAGIC_HEAD     0xAA55A55A
+
+#define FLASH_DECODER_FILE_TYPE_BL               0x9B939D93
+#define FLASH_DECODER_FILE_TYPE_IF               0x9B939E8F
+#define FLASH_DECODER_FILE_TYPE_TARGET_ALGO      0x9B939F00
+#define FLASH_DECODER_FILE_TYPE_TARGET_IMAGE     0x9B939F01
+#define FLASH_DECODER_FILE_TYPE_TARGET           0x9B939F02
+#endif /* #ifdef HISPARK_TRACE */
+
 typedef enum {
     FLASH_DECODER_TYPE_UNKNOWN,
     FLASH_DECODER_TYPE_BOOTLOADER,
     FLASH_DECODER_TYPE_INTERFACE,
+#ifdef HISPARK_TRACE
+    FLASH_DECODER_TYPE_TARGET_IMAGE,
+    FLASH_DECODER_TYPE_TARGET_ALGO,
+#endif /* #ifdef HISPARK_TRACE */
     FLASH_DECODER_TYPE_TARGET,
 } flash_decoder_type_t;
 
+#ifdef HISPARK_TRACE
+typedef struct {
+    uint32_t magic_head;
+    uint32_t region_info;
+    uint32_t file_type;
+    uint32_t version;
+    uint32_t vendor;
+    uint32_t vendor_model;
+    uint32_t vendor_flash_algo;
+    uint32_t size;
+    uint32_t crc_value;
+    uint32_t nameLen;
+    uint32_t targetAddr;
+    uint32_t maxLoads;
+} flash_decoder_head_t;
+#endif /* #ifdef HISPARK_TRACE */
+
 flash_decoder_type_t flash_decoder_detect_type(const uint8_t *data, uint32_t size, uint32_t addr, bool addr_valid);
 error_t flash_decoder_get_flash(flash_decoder_type_t type, uint32_t addr, bool addr_valid, uint32_t *start_addr, const flash_intf_t **flash_intf);
 
diff -uNr old/CA7/source/daplink/drag-n-drop/flash_intf.h new/CA7/source/daplink/drag-n-drop/flash_intf.h
--- old/CA7/source/daplink/drag-n-drop/flash_intf.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/flash_intf.h	2023-05-25 15:09:49.000000000 +0800
@@ -34,12 +34,18 @@
     FLASH_FUNC_NOP,
     FLASH_FUNC_ERASE,
     FLASH_FUNC_PROGRAM,
+#ifdef HISPARK_TRACE
+    FLASH_FUNC_READ,
+#endif
     FLASH_FUNC_VERIFY
 } flash_func_t;
 
 typedef error_t (*flash_intf_init_cb_t)(void);
 typedef error_t (*flash_intf_uninit_cb_t)(void);
 typedef error_t (*flash_intf_program_page_cb_t)(uint32_t addr, const uint8_t *buf, uint32_t size);
+#ifdef HISPARK_TRACE
+typedef error_t (*flash_intf_read_cb_t)(uint32_t addr, uint8_t *buf, uint32_t size);
+#endif
 typedef error_t (*flash_intf_erase_sector_cb_t)(uint32_t sector);
 typedef error_t (*flash_intf_erase_chip_cb_t)(void);
 typedef uint32_t (*flash_program_page_min_size_cb_t)(uint32_t addr);
@@ -57,6 +63,9 @@
     flash_erase_sector_size_cb_t erase_sector_size;
     flash_busy_cb_t flash_busy;
     flash_algo_set_cb_t flash_algo_set;
+#ifdef HISPARK_TRACE
+    flash_intf_read_cb_t read;
+#endif
 } flash_intf_t;
 
 // All flash interfaces.  Unsupported interfaces are NULL.
diff -uNr old/CA7/source/daplink/drag-n-drop/flash_manager.c new/CA7/source/daplink/drag-n-drop/flash_manager.c
--- old/CA7/source/daplink/drag-n-drop/flash_manager.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/flash_manager.c	2023-05-25 15:09:49.000000000 +0800
@@ -4,7 +4,7 @@
  *
  * DAPLink Interface Firmware
  * Copyright (c) 2009-2019, ARM Limited, All Rights Reserved
- * Copyright 2019, Cypress Semiconductor Corporation 
+ * Copyright 2019, Cypress Semiconductor Corporation
  * or a subsidiary of Cypress Semiconductor Corporation.
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -25,6 +25,9 @@
 #include "util.h"
 #include "error.h"
 #include "settings.h"
+#ifdef HISPARK_TRACE
+#include "target_lib_manager.h"
+#endif
 
 // Set to 1 to enable debugging
 #define DEBUG_FLASH_MANAGER     0
@@ -48,7 +51,11 @@
 static uint8_t buf[1024];
 static bool buf_empty;
 static bool current_sector_valid;
+#ifdef HISPARK_TRACE
+static bool page_erase_enabled = true;
+#else
 static bool page_erase_enabled = false;
+#endif
 static uint32_t current_write_block_addr;
 static uint32_t current_write_block_size;
 static uint32_t current_sector_addr;
diff -uNr old/CA7/source/daplink/drag-n-drop/iap_flash_intf.c new/CA7/source/daplink/drag-n-drop/iap_flash_intf.c
--- old/CA7/source/daplink/drag-n-drop/iap_flash_intf.c	2023-06-09 16:19:20.547962084 +0800
+++ new/CA7/source/daplink/drag-n-drop/iap_flash_intf.c	2023-06-09 15:37:12.812038800 +0800
@@ -52,6 +52,9 @@
 static error_t init(void);
 static error_t uninit(void);
 static error_t program_page(uint32_t addr, const uint8_t *buf, uint32_t size);
+#ifdef HISPARK_TRACE
+static error_t iap_flash_read(uint32_t addr, uint8_t *buf, uint32_t size);
+#endif
 static error_t erase_sector(uint32_t addr);
 static error_t erase_chip(void);
 static uint32_t program_page_min_size(uint32_t addr);
@@ -73,6 +76,10 @@
     program_page_min_size,
     erase_sector_size,
     target_flash_busy,
+#ifdef HISPARK_TRACE
+    0,
+    iap_flash_read,
+#endif
 };
 
 const flash_intf_t *const flash_intf_iap_protected = &flash_intf;
@@ -144,7 +151,11 @@
         // Bootloader - For 3rd party applications the end of the update
         //              is unknown so it is not an error if the transfer
         //              ends early.
+#ifdef HISPARK_TRACE
+
+#else
         return ERROR_IAP_UPDT_INCOMPLETE;
+#endif
     }
 
     return ERROR_SUCCESS;
@@ -368,7 +379,11 @@
 
 static error_t intercept_page_write(uint32_t addr, const uint8_t *buf, uint32_t size)
 {
+#ifdef HISPARK_TRACE
+    error_t status = ERROR_IAP_NO_INTERCEPT;
+#else
     error_t status;
+#endif
     uint32_t crc_size;
     uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
     uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
@@ -377,7 +392,6 @@
         util_assert(0);
         return ERROR_INTERNAL;
     }
-
     if ((addr < updt_start) || (addr >= updt_end)) {
         return ERROR_IAP_OUT_OF_BOUNDS;
     }
@@ -391,12 +405,16 @@
     crc = crc32_continue(crc, buf, crc_size);
 
     // Intercept the data if it is in the first sector
-    if ((addr >= updt_start) && (addr < updt_start + DAPLINK_SECTOR_SIZE)) {
-        uint32_t buf_offset = addr - updt_start;
-        memcpy(sector_buf + buf_offset, buf, size);
-        // Intercept was successful
+#ifdef HISPARK_TRACE
+
+#else
+     if ((addr >= updt_start) && (addr < updt_start + DAPLINK_SECTOR_SIZE)) {
+         uint32_t buf_offset = addr - updt_start;
+         memcpy(sector_buf + buf_offset, buf, size);
+         // Intercept was successful
         return ERROR_SUCCESS;
-    }
+     }
+#endif /* #ifdef HISPARK_TRACE */
 
     // Finalize update if this is the last sector
     if (updt_end == addr + size) {
@@ -427,15 +445,19 @@
         // The bootloader has been updated so recompute the crc
         info_crc_compute();
         update_complete = true;
+#ifdef HISPARK_TRACE
+    }
+    return status;
+#else
         return status;
     }
 
     return ERROR_IAP_NO_INTERCEPT;
+#endif
 }
 
 static error_t intercept_sector_erase(uint32_t addr)
 {
-    error_t status;
     uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
     uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
 
@@ -443,7 +465,6 @@
         util_assert(0);
         return ERROR_INTERNAL;
     }
-
     if ((addr < updt_start) || (addr >= updt_end)) {
         return ERROR_IAP_OUT_OF_BOUNDS;
     }
@@ -453,18 +474,21 @@
     }
 
     /* Everything below here is interface specific */
+#ifdef HISPARK_TRACE
 
-    if (DAPLINK_ROM_UPDATE_START == addr) {
-        uint32_t addr = DAPLINK_ROM_UPDATE_START;
-        status = critical_erase_and_program(addr, (uint8_t *)DAPLINK_ROM_IF_START, DAPLINK_MIN_WRITE_SIZE);
-
-        if (ERROR_SUCCESS == status) {
-            // Intercept was successful
-            status = ERROR_SUCCESS;
-        }
-
-        return status;
-    }
+#else /* #ifdef HISPARK_TRACE */
+     if (DAPLINK_ROM_UPDATE_START == addr) {
+         uint32_t addr = DAPLINK_ROM_UPDATE_START;
+         status = critical_erase_and_program(addr, (uint8_t *)DAPLINK_ROM_IF_START, DAPLINK_MIN_WRITE_SIZE);
+
+         if (ERROR_SUCCESS == status) {
+             // Intercept was successful
+             status = ERROR_SUCCESS;
+         }
+
+         return status;
+     }
+#endif /* #ifdef HISPARK_TRACE */
 
     return ERROR_IAP_NO_INTERCEPT;
 }
@@ -499,6 +523,13 @@
     return ERROR_SUCCESS;
 }
 
-static uint8_t target_flash_busy(void){
+static uint8_t target_flash_busy(void) {
     return (state == STATE_OPEN);
 }
+
+#ifdef HISPARK_TRACE
+static error_t iap_flash_read(uint32_t addr, uint8_t *buf, uint32_t size)
+{
+    return FlashRead(addr, size, buf);
+}
+#endif
diff -uNr old/CA7/source/daplink/drag-n-drop/intelhex.c new/CA7/source/daplink/drag-n-drop/intelhex.c
--- old/CA7/source/daplink/drag-n-drop/intelhex.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/intelhex.c	2023-05-25 15:09:49.000000000 +0800
@@ -37,9 +37,9 @@
 };
 
 typedef union hex_line_t hex_line_t;
-__PACKED_UNION hex_line_t {
+union __attribute__((packed)) hex_line_t {
     uint8_t buf[0x25];
-    __PACKED_STRUCT {
+    struct __attribute__((packed)) {
         uint8_t  byte_count;
         uint16_t address;
         uint8_t  record_type;
@@ -87,7 +87,7 @@
 static uint8_t low_nibble = 0, idx = 0, record_processed = 0, load_unaligned_record = 0, skip_until_aligned = 0;
 static uint16_t binary_version = 0;
 uint16_t board_id_hex __WEAK;
-uint16_t board_id_hex_default __WEAK;
+uint16_t board_id_hex_min __WEAK;
 
 void reset_hex_parser(void)
 {
@@ -170,15 +170,12 @@
 
                                     case DATA_RECORD:
                                     case CUSTOM_DATA_RECORD:
-                                        if (binary_version == 0 || binary_version == board_id_hex_default || binary_version == board_id_hex) {
+                                        if (binary_version == 0 || (binary_version >= board_id_hex_min && binary_version <= board_id_hex)){
                                             // Only save data from the correct binary
                                             // verify this is a continous block of memory or need to exit and dump
                                             if (((next_address_to_write & 0xffff0000) | line.address) != next_address_to_write) {
                                                 load_unaligned_record = 1;
                                                 status = HEX_PARSE_UNALIGNED;
-                                                // Function will be executed again and will start by finishing to process this record by
-                                                // adding the this line into bin_buf, so the 1st loop iteration should be the next blob byte
-                                                hex_blob++;
                                                 goto hex_parser_exit;
                                             } else {
                                                 // This should be superfluous but it is necessary for GCC
diff -uNr old/CA7/source/daplink/drag-n-drop/vfs_manager.c new/CA7/source/daplink/drag-n-drop/vfs_manager.c
--- old/CA7/source/daplink/drag-n-drop/vfs_manager.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/vfs_manager.c	2023-05-25 15:09:49.000000000 +0800
@@ -36,6 +36,15 @@
 #include "file_stream.h"
 #include "error.h"
 
+#ifdef HISPARK_TRACE
+#include "flash_intf.h"
+#include "config_storage_update.h"
+#include "target_lib_manager.h"
+#include "offline_sys_config.h"
+#include "user_crc.h"
+#include "status.h"
+#endif
+
 // Set to 1 to enable debugging
 #define DEBUG_VFS_MANAGER     0
 
@@ -389,7 +398,6 @@
     USBD_MSC_BlockCount = USBD_MSC_MemorySize / USBD_MSC_BlockSize;
     USBD_MSC_BlockBuf   = (uint8_t *)usb_buffer;
 }
-
 // Callback to handle changes to the root directory.  Should be used with vfs_set_file_change_callback
 static void file_change_handler(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
 {
@@ -556,6 +564,85 @@
     sync_unlock();
 }
 
+#ifdef HISPARK_TRACE
+static void transfer_update_done_handle(void)
+{
+    int loadType;
+    int currentIndex;
+    uint32_t fileStatus;
+    DapLinkStatus daplinkStatus;
+    TargetAlgoLibInfo currentLibAlgo;
+    TargetImageLibInfo currentLibImage;
+    const flash_intf_t *currentIntf;
+    loadType = ConfigLoadTypeGet();
+    switch (loadType) {
+        case CONFIG_LOAD_TYPE_INTERFACE:
+            if (SysStartFlagGet() == CONFIG_STRAT_FLAG_A) {
+                ConfigStartFlagSave(CONFIG_STRAT_FLAG_B);
+            } else {
+                ConfigStartFlagSave(CONFIG_STRAT_FLAG_A);
+            }
+            DapLinkStatusGet(&daplinkStatus);
+            daplinkStatus.fwUpgradeStatus = FIMRWARE_UPGRADE_SUCCESS;
+            DapLinkStatusSet(&daplinkStatus);
+            break;
+        case CONFIG_LOAD_TYPE_IMAGE:
+            if (FactoryStatusGet() == FACTORY_FLAG_IS_SET) {
+                FactoryLibCurrentImageGet(&currentLibImage);
+            } else {
+                TargetLibCurrentImageGet(&currentLibImage, (int32_t *)&currentIndex);
+            }
+            UserCrcInit(0, currentLibImage.info.fileCrc32);
+            currentIntf = flash_intf_iap_protected;
+            if (CheckCrcFromFlash(currentIntf, currentLibImage.startAddr, currentLibImage.info.fileSize)
+                != USER_CRC_CHECK_SUCCESS) {
+                DapLinkStatusGet(&daplinkStatus);
+                daplinkStatus.imageStoreStatus = IMAGE_STORE_CRC_ERROR;
+                DapLinkStatusSet(&daplinkStatus);
+            } else {
+                if (FactoryStatusGet() == FACTORY_FLAG_IS_SET) {
+                    currentIndex = FactoryLibImageIndexGetFormStartAddr(currentLibImage.startAddr);
+                    FactoryLibFileStatusChange(TARGET_LIB_TYPE_IMAGE, currentIndex, TARGET_LIB_FILE_STATUS_NORMAL);
+                } else {
+                    currentIndex = TargetLibImageIndexGetFormStartAddr(currentLibImage.startAddr);
+                    TargetLibFileStatusChange(TARGET_LIB_TYPE_IMAGE, currentIndex, TARGET_LIB_FILE_STATUS_NORMAL);
+                }
+                DapLinkStatusGet(&daplinkStatus);
+                daplinkStatus.imageStoreStatus = IMAGE_STORE_SUCCESS;
+                DapLinkStatusSet(&daplinkStatus);
+            }
+            break;
+        case CONFIG_LOAD_TYPE_ALGO:
+            TargetLibCurrentAlgoGet(&currentLibAlgo);
+            UserCrcInit(0, currentLibAlgo.info.fileCrc32);
+            currentIntf = flash_intf_iap_protected;
+            if (CheckCrcFromFlash(currentIntf, currentLibAlgo.startAddr, currentLibAlgo.info.fileSize)
+                != USER_CRC_CHECK_SUCCESS) {
+                DapLinkStatusGet(&daplinkStatus);
+                daplinkStatus.algoStoreStatus = ALGORITHM_STORE_CRC_ERROR;
+                DapLinkStatusSet(&daplinkStatus);
+            } else {
+                if ((currentLibAlgo.info.regioninfo & 0xFFFF0000) == TARGET_LIB_SEC_REGION) {
+                    fileStatus = TARGET_LIB_FILE_STATUS_SECURITY;
+                } else {
+                    fileStatus = TARGET_LIB_FILE_STATUS_NORMAL;
+                }
+
+                currentIndex = TargetLibAlgoIndexGetFormStartAddr(currentLibAlgo.startAddr);
+                TargetLibFileStatusChange(TARGET_LIB_TYPE_ALGO, currentIndex, fileStatus);
+                DapLinkStatusGet(&daplinkStatus);
+                daplinkStatus.algoStoreStatus = ALGORITHM_STORE_SUCCESS;
+                DapLinkStatusSet(&daplinkStatus);
+            }
+            break;
+        case CONFIG_LOAD_TYPE_TARGET:
+            break;
+        default:
+            break;
+    }
+}
+#endif /* #ifdef HISPARK_TRACE */
+
 // Update the tranfer state with file information
 static void transfer_update_file_info(vfs_file_t file, uint32_t start_sector, uint32_t size, stream_type_t stream)
 {
@@ -714,6 +801,9 @@
         // Override status so ERROR_SUCCESS_DONE
         // does not get passed into transfer_update_state
         status = stream_close();
+#ifdef HISPARK_TRACE
+        transfer_update_done_handle();
+#endif
         vfs_mngr_printf("    stream_close ret=%i\r\n", status);
         file_transfer_state.stream_open = false;
         file_transfer_state.stream_finished = true;
diff -uNr old/CA7/source/daplink/drag-n-drop/vfs_user.c new/CA7/source/daplink/drag-n-drop/vfs_user.c
--- old/CA7/source/daplink/drag-n-drop/vfs_user.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/drag-n-drop/vfs_user.c	2023-05-25 15:09:49.000000000 +0800
@@ -45,6 +45,13 @@
 //! device.  This is to accomodate for hex file programming.
 #define VFS_DISK_SIZE (MB(64))
 
+#ifdef HISPARK_TRACE
+// Additional buffer space to display more than 512 bytes in DETAILS.TXT
+#if !defined(BOARD_EXTRA_BUFFER)
+#define BOARD_EXTRA_BUFFER 0
+#endif
+#endif /* #ifdef HISPARK_TRACE */
+
 //! @brief Constants for magic action or config files.
 //!
 //! The "magic files" are files with a special name that if created on the USB MSC volume, will
@@ -118,8 +125,7 @@
 
 static uint32_t expand_info(uint8_t *buf, uint32_t bufsize);
 
-__WEAK void vfs_user_build_filesystem_hook(){}
-
+__WEAK void vfs_user_build_filesystem_hook(void){}
 void vfs_user_build_filesystem()
 {
     uint32_t file_size;
@@ -137,6 +143,10 @@
     if (vfs_mngr_get_transfer_status() != ERROR_SUCCESS) {
         file_size = get_file_size(read_file_fail_txt);
         vfs_create_file("FAIL    TXT", read_file_fail_txt, 0, file_size);
+#ifdef HISPARK_TRACE
+    } else {
+        vfs_create_file("SUCCESS TXT", 0, 0, 0);
+#endif
     }
 
     // ASSERT.TXT
@@ -517,12 +527,21 @@
 #define LOCAL_MODS ""
 #endif
 
+#ifdef HISPARK_TRACE
+#ifndef GIT_DESCRIPTION
+#define GIT_DESCRIPTION "001"
+#endif
+#endif /* #ifdef HISPARK_TRACE */
 static uint32_t update_details_txt_file(uint8_t *buf, uint32_t size, uint32_t start)
 {
     uint32_t pos = 0;
 
     pos += util_write_string_in_region(buf, size, start, pos,
+#ifdef HISPARK_TRACE
+        "# DAPLink Firmware - see https://mbed.com/daplink\r\n"
+#else
         "# DAPLink Firmware - see https://daplink.io\r\n"
+#endif
         // Build ID
         "Build ID: " GIT_DESCRIPTION " (" COMPILER_DESCRIPTION LOCAL_MODS ")\r\n");
     // Unique ID
@@ -671,7 +690,11 @@
             uint32_t buf_len = strlen((const char *)buf);
             uint32_t str_len = strlen((const char *)insert_string);
             //buffer overflow check on insert
+#ifdef HISPARK_TRACE
+            if (((buf + str_len + buf_len - 2) < (orig_buf+bufsize)) && (str_len > 0)){
+#else
             if( (buf + str_len + buf_len - 2) < (orig_buf+bufsize)){
+#endif
                 // push out string
                 memmove(buf + str_len, buf + 2, buf_len - 2);
                 // insert
diff -uNr old/CA7/source/daplink/error.c new/CA7/source/daplink/error.c
--- old/CA7/source/daplink/error.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/error.c	2023-05-25 15:09:49.000000000 +0800
@@ -71,6 +71,8 @@
     "Flash algorithm erase all command FAILURE",
     // ERROR_WRITE
     "Flash algorithm write command FAILURE",
+    // ERROR_READ
+    "Flash algorithm read command FAILURE",
     // ERROR_WRITE_VERIFY
     "Flash algorithm write verify command FAILURE",
 
@@ -177,6 +179,8 @@
     ERROR_TYPE_TARGET,
     // ERROR_WRITE
     ERROR_TYPE_TARGET,
+    // ERROR_READ
+    ERROR_TYPE_TARGET,
     // ERROR_WRITE_VERIFY
     ERROR_TYPE_TARGET,
 
diff -uNr old/CA7/source/daplink/error.h new/CA7/source/daplink/error.h
--- old/CA7/source/daplink/error.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/error.h	2023-05-25 15:09:49.000000000 +0800
@@ -52,6 +52,7 @@
     ERROR_ERASE_SECTOR,
     ERROR_ERASE_ALL,
     ERROR_WRITE,
+    ERROR_READ,
     ERROR_WRITE_VERIFY,
 
     /* File stream errors */
diff -uNr old/CA7/source/daplink/flash_hal.c new/CA7/source/daplink/flash_hal.c
--- old/CA7/source/daplink/flash_hal.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/flash_hal.c	2023-05-25 15:09:49.000000000 +0800
@@ -23,6 +23,10 @@
 #include "cortex_m.h"
 #include "daplink_addr.h"
 
+#ifdef HISPARK_TRACE
+#define ONE_PAGE_SIZE    256
+#endif
+
 uint32_t  flash_erase_sector(uint32_t addr)
 {
     cortex_int_state_t state;
@@ -35,11 +39,31 @@
 
 uint32_t  flash_program_page(uint32_t adr, uint32_t sz, uint8_t *buf)
 {
+
     int retval = -1;
     cortex_int_state_t state;
     state = cortex_int_get_and_disable();
+#ifdef HISPARK_TRACE
+    int i = 0;
+    uint32_t page_cnt = 0;
+    page_cnt = sz / ONE_PAGE_SIZE;
+
+    for (i = 0; i < page_cnt; i++) {
+        retval = ProgramPage(adr, ONE_PAGE_SIZE, (uint32_t *)buf);
+        cortex_int_restore(state);
+        adr += ONE_PAGE_SIZE;
+        sz -= ONE_PAGE_SIZE;
+        buf += ONE_PAGE_SIZE;
+    }
+
+    if (sz > 0) {
+        retval = ProgramPage(adr, sz, (uint32_t *)buf);
+    }
+#else
     retval = ProgramPage(adr, sz, (uint32_t *)buf);
     cortex_int_restore(state);
+#endif
+
     return retval;
 }
 
diff -uNr old/CA7/source/daplink/HardFault_Handler.c new/CA7/source/daplink/HardFault_Handler.c
--- old/CA7/source/daplink/HardFault_Handler.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/HardFault_Handler.c	2023-05-25 15:09:49.000000000 +0800
@@ -28,6 +28,7 @@
 //hexdump logic on hardfault
 __USED __NO_RETURN void _fault_handler(uint32_t _lr)
 {
+#ifndef HISPARK_TRACE
     uint32_t stk_ptr;
     uint32_t * stack = (uint32_t *)__get_MSP();
 
@@ -63,7 +64,7 @@
     config_ram_add_hexdump(SCB->MMFAR);
     config_ram_add_hexdump(SCB->BFAR);
 #endif // __CORTEX_M
-
+#endif
     util_assert(0);
     SystemReset();
 
@@ -77,7 +78,7 @@
     _fault_handler(_lr);
 }
 #else // gcc and armclang
-void HardFault_Handler()
+void HardFault_Handler(void)
 {
     __ASM volatile (
         "    mov    r0, lr              \n\t"
diff -uNr old/CA7/source/daplink/info.c new/CA7/source/daplink/info.c
--- old/CA7/source/daplink/info.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/info.c	2023-05-25 15:09:49.000000000 +0800
@@ -60,7 +60,6 @@
 
 static char usb_desc_unique_id[2 + sizeof(string_unique_id) * 2];
 
-
 const char *info_get_unique_id(void)
 {
     return string_unique_id;
@@ -160,7 +159,7 @@
     string_version[idx++] = 0;
 }
 
-static void setup_unique_id()
+static void setup_unique_id(void)
 {
     memset(string_unique_id, 0, sizeof(string_unique_id));
     strcat(string_unique_id, string_board_id);
@@ -169,7 +168,7 @@
     strcat(string_unique_id, string_hic_id);
 }
 
-static void setup_string_descriptor()
+static void setup_string_descriptor(void)
 {
     uint8_t i = 0, idx = 0, len = 0;
     len = strlen((const char *)string_unique_id);
@@ -187,7 +186,9 @@
 
 void info_init(void)
 {
+#ifndef HISPARK_TRACE
     info_crc_compute();
+#endif
     read_unique_id(host_id);
     setup_basics();
     setup_unique_id();
@@ -321,4 +322,3 @@
 
     return info_if->version;
 }
-
diff -uNr old/CA7/source/daplink/interface/bootloader_update.c new/CA7/source/daplink/interface/bootloader_update.c
--- old/CA7/source/daplink/interface/bootloader_update.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/bootloader_update.c	2023-05-25 15:09:49.000000000 +0800
@@ -49,7 +49,7 @@
     static const char image_data[1];
 #endif //DAPLINK_BOOTLOADER_UPDATE
 
-static bool interface_image_valid()
+static bool interface_image_valid(void)
 {
     uint32_t stored_crc = 0;
     uint32_t computed_crc;
diff -uNr old/CA7/source/daplink/interface/daplink.c new/CA7/source/daplink/interface/daplink.c
--- old/CA7/source/daplink/interface/daplink.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/daplink.c	2023-05-25 15:09:49.000000000 +0800
@@ -25,9 +25,11 @@
 
 #include "virtual_fs.h"
 #include "compiler.h"
+#ifdef HISPARK_TRACE
 
+#else
 COMPILER_ASSERT(DAPLINK_BUILD_KEY == DAPLINK_BUILD_KEY_IF);
-
+#endif
 const vfs_filename_t daplink_mode_file_name = "START_BLACT";
 
 #endif //DRAG_N_DROP_SUPPORT
diff -uNr old/CA7/source/daplink/interface/jtag_host.c new/CA7/source/daplink/interface/jtag_host.c
--- old/CA7/source/daplink/interface/jtag_host.c	1970-01-01 08:00:00.000000000 +0800
+++ new/CA7/source/daplink/interface/jtag_host.c	2023-06-09 08:51:53.645623700 +0800
@@ -0,0 +1,1467 @@
+/**
+ * @file    jtag_host.c
+ * @brief   Implementation of jtag_host.h
+ *
+ * DAPLink Interface Firmware
+ * Copyright (c) 2009-2019, ARM Limited, All Rights Reserved
+ * Copyright 2019, Cypress Semiconductor Corporation
+ * or a subsidiary of Cypress Semiconductor Corporation.
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TARGET_MCU_CORTEX_A
+#include "device.h"
+#include "cmsis_os2.h"
+#include "target_config.h"
+#include "jtag_host.h"
+#include "debug_cm.h"
+
+#include "DAP_config.h"
+#include "DAP.h"
+#include "target_family.h"
+#include "jtag_host.h"
+
+// riscv DM register
+/* RISC_V Debug 模块相关的寄存器定义，
+   详细的寄存器说明请查阅RISC-V官方文档《RISC-V Debug Specification》 */
+#define RISCV_DM_ADDRESS_SHIFT    0x2 /* TAR [2,31]bit */
+#define MATCH_CSRRW               0x1073
+#define MATCH_CSRRS               0x2073
+#define MATCH_CSRRC               0x3073
+
+#define RISCV_DM_GPRS_BASE_ADDR   0x1000
+
+#define RISCV_DM_DATA0            0x04
+#define RISCV_DM_DATA11           0x0f
+#define RISCV_DM_HARTINFO         0x12
+#define RISCV_DM_PROGBUF0         0x20
+#define RISCV_DM_PROGBUF1         0x21
+
+#define RISCV_DM_DMCONTROL                 0x10
+#define RISCV_DM_DMCONTROL_HALTREQ_SHIFT   31
+#define RISCV_DM_DMCONTROL_RESUMEREQ_SHIFT 30
+
+#define RISCV_DM_DMSTATUS                  0x11
+#define RISCV_DM_DMSTATUS_ALLHALTED_SHIFT  9
+
+#define RISCV_DM_ABSTRACTCS                0x16
+#define RISCV_DM_ABSTRACTCS_BUSY_SHIFT    12
+#define RISCV_DM_ABSTRACTCS_CMDERR_SHIFT  8
+
+#define RISCV_DM_COMMAND                 0x17
+#define RISCV_DM_COMMAND_CMDTYPE_SHIFT   24
+#define RISCV_DM_COMMAND_AARSIZE_SHIFT   20
+#define  RISCV_DM_COMMAND_POSTEXEC_SHIFT 18
+#define RISCV_DM_COMMAND_TRANSFER_SHIFT  17
+#define RISCV_DM_COMMAND_WRITE_SHIFT     16
+
+#define RISCV_DM_DCSR                 0x7B0
+#define RISCV_DM_DCSR_EBREAK_SHIFT    15
+
+#define RISCV_DM_DPC                 0x7B1
+#define RISCV_DM_EBREAK_CMD          0x100073
+
+// Default NVIC and Core debug base addresses
+// TODO: Read these addresses from ROM.
+#define NVIC_Addr    (0xe000e000)
+#define DBG_Addr     (0xe000edf0)
+
+// AP CSW register, base value
+#define CSW_VALUE (CSW_RESERVED | CSW_MSTRDBG | CSW_HPROT | CSW_DBGSTAT | CSW_SADDRINC)
+
+#define DCRDR 0xE000EDF8
+#define DCRSR 0xE000EDF4
+#define DHCSR 0xE000EDF0
+#define REGWnR (1 << 16)
+
+#define MAX_JTAG_RETRY 10//10
+#define MAX_TIMEOUT   5000  // Timeout for syscalls on target
+
+// Use the CMSIS-Core definition if available.
+#if !defined(SCB_AIRCR_PRIGROUP_Pos)
+#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+#endif
+
+typedef struct {
+    uint32_t select;
+    uint32_t csw;
+} DAP_STATE;
+
+typedef struct {
+    uint32_t r[33];
+} DEBUG_STATE;
+
+static JTAG_SWD_CONNECT_TYPE reset_connect = CONNECT_NORMAL;
+
+static DAP_STATE dap_state;
+static uint32_t  soft_reset = SYSRESETREQ;
+
+static uint8_t jtag_halted(void);
+static uint8_t jtag_wait_until_halted(void);
+static uint32_t jtag_csrrw(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint32_t jtag_csrrs(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint32_t jtag_csrrc(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint8_t jtag_set_pc(uint32_t pc_addr);
+static uint8_t jtag_set_ebreak_mode(uint8_t mode);
+
+void jtag_set_reset_connect(JTAG_SWD_CONNECT_TYPE type)
+{
+    reset_connect = type;
+}
+
+static void int2array(uint8_t *res, uint32_t data, uint8_t len)
+{
+    uint8_t i = 0;
+
+    for (i = 0; i < len; i++) {
+        res[i] = (data >> 8 * i) & 0xff;
+    }
+}
+
+uint8_t jtag_transfer_retry(uint32_t req, uint32_t *data)
+{
+    uint8_t i, ack;
+
+    for (i = 0; i < MAX_JTAG_RETRY; i++) {
+        ack = JTAG_Transfer(req, data);
+
+        // if ack != WAIT
+        if (ack != DAP_TRANSFER_WAIT) {
+            return ack;
+        }
+    }
+
+    return ack;
+}
+
+void jtag_set_soft_reset(uint32_t soft_reset_type)
+{
+    soft_reset = soft_reset_type;
+}
+
+uint8_t jtag_init(void)
+{
+    //TODO - DAP_Setup puts GPIO pins in a hi-z state which can
+    //       cause problems on re-init.  This needs to be investigated
+    //       and fixed.
+    DAP_Setup();
+    PORT_JTAG_SETUP();
+    return 1;
+}
+
+uint8_t jtag_off(void)
+{
+    PORT_OFF();
+    return 1;
+}
+
+uint8_t jtag_clear_errors(void)
+{
+    JTAG_WriteAbort(STKCMPCLR | STKERRCLR | WDERRCLR | ORUNERRCLR);
+    return 1;
+}
+
+// Read debug port register.
+uint8_t jtag_read_dp(uint8_t adr, uint32_t *val)
+{
+    uint32_t tmp_in;
+    uint8_t tmp_out[4];
+    uint8_t ack;
+    uint32_t tmp;
+    uint32_t ir = JTAG_DPACC;
+
+    tmp_in = JTAG_REG_R | JTAG_REG_ADR(adr);
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(tmp_in, (uint32_t *)tmp_out);
+    *val = 0;
+    tmp = tmp_out[3];
+    *val |= (tmp << 24);
+    tmp = tmp_out[2];
+    *val |= (tmp << 16);
+    tmp = tmp_out[1];
+    *val |= (tmp << 8);
+    tmp = tmp_out[0];
+    *val |= (tmp << 0);
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Write debug port register
+uint8_t jtag_write_dp(uint8_t adr, uint32_t val)
+{
+    uint32_t req;
+    uint8_t data[4];
+    uint8_t ack;
+    uint32_t ir = JTAG_DPACC;
+
+    //check if the right bank is already selected
+    if ((adr == DP_SELECT) && (dap_state.select == val)) {
+        return 1;
+    }
+    req = JTAG_REG_W | JTAG_REG_ADR(adr);
+    int2array(data, val, 4);
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, (uint32_t *)data);
+    if ((ack == DAP_TRANSFER_OK) && (adr == DP_SELECT)) {
+        dap_state.select = val;
+    }
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Read access port register.
+uint8_t jtag_read_ap(uint32_t adr, uint32_t *val, uint32_t apsel)
+{
+    uint8_t tmp_in, ack;
+    uint8_t tmp_out[4];
+    uint32_t tmp;
+    uint32_t bank_sel = adr & APBANKSEL;
+    uint32_t ir = JTAG_APACC;
+
+    if (!jtag_write_dp(DP_SELECT, apsel | bank_sel)) {
+        return 0;
+    }
+
+    tmp_in =  JTAG_REG_R | JTAG_REG_ADR(adr);
+    // first dummy read
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(tmp_in, (uint32_t *)tmp_out);
+    *val = 0;
+    tmp = tmp_out[3];
+    *val |= (tmp << 24);
+    tmp = tmp_out[2];
+    *val |= (tmp << 16);
+    tmp = tmp_out[1];
+    *val |= (tmp << 8);
+    tmp = tmp_out[0];
+    *val |= (tmp << 0);
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Write access port register
+uint8_t jtag_write_ap(uint32_t adr, uint32_t val,uint32_t apsel)
+{
+    uint8_t data[4];
+    uint8_t req, ack;
+    uint32_t bank_sel = adr & APBANKSEL;
+    uint32_t ir = JTAG_APACC;
+
+    if (!jtag_write_dp(DP_SELECT, apsel | bank_sel)) {
+    //if (!jtag_write_dp(DP_SELECT, 0x1000000)) {
+        return 0;
+    }
+
+    switch (adr) {
+        case AP_CSW:
+            if (dap_state.csw == val) {
+                return 1;
+            }
+
+            dap_state.csw = val;
+            break;
+
+        default:
+            break;
+    }
+
+    req = JTAG_REG_W | JTAG_REG_ADR(adr);
+    int2array(data, val, 4);
+    JTAG_IR(ir);
+    if (jtag_transfer_retry(req, (uint32_t *)data) != 0x01) {
+        return 0;
+    }
+
+    req = JTAG_REG_R | JTAG_REG_ADR(DP_RDBUFF);
+    ir = JTAG_DPACC;
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, NULL);
+
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+
+// Write 32-bit word aligned values to target memory using address auto-increment.
+// size is in bytes.
+static uint8_t jtag_write_block(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint8_t tmp_in[4], req;
+    uint32_t size_in_words;
+    uint32_t i, ack;
+    uint32_t ir = JTAG_DPACC;
+
+    if (size == 0) {
+        return 0;
+    }
+
+    size_in_words = size / 4;
+
+    //AHB 地址递增写
+    if (!jtag_write_ap(AP_CSW, 0x12, 0x1000000)) {
+        return 0;
+    }
+
+    // TAR write
+    req = JTAG_REG_W | (1 << 2);
+    int2array(tmp_in, address, 4);
+     ir = JTAG_APACC;
+    JTAG_IR(ir);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
+        return 0;
+    }
+
+    // DRW write
+    req = JTAG_REG_W | (3 << 2);
+
+    for (i = 0; i < size_in_words; i++) {
+        if (jtag_transfer_retry(req, (uint32_t *)data) != 0x01) {
+            return 0;
+        }
+
+        data += 4;
+    }
+    ir = JTAG_DPACC;
+    // dummy read
+    req = JTAG_REG_R | SWD_REG_ADR(DP_RDBUFF);
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, NULL);
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Read 32-bit word aligned values from target memory using address auto-increment.
+// size is in bytes.
+static uint8_t jtag_read_block(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint8_t tmp_in[4], req, ack;
+    uint32_t size_in_words;
+    uint32_t i;
+    uint32_t ir;
+
+    if (size == 0) {
+        return 0;
+    }
+
+    size_in_words = size / 4;
+    //AHB地址递增读
+    if (!jtag_write_ap(AP_CSW, 0x12, 0x1000000)) {
+        return 0;
+    }
+
+    // TAR write
+    req = JTAG_REG_W | AP_TAR;
+    int2array(tmp_in, address, 4);
+    ir = JTAG_APACC;
+    JTAG_IR(ir);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_in) != DAP_TRANSFER_OK) {
+        return 0;
+    }
+
+    // read data
+    req = JTAG_REG_R | AP_DRW;
+    JTAG_IR(ir);
+    // initiate first read, data comes back in next read
+    if (jtag_transfer_retry(req, NULL) != 0x01) {
+        return 0;
+    }
+
+    for (i = 0; i < (size_in_words - 1); i++) {
+        if (jtag_transfer_retry(req, (uint32_t *)data) != DAP_TRANSFER_OK) {
+            return 0;
+        }
+
+        data += 4;
+    }
+
+    // read last word
+    ir = JTAG_DPACC;
+    req = JTAG_REG_R | JTAG_REG_ADR(DP_RDBUFF);
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, (uint32_t *)data);
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Read target memory.
+static uint8_t jtag_read_data(uint32_t addr, uint32_t *val)
+{
+    uint8_t tmp_in[4];
+    uint8_t tmp_out[4];
+    uint8_t req, ack;
+    uint32_t tmp;
+    uint32_t ir;
+    // put addr in TAR register
+    int2array(tmp_in, addr, 4);
+    ir = JTAG_APACC;
+    req = JTAG_REG_W | (1 << 2);
+    JTAG_IR(ir);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
+        return 0;
+    }
+
+    // read data
+    req = JTAG_REG_R | (3 << 2);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_out) != 0x01) {
+        return 0;
+    }
+
+    // dummy read
+    ir = JTAG_DPACC;
+    req = JTAG_REG_R | JTAG_REG_ADR(DP_RDBUFF);
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, (uint32_t *)tmp_out);
+    *val = 0;
+    tmp = tmp_out[3];
+    *val |= (tmp << 24);
+    tmp = tmp_out[2];
+    *val |= (tmp << 16);
+    tmp = tmp_out[1];
+    *val |= (tmp << 8);
+    tmp = tmp_out[0];
+    *val |= (tmp << 0);
+    return ((ack == 0x1) ? 0x1 : 0x0);
+}
+
+// Write target memory.
+static uint8_t jtag_write_data(uint32_t address, uint32_t data)
+{
+    uint8_t tmp_in[4];
+    uint8_t req, ack;
+    uint32_t ir;
+    // put addr in TAR register
+    int2array(tmp_in, address, 4);
+    req = JTAG_REG_W | (1 << 2);
+    ir = JTAG_APACC;
+    JTAG_IR(ir);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
+        return 0;
+    }
+
+    // write data
+    int2array(tmp_in, data, 4);
+    req = JTAG_REG_W | (3 << 2);
+    if (jtag_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
+        return 0;
+    }
+
+    // dummy read
+    req = JTAG_REG_R | JTAG_REG_ADR(DP_RDBUFF);
+    ir = JTAG_DPACC;
+    JTAG_IR(ir);
+    ack = jtag_transfer_retry(req, NULL);
+    return ((ack == 0x01) ? 1 : 0);
+}
+
+// Read 32-bit word from target memory.
+uint8_t jtag_read_word(uint32_t addr, uint32_t *val)
+{
+    if (!jtag_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32, 0x000000)) {
+        return 0;
+    }
+
+    if (!jtag_read_data(addr, val)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+// Write 32-bit word to target memory.
+uint8_t jtag_write_word(uint32_t addr, uint32_t val, uint32_t apsel)
+{
+    if (!jtag_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32, apsel)) {
+        return 0;
+    }
+
+    if (!jtag_write_data(addr, val)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+// Read 8-bit byte from target memory.
+uint8_t jtag_read_byte(uint32_t addr, uint8_t *val)
+{
+    uint32_t tmp;
+
+    if (!jtag_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8, 0x1000000)) {
+        return 0;
+    }
+
+    if (!jtag_read_data(addr, &tmp)) {
+        return 0;
+    }
+
+    *val = (uint8_t)(tmp >> ((addr & 0x03) << 3));
+    return 1;
+}
+
+// Write 8-bit byte to target memory.
+uint8_t jtag_write_byte(uint32_t addr, uint8_t val)
+{
+    uint32_t tmp;
+
+    if (!jtag_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8, 0x1000000)) {
+        return 0;
+    }
+
+    tmp = val << ((addr & 0x03) << 3);
+
+    if (!jtag_write_data(addr, tmp)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+// Read unaligned data from target memory.
+// size is in bytes.
+uint8_t jtag_read_memory(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint32_t n;
+
+    // Read bytes until word aligned
+    while ((size > 0) && (address & 0x3)) {
+        if (!jtag_read_byte(address, data)) {
+            return 0;
+        }
+
+        address++;
+        data++;
+        size--;
+    }
+
+    // Read word aligned blocks
+    while (size > 3) {
+        // Limit to auto increment page size
+        n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
+
+        if (size < n) {
+            n = size & 0xFFFFFFFC; // Only count complete words remaining
+        }
+
+        if (!jtag_read_block(address, data, n)) {
+            return 0;
+        }
+
+        address += n;
+        data += n;
+        size -= n;
+    }
+
+    // Read remaining bytes
+    while (size > 0) {
+        if (!jtag_read_byte(address, data)) {
+            return 0;
+        }
+
+        address++;
+        data++;
+        size--;
+    }
+
+    return 1;
+}
+
+// Write unaligned data to target memory.
+// size is in bytes.
+uint8_t jtag_write_memory(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint32_t n = 0;
+
+    // Write bytes until word aligned
+    while ((size > 0) && (address & 0x3)) {
+        if (!jtag_write_byte(address, *data)) {
+            return 0;
+        }
+
+        address++;
+        data++;
+        size--;
+    }
+
+    // Write word aligned blocks
+    while (size > 3) {
+        // Limit to auto increment page size
+        n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
+
+        if (size < n) {
+            n = size & 0xFFFFFFFC; // Only count complete words remaining
+        }
+
+        if (!jtag_write_block(address, data, n)) {
+            return 0;
+        }
+
+        address += n;
+        data += n;
+        size -= n;
+    }
+
+    // Write remaining bytes
+    while (size > 0) {
+        if (!jtag_write_byte(address, *data)) {
+            return 0;
+        }
+
+        address++;
+        data++;
+        size--;
+    }
+
+    return 1;
+}
+
+// Execute system call.
+static uint8_t jtag_write_debug_state(DEBUG_STATE *state)
+{
+    uint32_t i, status;
+    uint32_t temReg;
+    uint32_t try = 5;
+
+    if (!jtag_write_dp(DP_SELECT, 0)) {
+        return 0;
+    }
+
+    /* halt hart */
+    for (i = 0; i < try;) {
+        i++;
+        if (jtag_halted()) {
+            break;
+        }
+        if (i == try) {
+            return 0;
+        }
+    }
+
+    if (!jtag_set_pc(state->r[32])) {
+        return 0;
+    }
+
+    // R10, R11, R12, R13
+    for (i = 10; i < 14; i++) {
+        temReg = i + RISCV_DM_GPRS_BASE_ADDR;
+        if (!jtag_write_core_register(temReg, state->r[i])) {
+            return 0;
+        }
+    }
+    // x1, x2, x3
+    for (i = 1; i < 4; i++) {
+        temReg = i + RISCV_DM_GPRS_BASE_ADDR;
+        if (!jtag_write_core_register(temReg, state->r[i])) {
+            return 0;
+        }
+    }
+
+    /* resume hart */
+    if (!jtag_write_word(RISCV_DM_DMCONTROL << RISCV_DM_ADDRESS_SHIFT, 1 << RISCV_DM_DMCONTROL_RESUMEREQ_SHIFT | 0x1, 0x0)) {
+        return 0;
+    }
+
+    // check status
+    if (!jtag_read_dp(DP_CTRL_STAT, &status)) {
+        return 0;
+    }
+
+    if (status & (STICKYERR | WDATAERR)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+uint8_t jtag_read_core_register(uint32_t n, uint32_t *val)
+{
+    int i = 0, timeout = 100;
+    uint32_t tempCommand = 0;
+    if (!jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0)) {
+        return 0;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_TRANSFER_SHIFT) | n;
+    if (!jtag_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand, 0x0)) {
+        return 0;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!jtag_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, val)) {
+            return 0;
+        }
+
+        if ((*val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((*val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                break;
+            } else {
+                jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0);
+                return 0;
+            }
+        }
+    }
+
+    if (i == timeout) {
+        return 0;
+    }
+
+    if (!jtag_read_word(RISCV_DM_DATA0 << RISCV_DM_ADDRESS_SHIFT, val)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+uint8_t jtag_write_core_register(uint32_t n, uint32_t val)
+{
+    int i = 0, timeout = 100;
+    uint32_t tempCommand = 0;
+    if (!jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0)) {
+        return 0;
+    }
+    if (!jtag_write_word(RISCV_DM_DATA0 << RISCV_DM_ADDRESS_SHIFT, val, 0x0)) {
+        return 0;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_TRANSFER_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_WRITE_SHIFT) | n;
+
+    if (!jtag_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand, 0x0)) {
+        return 0;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!jtag_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+            return 0;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                return 1;
+            } else {
+                jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0);
+                return 0;
+            }
+        }
+    }
+    return 0;
+}
+
+static uint8_t jtag_wait_until_halted(void)
+{
+    // Wait for target to stop
+    uint32_t val, i, timeout = MAX_TIMEOUT;
+
+    for (i = 0; i < timeout; i++) {
+        if (!jtag_read_word(RISCV_DM_DMSTATUS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+            return 0;
+        }
+
+        if (val & (0x1 << RISCV_DM_DMSTATUS_ALLHALTED_SHIFT)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static uint32_t jtag_csrrw(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+	return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRW;
+}
+
+static uint32_t jtag_csrrs(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+    return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRS;
+}
+
+static uint32_t jtag_csrrc(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+    return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRC;
+}
+
+static uint8_t jtag_halted(void)
+{
+    /* halt hart */
+    if (!jtag_write_word(RISCV_DM_DMCONTROL << RISCV_DM_ADDRESS_SHIFT, 1 << RISCV_DM_DMCONTROL_HALTREQ_SHIFT | 0x1, 0x0)) {
+        return 0;
+    }
+     if (!jtag_wait_until_halted()) {
+        return 0;
+    }
+    return 1;
+}
+
+static uint8_t jtag_set_pc(uint32_t pc_addr)
+{
+    uint32_t tempCommand;
+    uint32_t i;
+    uint32_t val;
+    uint32_t timeout = 100;
+    uint32_t temReg;
+    uint32_t s0;
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_read_core_register(temReg,  &s0)) {
+        return 0;
+    }
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_write_core_register(temReg, pc_addr)) {
+        goto SET_PC_ERR;
+    }
+
+    if (!jtag_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, jtag_csrrw(0,8,RISCV_DM_DPC), 0x0)) {
+         goto SET_PC_ERR;
+    }
+
+    if (!jtag_write_word(RISCV_DM_PROGBUF1 << RISCV_DM_ADDRESS_SHIFT,RISCV_DM_EBREAK_CMD, 0x0)) {
+         goto SET_PC_ERR;
+    }
+
+    if (!jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0)) {
+         goto SET_PC_ERR;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_POSTEXEC_SHIFT)| 0x1000;
+
+    if (!jtag_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand, 0x0)) {
+         goto SET_PC_ERR;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!jtag_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+             goto SET_PC_ERR;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                goto SET_PC_SUCCESS;
+            } else {
+                jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0);
+                goto SET_PC_ERR;
+            }
+        }
+    }
+
+SET_PC_ERR:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    jtag_write_core_register(temReg, s0);
+    return 0;
+
+SET_PC_SUCCESS:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_write_core_register(temReg, s0)) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+
+static uint8_t jtag_set_ebreak_mode(uint8_t mode)
+{
+    uint32_t tempCommand;
+    uint32_t i;
+    uint32_t val;
+    uint32_t timeout = 100;
+    uint32_t temReg;
+    uint32_t s0;
+    uint32_t try = 5;
+
+    /* halt hart */
+    for (i = 0; i < try;) {
+        i++;
+        if (jtag_halted()) {
+            break;
+        }
+        if (i == try) {
+            return 0;
+        }
+    }
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_read_core_register(temReg,  &s0)) {
+        return 0;
+    }
+    if (mode == 0) {
+        val = ~(0x1 << RISCV_DM_DCSR_EBREAK_SHIFT);
+    } else {
+        val = (0x1 << RISCV_DM_DCSR_EBREAK_SHIFT);
+    }
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_write_core_register(temReg, val)) {
+        goto SET_EBREAK_MODE_ERR;
+    }
+
+    if (mode == 0) {
+         if (!jtag_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, jtag_csrrc(0,8,RISCV_DM_DCSR), 0x0)) {
+            goto SET_EBREAK_MODE_ERR;
+        }
+    } else {
+        if (!jtag_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, jtag_csrrs(0,8,RISCV_DM_DCSR), 0x0)) {
+            goto SET_EBREAK_MODE_ERR;
+        }
+    }
+
+    if (!jtag_write_word(RISCV_DM_PROGBUF1 << RISCV_DM_ADDRESS_SHIFT, RISCV_DM_EBREAK_CMD, 0x0)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+
+    if (!jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_POSTEXEC_SHIFT)| 0x1000;
+
+    if (!jtag_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand, 0x0)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!jtag_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+             goto SET_EBREAK_MODE_ERR;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                goto SET_EBREAK_MODE_SUCCESS;
+            } else {
+                jtag_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8, 0x0);
+                 goto SET_EBREAK_MODE_ERR;
+            }
+        }
+    }
+
+SET_EBREAK_MODE_ERR:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    jtag_write_core_register(temReg, s0);
+    return 0;
+
+SET_EBREAK_MODE_SUCCESS:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_write_core_register(temReg, s0)) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+
+uint8_t jtag_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type)
+{
+    uint32_t temReg;
+    volatile DEBUG_STATE state = {{0}};
+    // Call flash algorithm function on target and wait for result.
+    state.r[10]     = arg1;                   // R10: Argument 1
+    state.r[11]     = arg2;                   // R11: Argument 2
+    state.r[12]     = arg3;                   // R12: Argument 3
+    state.r[13]     = arg4;                   // R13: Argument 4
+    state.r[3]      = sysCallParam->static_base;    // SB: Static Base
+    state.r[2]      = sysCallParam->stack_pointer;  // SP: Stack Pointer
+    state.r[1]      = sysCallParam->breakpoint;     // LR: Exit Point
+    state.r[32]     = entry;                        // PC: Entry Point
+
+    if (!jtag_write_debug_state((DEBUG_STATE *)&state)) {
+        return 0;
+    }
+    if (!jtag_wait_until_halted()) {
+        return 0;
+    }
+    temReg = 10 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!jtag_read_core_register(temReg, (uint32_t *)&state.r[10])) {
+        return 0;
+    }
+
+    if ( return_type == FLASHALGO_RETURN_POINTER ) {
+        // Flash verify functions return pointer to byte following the buffer if successful.
+        if (state.r[10] != (arg1 + arg2)) {
+            return 0;
+        }
+    } else {
+        // Flash functions return 0 if successful.
+        if (state.r[10] != 0) {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+// JTAG Reset
+static uint8_t jtag_reset(void)
+{
+    uint8_t tmp_in[8];
+    uint8_t i = 0;
+
+    for (i = 0; i < 8; i++) {
+        tmp_in[i] = 0xff;
+    }
+
+    SWJ_Sequence(51, tmp_in);
+    return 1;
+}
+
+// JTAG Switch
+static uint8_t jtag_switch(uint16_t val)
+{
+    uint8_t tmp_in[2];
+    tmp_in[0] = val & 0xff;
+    tmp_in[1] = (val >> 8) & 0xff;
+    SWJ_Sequence(16, tmp_in);
+    return 1;
+}
+
+// JTAG Read ID
+static uint8_t jtag_read_idcode(uint32_t *id)
+{
+    *id = JTAG_ReadIDCode();
+    // uint8_t tmp_out[4];
+    // if (jtag_read_dp(0, (uint32_t *)tmp_out) != 0x01) {
+    //     return 0;
+    // }
+
+    // *id = (tmp_out[3] << 24) | (tmp_out[2] << 16) | (tmp_out[1] << 8) | tmp_out[0];
+    return 1;
+}
+
+
+uint8_t SWD2JTAG()
+{
+    uint32_t tmp = 0;
+
+    if (!jtag_reset()) {
+        return 0;
+    }
+
+    if (!jtag_switch(0xE73C)) {
+        return 0;
+    }
+
+    JTAG_RESET();
+    jtag_read_idcode(&tmp);
+    if (tmp == 0 || tmp == 0xFFFFFFFF) {
+        return 0;
+    }
+
+    return 1;
+}
+
+uint8_t jtag_init_debug(void)
+{
+    uint32_t tmp = 0;
+    int i = 0;
+    int timeout = 100;
+    // init dap state with fake values
+    dap_state.select = 0xffffffff;
+    dap_state.csw = 0xffffffff;
+
+    int8_t retries = 4;
+    int8_t do_abort = 0;
+    do {
+        if (do_abort) {
+            //do an abort on stale target, then reset the device
+            JTAG_WriteAbort(DAPABORT);
+            //jtag_write_dp(DP_ABORT, DAPABORT);
+            jtag_set_target_reset(1);
+            osDelay(2);
+            jtag_set_target_reset(0);
+            osDelay(2);
+            do_abort = 0;
+        }
+        jtag_init();
+        // call a target dependant function
+        // this function can do several stuff before really
+        // initing the debug
+        if (g_target_family && g_target_family->target_before_init_debug) {
+            g_target_family->target_before_init_debug();
+        }
+
+        if (!SWD2JTAG()) {
+            do_abort = 1;
+            continue;
+        }
+
+        if (!jtag_clear_errors()) {
+            do_abort = 1;
+            continue;
+        }
+
+        if (!jtag_write_dp(DP_SELECT, 0)) {
+            do_abort = 1;
+            continue;
+
+        }
+
+        // Power up
+        if (!jtag_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
+            do_abort = 1;
+            continue;
+        }
+
+        for (i = 0; i < timeout; i++) {
+
+            if (!jtag_read_dp(DP_CTRL_STAT, &tmp)) {
+                do_abort = 1;
+                break;
+            }
+
+            if ((tmp & (CDBGPWRUPACK | CSYSPWRUPACK)) == (CDBGPWRUPACK | CSYSPWRUPACK)) {
+                 //Break from loop if powerup is complete
+                break;
+            }
+        }
+        if ((i == timeout) || (do_abort == 1)) {
+            // Unable to powerup DP
+            do_abort = 1;
+            continue;
+        }
+
+        if (!jtag_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)) {
+            do_abort = 1;
+            continue;
+        }
+
+        // call a target dependant function:
+        // some target can enter in a lock state
+        // this function can unlock these targets
+        if (g_target_family && g_target_family->target_unlock_sequence) {
+            g_target_family->target_unlock_sequence();
+        }
+
+        if (!jtag_write_dp(DP_SELECT, 0)) {
+            do_abort = 1;
+            continue;
+        }
+
+        if (!jtag_set_ebreak_mode(1)) {
+            do_abort = 1;
+            continue;
+        }
+        return 1;
+
+    } while (--retries > 0);
+
+    return 0;
+}
+
+uint8_t jtag_set_target_state_hw(target_state_t state)
+{
+    uint32_t val;
+    int8_t ap_retries = 2;
+    /* Calling jtag_init prior to entering RUN state causes operations to fail. */
+    if (state != RUN) {
+        jtag_init();
+    }
+
+    switch (state) {
+        case RESET_HOLD:
+            jtag_set_target_reset(1);
+            break;
+
+        case RESET_RUN:
+            jtag_set_target_reset(1);
+            osDelay(2);
+            jtag_set_target_reset(0);
+            osDelay(2);
+            jtag_off();
+            break;
+
+        case RESET_PROGRAM:
+            if (!jtag_init_debug()) {
+                return 0;
+            }
+
+            if (reset_connect == CONNECT_UNDER_RESET) {
+                // Assert reset
+                jtag_set_target_reset(1);
+                osDelay(2);
+            }
+
+            // Enable debug
+            while(jtag_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN, 0x0) == 0) {
+                if( --ap_retries <=0 )
+                    return 0;
+                // Target is in invalid state?
+                jtag_set_target_reset(1);
+                osDelay(2);
+                jtag_set_target_reset(0);
+                osDelay(2);
+            }
+
+            // Enable halt on reset
+            if (!jtag_write_word(DBG_EMCR, VC_CORERESET, 0x0)) {
+                return 0;
+            }
+
+            if (reset_connect == CONNECT_NORMAL) {
+                // Assert reset
+                jtag_set_target_reset(1);
+                osDelay(2);
+            }
+
+            // Deassert reset
+            jtag_set_target_reset(0);
+            osDelay(2);
+
+            do {
+                if (!jtag_read_word(DBG_HCSR, &val)) {
+                    return 0;
+                }
+            } while ((val & S_HALT) == 0);
+
+            // Disable halt on reset
+            if (!jtag_write_word(DBG_EMCR, 0, 0x0)) {
+                return 0;
+            }
+
+            break;
+
+        case NO_DEBUG:
+            if (!jtag_write_word(DBG_HCSR, DBGKEY, 0x0)) {
+                return 0;
+            }
+
+            break;
+
+        case DEBUG:
+            if (!SWD2JTAG()) {
+                return 0;
+            }
+
+            if (!jtag_clear_errors()) {
+                return 0;
+            }
+
+            // Ensure CTRL/STAT register selected in DPBANKSEL
+            if (!jtag_write_dp(DP_SELECT, 0)) {
+                return 0;
+            }
+
+            // Power up
+            if (!jtag_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
+                return 0;
+            }
+
+            // Enable debug
+            if (!jtag_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN, 0x0)) {
+                return 0;
+            }
+
+            break;
+
+        case HALT:
+            if (!jtag_init_debug()) {
+                return 0;
+            }
+
+            // Enable debug and halt the core (DHCSR <- 0xA05F0003)
+            if (!jtag_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT, 0x0)) {
+                return 0;
+            }
+
+            // Wait until core is halted
+            do {
+                if (!jtag_read_word(DBG_HCSR, &val)) {
+                    return 0;
+                }
+            } while ((val & S_HALT) == 0);
+            break;
+
+        case RUN:
+            if (!jtag_write_word(DBG_HCSR, DBGKEY, 0x0)) {
+                return 0;
+            }
+            jtag_off();
+            break;
+
+        case POST_FLASH_RESET:
+            // This state should be handled in target_reset.c, nothing needs to be done here.
+            break;
+
+        default:
+            return 0;
+    }
+
+    return 1;
+}
+
+uint8_t jtag_set_target_state_sw(target_state_t state)
+{
+    uint32_t val;
+    /* Calling jtag_init prior to enterring RUN state causes operations to fail. */
+    if (state != RUN) {
+        jtag_init();
+    }
+
+    switch (state) {
+        case RESET_HOLD:
+            jtag_set_target_reset(1);
+            break;
+
+        case RESET_RUN:
+            jtag_set_target_reset(1);
+            osDelay(2);
+            jtag_set_target_reset(0);
+            osDelay(2);
+
+            // Power down
+            // Per ADIv6 spec. Clear first CSYSPWRUPREQ followed by CDBGPWRUPREQ
+            if (!jtag_read_dp(DP_CTRL_STAT, &val)) {
+                return 0;
+            }
+
+            if (!jtag_write_dp(DP_CTRL_STAT, val & ~CSYSPWRUPREQ)) {
+                return 0;
+            }
+
+            // Wait until ACK is deasserted
+            do {
+                if (!jtag_read_dp(DP_CTRL_STAT, &val)) {
+                    return 0;
+                }
+            } while ((val & (CSYSPWRUPACK)) != 0);
+
+            if (!jtag_write_dp(DP_CTRL_STAT, val & ~CDBGPWRUPREQ)) {
+                return 0;
+            }
+
+            // Wait until ACK is deasserted
+            do {
+                if (!jtag_read_dp(DP_CTRL_STAT, &val)) {
+                    return 0;
+                }
+            } while ((val & (CDBGPWRUPACK)) != 0);
+
+            jtag_off();
+            break;
+
+        case RESET_PROGRAM:
+            if (!jtag_init_debug()) {
+                return 0;
+            }
+
+            jtag_exec_soft_reset();
+            if (!jtag_init_debug()) {
+                return 0;
+            }
+            break;
+
+        case NO_DEBUG:
+            if (!jtag_write_word(DBG_HCSR, DBGKEY, 0x0)) {
+                return 0;
+            }
+
+            break;
+
+        case DEBUG:
+            if (!SWD2JTAG()) {
+                return 0;
+            }
+
+            if (!jtag_clear_errors()) {
+                return 0;
+            }
+
+            // Ensure CTRL/STAT register selected in DPBANKSEL
+            if (!jtag_write_dp(DP_SELECT, 0)) {
+                return 0;
+            }
+
+            // Power up
+            if (!jtag_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
+                return 0;
+            }
+
+            // Enable debug
+            if (!jtag_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN, 0x0)) {
+                return 0;
+            }
+
+            break;
+
+        case HALT:
+            if (!jtag_init_debug()) {
+                return 0;
+            }
+
+            // Enable debug and halt the core (DHCSR <- 0xA05F0003)
+            if (!jtag_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT, 0x0)) {
+                return 0;
+            }
+
+            // Wait until core is halted
+            do {
+                if (!jtag_read_word(DBG_HCSR, &val)) {
+                    return 0;
+                }
+            } while ((val & S_HALT) == 0);
+            break;
+
+        case RUN:
+            if (!jtag_write_word(DBG_HCSR, DBGKEY, 0x0)) {
+                return 0;
+            }
+            jtag_off();
+            break;
+
+        case POST_FLASH_RESET:
+            // This state should be handled in target_reset.c, nothing needs to be done here.
+            break;
+
+        default:
+            return 0;
+    }
+
+    return 1;
+}
+
+void jtag_exec_soft_reset(void)
+{
+    uint32_t val;
+    jtag_init_debug();
+    /* Set <sc_hrst_res>(0x10100200)  debug flag register */
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    jtag_read_dp(DP_RDBUFF,&val);
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_TAR, 0x10100200, 0x1000000);
+    jtag_write_ap(AP_DRW, 0xA5A5A5A5, 0x1000000);
+
+    /* Unlock <sc_cfg_lock>(0x10100044)  configuration lock register */
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    jtag_read_dp(DP_RDBUFF,&val);
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_TAR, 0x10100044, 0x1000000);
+    jtag_write_ap(AP_DRW, 0xEA510000, 0x1000000);
+
+    /* Set<PERI_CRG>  (0x1000001C)  to HOSC (0x1000001C = 0x8) -- bit1~0: 0-HOSC, 1-XTAL, 2-PLL */
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    jtag_read_dp(DP_RDBUFF,&val);
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_TAR, 0x1000001C, 0x1000000);
+    jtag_write_ap(AP_DRW, 0x00000008, 0x1000000);
+
+    /* Set <sc_sys_res>(0x10100004) system reset register  to reset system */
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    jtag_read_dp(DP_RDBUFF,&val);
+    jtag_write_dp(DP_SELECT, 0x1000000);
+    jtag_write_ap(AP_TAR, 0x10100004, 0x1000000);
+    jtag_write_ap(AP_DRW, 0x00000001, 0x1000000);
+
+    /* Add some clocks to ensure the last write operations takes effect  with  jlink */
+    jtag_read_dp(DP_RDBUFF,&val);
+     /* Wait until the reset is complete. */
+    osDelay(300);
+}
+#endif
diff -uNr old/CA7/source/daplink/interface/jtag_host.h new/CA7/source/daplink/interface/jtag_host.h
--- old/CA7/source/daplink/interface/jtag_host.h	1970-01-01 08:00:00.000000000 +0800
+++ new/CA7/source/daplink/interface/jtag_host.h	2023-06-08 11:47:56.470578000 +0800
@@ -0,0 +1,68 @@
+/**
+ * @file    jtag_host.h
+ * @brief   Host driver for accessing the DAP
+ *
+ * DAPLink Interface Firmware
+ * Copyright (c) 2009-2019, ARM Limited, All Rights Reserved
+ * Copyright 2019, Cypress Semiconductor Corporation
+ * or a subsidiary of Cypress Semiconductor Corporation.
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JTAGHOST_CM_H
+#define JTAGHOST_CM_H
+
+#include "flash_blob.h"
+#include "target_family.h"
+#ifdef TARGET_MCU_CORTEX_A
+#include "debug_ca.h"
+#else
+#include "debug_cm.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+uint8_t jtag_init(void);
+uint8_t jtag_off(void);
+uint8_t jtag_init_debug(void);
+uint8_t jtag_clear_errors(void);
+uint8_t jtag_read_dp(uint8_t adr, uint32_t *val);
+uint8_t jtag_write_dp(uint8_t adr, uint32_t val);
+uint8_t jtag_read_ap(uint32_t adr, uint32_t *val,uint32_t apsel);
+uint8_t jtag_write_ap(uint32_t adr, uint32_t val,uint32_t apsel);
+uint8_t jtag_read_word(uint32_t addr, uint32_t *val);
+uint8_t jtag_write_word(uint32_t addr, uint32_t val, uint32_t apsel);
+uint8_t jtag_read_byte(uint32_t addr, uint8_t *val);
+uint8_t jtag_write_byte(uint32_t addr, uint8_t val);
+uint8_t jtag_read_memory(uint32_t address, uint8_t *data, uint32_t size);
+uint8_t jtag_write_memory(uint32_t address, uint8_t *data, uint32_t size);
+uint8_t jtag_read_core_register(uint32_t n, uint32_t *val);
+uint8_t jtag_write_core_register(uint32_t n, uint32_t val);
+uint8_t jtag_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type);
+uint8_t jtag_set_target_state_hw(target_state_t state);
+uint8_t jtag_set_target_state_sw(target_state_t state);
+uint8_t jtag_transfer_retry(uint32_t req, uint32_t *data);
+void jtag_set_reset_connect(JTAG_SWD_CONNECT_TYPE type);
+void jtag_set_soft_reset(uint32_t soft_reset_type);
+void jtag_exec_soft_reset(void);
+uint8_t SWD2JTAG(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -uNr old/CA7/source/daplink/interface/main_interface.c new/CA7/source/daplink/interface/main_interface.c
--- old/CA7/source/daplink/interface/main_interface.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/main_interface.c	2023-12-27 14:14:08.214716956 +0800
@@ -29,6 +29,7 @@
 #include "uart.h"
 #include "tasks.h"
 #include "swd_host.h"
+#include "jtag_host.h"
 #include "info.h"
 #include "settings.h"
 #include "daplink.h"
@@ -50,6 +51,21 @@
 #include "rtx_os.h"
 #endif
 
+#ifdef HISPARK_TRACE
+#include "debug.h"
+#include "key.h"
+#include "oled.h"
+#include "target_lib_manager.h"
+#include "offline_download.h"
+#include "offline_sys_config.h"
+#include "var_monitor_process.h"
+#include "display.h"
+#include "remote_proc.h"
+#include "msg_queue.h"
+#include "factory_manager.h"
+#include "gpio.h"
+#endif
+
 #if defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
 #ifndef __MICROLIB
 /* Avoids early implicit call to osKernelInitialize() */
@@ -81,6 +97,12 @@
 #define FLAGS_MAIN_CDC_EVENT    (1 << 11)
 // Used by msd when flashing a new binary
 #define FLAGS_LED_BLINK_30MS    (1 << 6)
+#ifdef HISPARK_TRACE
+#define FLAGS_MAIN_450MS        (1 << 7)
+#define FLAGS_MAIN_1200MS       (1 << 8)
+#define FLAGS_MAIN_LOOP         (1 << 31)
+#define FLAGS_MAIN_60MS         (1 << 12)
+#endif
 
 // Timing constants (in 90mS ticks)
 // USB busy time (~3 sec)
@@ -110,26 +132,34 @@
 #define MSC_LED_DEF GPIO_LED_OFF
 #endif
 
+#ifdef HISPARK_TRACE
+#define TICK_30MS  (30)
+#define TICK_60MS  (60)
+#define TICK_90MS  (90)
+#define TICK_450MS (450)
+#define TICK_1200MS (1200)
+#endif
+
 // Reference to our main task
 osThreadId_t main_task_id;
 #ifndef USE_LEGACY_CMSIS_RTOS
 static uint32_t s_main_thread_cb[WORDS(sizeof(osRtxThread_t))];
 static uint64_t s_main_task_stack[MAIN_TASK_STACK / sizeof(uint64_t)];
 static const osThreadAttr_t k_main_thread_attr = {
-        .name = "main",
-        .cb_mem = s_main_thread_cb,
-        .cb_size = sizeof(s_main_thread_cb),
-        .stack_mem = s_main_task_stack,
-        .stack_size = sizeof(s_main_task_stack),
-        .priority = MAIN_TASK_PRIORITY,
-    };
+    .name = "main",
+    .cb_mem = s_main_thread_cb,
+    .cb_size = sizeof(s_main_thread_cb),
+    .stack_mem = s_main_task_stack,
+    .stack_size = sizeof(s_main_task_stack),
+    .priority = MAIN_TASK_PRIORITY,
+};
 
 static uint32_t s_timer_30ms_cb[WORDS(sizeof(osRtxTimer_t))];
 static const osTimerAttr_t k_timer_30ms_attr = {
-        .name = "30ms",
-        .cb_mem = s_timer_30ms_cb,
-        .cb_size = sizeof(s_timer_30ms_cb),
-    };
+    .name = "30ms",
+    .cb_mem = s_timer_30ms_cb,
+    .cb_size = sizeof(s_timer_30ms_cb),
+};
 #endif
 
 // USB busy LED state; when TRUE the LED will flash once using 30mS clock tick
@@ -149,6 +179,12 @@
 
 }
 
+#ifdef HISPARK_TRACE
+__WEAK void DisplayPeriodProcHook(void)
+{
+}
+#endif
+
 __WEAK void handle_reset_button(void)
 {
 	// button state
@@ -171,12 +207,12 @@
     }
 }
 
-__WEAK void board_handle_powerdown()
+__WEAK void board_handle_powerdown(void)
 {
     // TODO: put the interface chip in sleep mode
 }
 
-__WEAK void board_custom_event()
+__WEAK void board_custom_event(void)
 {
 
 }
@@ -263,10 +299,152 @@
 
 extern void cdc_process_event(void);
 
+#ifdef HISPARK_TRACE
+uint32_t GetTickDelta(uint32_t curTicks, uint32_t preTicks)
+{
+    if (curTicks >= preTicks) {
+        return curTicks - preTicks;
+    } else {
+        return 0xFFFFFFFF - preTicks + curTicks + 1;
+    }
+}
+
+void M4_Startup(void)
+{
+    MSGQ_Init(); /* 消息队列初始化 */
+    RemoteStart();
+}
+
+void KeyProcess(void)
+{
+    uint8_t key_value = 0;
+    key_value = KeyScan(SHORT_KEY);
+    switch (key_value) {
+        case KEY_DOWN:
+            FrameMoveDown();
+            break;
+        case KEY_UP:
+            FrameMoveUp();
+            break;
+        case KEY_CONFIRM:
+            FrameItemSelect();
+            break;
+        default:
+            break;
+    }
+}
+extern void DaplinkStatusSetTest(void);
+UART_Configuration my_UART_Config;
+
+void my_uart_init(void)
+{
+    my_UART_Config.Baudrate    = 115200; /* Default baudrate = 115200 */
+    my_UART_Config.DataBits    = 0;
+    my_UART_Config.Parity      = 0;
+    my_UART_Config.StopBits    = 8;      /* stop bits = 8 */
+    my_UART_Config.FlowControl = UART_FLOW_CONTROL_NONE;
+
+    uart_set_configuration(&my_UART_Config);
+}
+
+static void UpdateUsbStatus(uint32_t *usbStateCnt, uint32_t *usbNoCfgCnt)
+{
+    uint32_t usb_state_count = *usbStateCnt;
+    uint32_t usb_no_config_count = *usbNoCfgCnt;
+    // Update USB busy status
+#ifdef DRAG_N_DROP_SUPPORT
+    vfs_mngr_periodic(90); // FLAGS_MAIN_90MS
+#endif
+    DAP_StatusDetection();
+    // Update USB connect status
+    switch (usb_state) {
+        case USB_DISCONNECTING:
+            usb_state = USB_DISCONNECTED;
+            // Disable board power before USB is disconnected.
+            gpio_set_board_power(false);
+            usbd_connect(0);
+            break;
+
+        case USB_CONNECTING:
+            // Wait before connecting
+            if (DECZERO(usb_state_count) == 0) {
+                usbd_connect(1);
+                usb_state = USB_CHECK_CONNECTED;
+                // Reset connect timeout
+                usb_no_config_count = USB_CONFIGURE_TIMEOUT;
+            }
+            break;
+
+        case USB_CHECK_CONNECTED:
+            if (usbd_configured()) {
+                // Let the HIC enable power to the target now that high power has been negotiated.
+                gpio_set_board_power(true);
+
+                usb_state = USB_CONNECTED;
+            } else if (DECZERO(usb_no_config_count) == 0) {
+                // USB configuration timed out, which most likely indicates that the HIC is
+                // powered by a USB wall wart or similar power source. Go ahead and enable
+                // board power.
+                gpio_set_board_power(true);
+                usb_state = USB_DISCONNECTED;
+            }
+
+            break;
+
+        case USB_CONNECTED:
+        case USB_DISCONNECTED:
+            if (usbd_configured()) {
+                usb_state = USB_CONNECTED;
+            } else {
+                usb_state = USB_DISCONNECTED;
+                usb_state_count = USB_CONNECT_DELAY;
+                usb_no_config_count = USB_CONFIGURE_TIMEOUT;
+            }
+        default:
+            break;
+    }
+
+    *usbStateCnt = usb_state_count;
+    *usbNoCfgCnt = usb_no_config_count;
+}
+
+#ifdef PBON_BUTTON
+static void PbonPressProcess(uint8_t *powerOn)
+{
+    // handle PBON pressed
+    if (gpio_get_pbon_btn()) {
+        if (*powerOn) {
+            // Loop till PBON is pressed
+            while (gpio_get_pbon_btn()) {
+                ;
+            }
+            // Power button released when target was running
+            target_set_state(SHUTDOWN);
+            *powerOn = 0;
+        } else {
+            // Loop till PBON is pressed
+            while (gpio_get_pbon_btn()) {
+                ;
+            }
+            // Power button released when target was already powered off
+            target_set_state(POWER_ON);
+            *powerOn = 1;
+        }
+    }
+}
+#endif
+#endif
+
 void main_task(void * arg)
 {
     // State processing
     uint16_t flags = 0;
+#ifdef HISPARK_TRACE	
+    uint32_t preTicks;
+    uint32_t curTicks;
+    uint32_t delta;
+    uint32_t times = 0;
+#endif	
     // LED
     gpio_led_state_t hid_led_value = HID_LED_DEF;
     gpio_led_state_t cdc_led_value = CDC_LED_DEF;
@@ -287,6 +465,18 @@
 #endif
     // leds
     gpio_init();
+
+#ifdef HISPARK_TRACE
+// NOTE!!!!! if use debug, CDC can't be used!
+#if (DBG_PRINTF_USE == DBG_USE_CUSTOM_PRINTF)
+    uart_initialize();
+    my_uart_init();
+#endif
+
+    DBG_PRINTF("\r\nDaplink\r\n");
+    M4_Startup();
+    gpio_set_daplink_run(GPIO_LED_ON);
+#endif	
     // Turn to LED default settings
     gpio_set_hid_led(hid_led_value);
     gpio_set_cdc_led(cdc_led_value);
@@ -302,16 +492,17 @@
         g_board_info.prerun_board_config();
     }
 
-    //initialize the family
+    // initialize the family
     init_family();
 
     if (g_target_family && g_target_family->prerun_target_config) {
         g_target_family->prerun_target_config();
     }
 
-    //setup some flags
+    // setup some flags
     if (g_board_info.flags & kEnableUnderResetConnect) {
         swd_set_reset_connect(CONNECT_UNDER_RESET);
+        jtag_set_reset_connect(CONNECT_UNDER_RESET);
     }
     if (g_board_info.flags & kEnablePageErase) {
 #ifdef DRAG_N_DROP_SUPPORT
@@ -333,24 +524,53 @@
     usb_state_count = USB_CONNECT_DELAY;
 
     // Start timer tasks
-#ifndef USE_LEGACY_CMSIS_RTOS
-    osTimerId_t tmr_id = osTimerNew(timer_task_30mS, osTimerPeriodic, NULL, &k_timer_30ms_attr);
-#else
-    osTimerId_t tmr_id = osTimerNew(timer_task_30mS, osTimerPeriodic, NULL, NULL);
-#endif
-    osTimerStart(tmr_id, 3);
+    preTicks = HAL_GetTick();
+    OfflineSysConfigInit();
+    OfflineDownLoadInit();
+    TargetLibInit();
+    FactoryInit();
+    DisplayInit();
+
     while (1) {
-        flags = osThreadFlagsWait(FLAGS_MAIN_RESET             // Put target in reset state
-                       | FLAGS_MAIN_90MS            // 90mS tick
-                       | FLAGS_MAIN_30MS            // 30mS tick
-                       | FLAGS_MAIN_POWERDOWN       // Power down interface
-                       | FLAGS_MAIN_DISABLEDEBUG    // Disable target debug
-                       | FLAGS_MAIN_PROC_USB        // process usb events
-                       | FLAGS_MAIN_CDC_EVENT       // cdc event
-                       | FLAGS_BOARD_EVENT          // custom board event
-                       , osFlagsWaitAny
-                       , osWaitForever);
+        osThreadFlagsSet(main_task_id, FLAGS_MAIN_LOOP);
+        flags = osThreadFlagsWait(FLAGS_MAIN_RESET  // Put target in reset state
+            | FLAGS_MAIN_90MS            // 90mS tick
+            | FLAGS_MAIN_60MS            // 60mS tick            
+            | FLAGS_MAIN_1200MS
+            | FLAGS_MAIN_450MS
+            | FLAGS_MAIN_30MS            // 30mS tick
+            | FLAGS_MAIN_POWERDOWN       // Power down interface
+            | FLAGS_MAIN_DISABLEDEBUG    // Disable target debug
+            | FLAGS_MAIN_PROC_USB        // process usb events
+            | FLAGS_MAIN_CDC_EVENT       // cdc event
+            | FLAGS_BOARD_EVENT          // custom board event
+            | FLAGS_MAIN_LOOP,
+            osFlagsWaitAny,
+            osWaitForever);
+
+        curTicks = HAL_GetTick();
+        delta = GetTickDelta(curTicks, preTicks);
+        if (delta >= TICK_30MS) {
+            osThreadFlagsSet(main_task_id, FLAGS_MAIN_30MS);
+            times++;
+            if ((times % (TICK_60MS / TICK_30MS)) == 0) {
+                osThreadFlagsSet(main_task_id, FLAGS_MAIN_60MS);
+            }            
+            if ((times & (TICK_90MS / TICK_30MS)) == 0) {
+                osThreadFlagsSet(main_task_id, FLAGS_MAIN_90MS);
+            }
+            if ((times % (TICK_450MS / TICK_30MS)) == 0) {
+                osThreadFlagsSet(main_task_id, FLAGS_MAIN_450MS);
+            }
+            if ((times % (TICK_1200MS / TICK_30MS)) == 0) {
+                osThreadFlagsSet(main_task_id, FLAGS_MAIN_1200MS);
+            }
+            preTicks = curTicks;
+        }
 
+        if (flags == FLAGS_MAIN_LOOP) {
+            continue;
+        }
         if (flags & FLAGS_MAIN_PROC_USB) {
             if (usb_test_mode) {
                 // When in USB test mode Insert a delay to
@@ -379,109 +599,44 @@
             board_handle_powerdown();
         }
 
-        if (flags & FLAGS_MAIN_DISABLEDEBUG) {
-            // Disable debug
-            target_set_state(NO_DEBUG);
-        }
-
+#if (DBG_PRINTF_USE == DBG_USE_NO_PRINTF)
         if (flags & FLAGS_MAIN_CDC_EVENT) {
             cdc_process_event();
         }
-        
+#endif
         if (flags & FLAGS_BOARD_EVENT) {
             board_custom_event();
         }
 
-        if (flags & FLAGS_MAIN_90MS) {
-            // Update USB busy status
-#ifdef DRAG_N_DROP_SUPPORT
-            vfs_mngr_periodic(90); // FLAGS_MAIN_90MS
-#endif
-            // Update USB connect status
-            switch (usb_state) {
-                case USB_DISCONNECTING:
-                    usb_state = USB_DISCONNECTED;
-                    // Disable board power before USB is disconnected.
-                    gpio_set_board_power(false);
-                    usbd_connect(0);
-                    break;
-
-                case USB_CONNECTING:
-                    // Wait before connecting
-                    if (DECZERO(usb_state_count) == 0) {
-                        usbd_connect(1);
-                        usb_state = USB_CHECK_CONNECTED;
-                        // Reset connect timeout
-                        usb_no_config_count = USB_CONFIGURE_TIMEOUT;
-                    }
-
-                    break;
-
-                case USB_CHECK_CONNECTED:
-                    if (usbd_configured()) {
-                        // Let the HIC enable power to the target now that high power has been negotiated.
-                        gpio_set_board_power(true);
-
-                        usb_state = USB_CONNECTED;
-                    }
-                    else if (DECZERO(usb_no_config_count) == 0) {
-                        // USB configuration timed out, which most likely indicates that the HIC is
-                        // powered by a USB wall wart or similar power source. Go ahead and enable
-                        // board power.
-                        gpio_set_board_power(true);
-                        usb_state = USB_DISCONNECTED;
-                    }
-
-                    break;
-
-                case USB_CONNECTED:
-                case USB_DISCONNECTED:
-                    if (usbd_configured()) {
-                        usb_state = USB_CONNECTED;
-                    }
-                    else {
-                        usb_state = USB_DISCONNECTED;
-                        usb_state_count = USB_CONNECT_DELAY;
-                        usb_no_config_count = USB_CONFIGURE_TIMEOUT;
-                    }
-                default:
-                    break;
-            }
+        if (flags & FLAGS_MAIN_450MS) {
+            DisplayPeriodProcHook();
         }
 
+        if (flags & FLAGS_MAIN_1200MS) {
+            UpdateDapStatistics();
+        }
+        if (flags & FLAGS_MAIN_90MS) {
+            UpdateUsbStatus(&usb_state_count, &usb_no_config_count);            
+        }
+        if (flags & FLAGS_MAIN_60MS) {
+            OfflineDownLoadHandler();
+        }       
         // 30mS tick used for flashing LED when USB is busy
         if (flags & FLAGS_MAIN_30MS) {
-
+            if (!IsOfflineDownLoad()) {
+                KeyProcess();
+            }
             handle_reset_button();
 
 #ifdef PBON_BUTTON
             // handle PBON pressed
-            if(gpio_get_pbon_btn())
-            {
-                if(power_on)
-                {
-                    // Loop till PBON is pressed
-                    while (gpio_get_pbon_btn()) {;}
-                    // Power button released when target was running
-                    target_set_state(SHUTDOWN);
-                    power_on = 0;
-                }
-                else
-                {
-                    // Loop till PBON is pressed
-                    while (gpio_get_pbon_btn()) {;}
-                    // Power button released when target was already powered off
-                    target_set_state(POWER_ON);
-                    power_on = 1;
-                }
-            }
+            PbonPressProcess(&power_on);
 #endif
             // 30ms event hook function
             board_30ms_hook();
 
             // DAP LED
             if (hid_led_usb_activity) {
-
                 if ((hid_led_state == MAIN_LED_FLASH) || (hid_led_state == MAIN_LED_FLASH_PERMANENT)) {
                     // Toggle LED value
                     hid_led_value = GPIO_LED_ON == hid_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
@@ -492,7 +647,7 @@
                         hid_led_state = MAIN_LED_DEF;
                     }
                 } else {
-                    //LED next state is MAIN_LED_DEF
+                    // LED next state is MAIN_LED_DEF
                     hid_led_value = HID_LED_DEF;
                     hid_led_usb_activity = 0;
                 }
@@ -503,7 +658,6 @@
 
             // MSD LED
             if (msc_led_usb_activity) {
-
                 if ((msc_led_state == MAIN_LED_FLASH) || (msc_led_state == MAIN_LED_FLASH_PERMANENT)) {
                     // Toggle LED value
                     msc_led_value = GPIO_LED_ON == msc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
@@ -514,7 +668,7 @@
                         msc_led_state = MAIN_LED_DEF;
                     }
                 } else {
-                    //LED next state is MAIN_LED_DEF
+                    // LED next state is MAIN_LED_DEF
                     msc_led_value = MSC_LED_DEF;
                     msc_led_usb_activity = 0;
                 }
@@ -525,8 +679,7 @@
 
             // CDC LED
             if (cdc_led_usb_activity) {
-
-                if ((cdc_led_state == MAIN_LED_FLASH) || (cdc_led_state == MAIN_LED_FLASH_PERMANENT)){
+                if ((cdc_led_state == MAIN_LED_FLASH) || (cdc_led_state == MAIN_LED_FLASH_PERMANENT)) {
                     // Toggle LED value
                     cdc_led_value = GPIO_LED_ON == cdc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
 
@@ -535,8 +688,8 @@
                         cdc_led_usb_activity = 0;
                         cdc_led_state = MAIN_LED_DEF;
                     }
-                }else{
-                    //LED next state is MAIN_LED_DEF
+                } else {
+                    // LED next state is MAIN_LED_DEF
                     cdc_led_value = CDC_LED_DEF;
                     cdc_led_usb_activity = 0;
                 }
@@ -553,7 +706,9 @@
     // Explicitly set the vector table since the bootloader might not set
     // it to what we expect.
 #if DAPLINK_ROM_BL_SIZE > 0
-    SCB->VTOR = SCB_VTOR_TBLOFF_Msk & DAPLINK_ROM_IF_START;
+    // remove start by xuyong, SCB not found
+    // SCB->VTOR = SCB_VTOR_TBLOFF_Msk & DAPLINK_ROM_IF_START;
+    // remove end
 #endif
     // initialize vendor sdk
     sdk_init();
@@ -572,5 +727,7 @@
     osKernelStart();
 
     // Should never reach here!
-    for (;;) {}
+    for (;;) {
+        ;
+    }
 }
diff -uNr old/CA7/source/daplink/interface/swd_host.c new/CA7/source/daplink/interface/swd_host.c
--- old/CA7/source/daplink/interface/swd_host.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/swd_host.c	2024-12-30 10:11:39.390510672 +0800
@@ -25,11 +25,58 @@
 #include "device.h"
 #include "cmsis_os2.h"
 #include "target_config.h"
+#if defined(HISPARK_TRACE)
+#include "swd_host.h"
+#include "debug_cm.h"
+#include "offline_sys_config.h"
+#endif
 #include "DAP_config.h"
 #include "DAP.h"
 #include "target_family.h"
 #include "swd_host.h"
 
+#if defined(HISPARK_TRACE)
+// riscv DM register
+/* RISC_V Debug 模块相关的寄存器定义，
+   详细的寄存器说明请查阅RISC-V官方文档《RISC-V Debug Specification》 */
+#define RISCV_DM_ADDRESS_SHIFT    0x2
+#define MATCH_CSRRW               0x1073
+#define MATCH_CSRRS               0x2073
+#define MATCH_CSRRC               0x3073
+
+#define RISCV_DM_GPRS_BASE_ADDR   0x1000
+
+#define RISCV_DM_DATA0            0x04
+#define RISCV_DM_DATA11           0x0f
+#define RISCV_DM_HARTINFO         0x12
+#define RISCV_DM_PROGBUF0         0x20
+#define RISCV_DM_PROGBUF1         0x21
+
+#define RISCV_DM_DMCONTROL                 0x10
+#define RISCV_DM_DMCONTROL_HALTREQ_SHIFT   31
+#define RISCV_DM_DMCONTROL_RESUMEREQ_SHIFT 30
+
+#define RISCV_DM_DMSTATUS                  0x11
+#define RISCV_DM_DMSTATUS_ALLHALTED_SHIFT  9
+
+#define RISCV_DM_ABSTRACTCS                0x16
+#define RISCV_DM_ABSTRACTCS_BUSY_SHIFT    12
+#define RISCV_DM_ABSTRACTCS_CMDERR_SHIFT  8
+
+#define RISCV_DM_COMMAND                 0x17
+#define RISCV_DM_COMMAND_CMDTYPE_SHIFT   24
+#define RISCV_DM_COMMAND_AARSIZE_SHIFT   20
+#define  RISCV_DM_COMMAND_POSTEXEC_SHIFT 18
+#define RISCV_DM_COMMAND_TRANSFER_SHIFT  17
+#define RISCV_DM_COMMAND_WRITE_SHIFT     16
+
+#define RISCV_DM_DCSR                 0x7B0
+#define RISCV_DM_DCSR_EBREAK_SHIFT    15
+
+#define RISCV_DM_DPC                 0x7B1
+#define RISCV_DM_EBREAK_CMD          0x100073
+#endif
+
 // Default NVIC and Core debug base addresses
 // TODO: Read these addresses from ROM.
 #define NVIC_Addr    (0xe000e000)
@@ -43,8 +90,13 @@
 #define DHCSR 0xE000EDF0
 #define REGWnR (1 << 16)
 
+#if defined(HISPARK_TRACE)
+#define MAX_SWD_RETRY 10//10
+#define MAX_TIMEOUT   10000  // Timeout for syscalls on target
+#else
 #define MAX_SWD_RETRY 100//10
 #define MAX_TIMEOUT   1000000  // Timeout for syscalls on target
+#endif
 
 // Use the CMSIS-Core definition if available.
 #if !defined(SCB_AIRCR_PRIGROUP_Pos)
@@ -58,15 +110,32 @@
 } DAP_STATE;
 
 typedef struct {
+#if defined(HISPARK_TRACE)
+    uint32_t r[33];
+#else
     uint32_t r[16];
     uint32_t xpsr;
+#endif
 } DEBUG_STATE;
 
-static SWD_CONNECT_TYPE reset_connect = CONNECT_NORMAL;
+static JTAG_SWD_CONNECT_TYPE reset_connect = CONNECT_NORMAL;
 
 static DAP_STATE dap_state;
 static uint32_t  soft_reset = SYSRESETREQ;
 
+#if defined(HISPARK_TRACE)
+static uint8_t swd_halted(void);
+static uint8_t swd_wait_until_halted(void);
+static uint32_t swd_csrrw(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint32_t swd_csrrs(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint32_t swd_csrrc(unsigned int rd, unsigned int rs, unsigned int csr);
+static uint8_t swd_set_pc(uint32_t pc_addr);
+static uint8_t swd_set_ebreak_mode(uint8_t mode);
+#endif
+
+#if defined(HISPARK_TRACE)
+
+#else
 static uint32_t swd_get_apsel(uint32_t adr)
 {
     uint32_t apsel = target_get_apsel();
@@ -75,8 +144,8 @@
     else
         return apsel;
 }
-
-void swd_set_reset_connect(SWD_CONNECT_TYPE type)
+#endif /* #if defined(HISPARK_TRACE) */
+void swd_set_reset_connect(JTAG_SWD_CONNECT_TYPE type)
 {
     reset_connect = type;
 }
@@ -153,7 +222,11 @@
     *val |= (tmp << 8);
     tmp = tmp_out[0];
     *val |= (tmp << 0);
+#if defined(HISPARK_TRACE)
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Write debug port register
@@ -164,26 +237,39 @@
     uint8_t ack;
 
     //check if the right bank is already selected
+#ifndef HISPARK_TRACE
     if ((adr == DP_SELECT) && (dap_state.select == val)) {
         return 1;
     }
-
+#endif
     req = SWD_REG_DP | SWD_REG_W | SWD_REG_ADR(adr);
     int2array(data, val, 4);
     ack = swd_transfer_retry(req, (uint32_t *)data);
     if ((ack == DAP_TRANSFER_OK) && (adr == DP_SELECT)) {
         dap_state.select = val;
     }
+#if defined(HISPARK_TRACE)
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Read access port register.
+#ifdef HISPARK_TRACE
+uint8_t swd_read_ap(uint32_t adr, uint32_t *val, uint32_t apsel)
+#else
 uint8_t swd_read_ap(uint32_t adr, uint32_t *val)
+#endif
 {
     uint8_t tmp_in, ack;
     uint8_t tmp_out[4];
     uint32_t tmp;
+#ifdef HISPARK_TRACE
+
+#else
     uint32_t apsel = swd_get_apsel(adr);
+#endif
     uint32_t bank_sel = adr & APBANKSEL;
 
     if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
@@ -192,7 +278,6 @@
 
     tmp_in = SWD_REG_AP | SWD_REG_R | SWD_REG_ADR(adr);
     // first dummy read
-    swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
     ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
     *val = 0;
     tmp = tmp_out[3];
@@ -203,17 +288,28 @@
     *val |= (tmp << 8);
     tmp = tmp_out[0];
     *val |= (tmp << 0);
+#ifdef HISPARK_TRACE
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Write access port register
+#ifdef HISPARK_TRACE
+uint8_t swd_write_ap(uint32_t adr, uint32_t val,uint32_t apsel)
+#else
 uint8_t swd_write_ap(uint32_t adr, uint32_t val)
+#endif
 {
     uint8_t data[4];
     uint8_t req, ack;
+#ifdef HISPARK_TRACE
+
+#else
     uint32_t apsel = swd_get_apsel(adr);
+#endif
     uint32_t bank_sel = adr & APBANKSEL;
-
     if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
         return 0;
     }
@@ -240,7 +336,11 @@
 
     req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
     ack = swd_transfer_retry(req, NULL);
+#ifdef HISPARK_TRACE
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 
@@ -259,7 +359,12 @@
     size_in_words = size / 4;
 
     // CSW register
+    //AHB 地址递增写
+#ifdef HISPARK_TRACE
+    if (!swd_write_ap(AP_CSW, 0x12, 0x1000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
+#endif
         return 0;
     }
 
@@ -285,7 +390,11 @@
     // dummy read
     req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
     ack = swd_transfer_retry(req, NULL);
+#ifdef HISPARK_TRACE
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Read 32-bit word aligned values from target memory using address auto-increment.
@@ -301,8 +410,12 @@
     }
 
     size_in_words = size / 4;
-
+#ifdef HISPARK_TRACE
+    //AHB地址递增读
+    if (!swd_write_ap(AP_CSW, 0x12, 0x1000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
+#endif
         return 0;
     }
 
@@ -333,7 +446,11 @@
     // read last word
     req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
     ack = swd_transfer_retry(req, (uint32_t *)data);
+#ifdef HISPARK_TRACE
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Read target memory.
@@ -370,7 +487,11 @@
     *val |= (tmp << 8);
     tmp = tmp_out[0];
     *val |= (tmp << 0);
+#ifdef HISPARK_TRACE
+    return ack;
+#else
     return (ack == 0x01);
+#endif
 }
 
 // Write target memory.
@@ -403,7 +524,11 @@
 // Read 32-bit word from target memory.
 uint8_t swd_read_word(uint32_t addr, uint32_t *val)
 {
+#ifdef HISPARK_TRACE
+    if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32, 0x000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
+#endif
         return 0;
     }
 
@@ -417,7 +542,11 @@
 // Write 32-bit word to target memory.
 uint8_t swd_write_word(uint32_t addr, uint32_t val)
 {
+#ifdef HISPARK_TRACE
+    if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32, 0x000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
+#endif
         return 0;
     }
 
@@ -432,8 +561,11 @@
 uint8_t swd_read_byte(uint32_t addr, uint8_t *val)
 {
     uint32_t tmp;
-
+#ifdef HISPARK_TRACE
+    if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8, 0x1000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
+#endif
         return 0;
     }
 
@@ -449,8 +581,11 @@
 uint8_t swd_write_byte(uint32_t addr, uint8_t val)
 {
     uint32_t tmp;
-
+#ifdef HISPARK_TRACE
+    if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8, 0x1000000)) {
+#else
     if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
+#endif
         return 0;
     }
 
@@ -562,6 +697,66 @@
 }
 
 // Execute system call.
+#ifdef HISPARK_TRACE
+/* RISC-V */
+static uint8_t swd_write_debug_state(DEBUG_STATE *state)
+{
+    uint32_t i, status;
+    uint32_t temReg;
+    uint32_t try = 5;
+
+    if (!swd_write_dp(DP_SELECT, 0)) {
+        return 0;
+    }
+
+    /* halt hart */
+    for (i = 0; i < try;) {
+        i++;
+        if (swd_halted()) {
+            break;
+        }
+        if (i == try) {
+            return 0;
+        }
+    }
+
+    if (!swd_set_pc(state->r[32])) {
+        return 0;
+    }
+
+    // R10, R11, R12, R13
+    for (i = 10; i < 14; i++) {
+        temReg = i + RISCV_DM_GPRS_BASE_ADDR;
+        if (!swd_write_core_register(temReg, state->r[i])) {
+            return 0;
+        }
+    }
+    // x1, x2, x3
+    for (i = 1; i < 4; i++) {
+        temReg = i + RISCV_DM_GPRS_BASE_ADDR;
+        if (!swd_write_core_register(temReg, state->r[i])) {
+            return 0;
+        }
+    }
+
+    /* resume hart */
+    if (!swd_write_word(RISCV_DM_DMCONTROL << RISCV_DM_ADDRESS_SHIFT, 1 << RISCV_DM_DMCONTROL_RESUMEREQ_SHIFT | 0x1)) {
+        return 0;
+    }
+
+    // check status
+    if (!swd_read_dp(DP_CTRL_STAT, &status)) {
+        return 0;
+    }
+
+    if (status & (STICKYERR | WDATAERR)) {
+        return 0;
+    }
+
+    return 1;
+}
+#else /* #ifdef HISPARK_TRACE */
+/* ARM */
 static uint8_t swd_write_debug_state(DEBUG_STATE *state)
 {
     uint32_t i, status;
@@ -613,7 +808,49 @@
 
     return 1;
 }
+#endif /* #ifdef HISPARK_TRACE */
 
+#ifdef HISPARK_TRACE
+uint8_t swd_read_core_register(uint32_t n, uint32_t *val)
+{
+    int i = 0, timeout = 100;
+    uint32_t tempCommand = 0;
+    if (!swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8)) {
+        return 0;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_TRANSFER_SHIFT) | n;
+    if (!swd_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand)) {
+        return 0;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!swd_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, val)) {
+            return 0;
+        }
+
+        if ((*val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((*val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                break;
+            } else {
+                swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8);
+                return 0;
+            }
+        }
+    }
+
+    if (i == timeout) {
+        return 0;
+    }
+
+    if (!swd_read_word(RISCV_DM_DATA0 << RISCV_DM_ADDRESS_SHIFT, val)) {
+        return 0;
+    }
+
+    return 1;
+}
+#else /* #ifdef HISPARK_TRACE */
 uint8_t swd_read_core_register(uint32_t n, uint32_t *val)
 {
     int i = 0, timeout = 100;
@@ -643,7 +880,45 @@
 
     return 1;
 }
+#endif /* #ifdef HISPARK_TRACE */
 
+#ifdef HISPARK_TRACE
+uint8_t swd_write_core_register(uint32_t n, uint32_t val)
+{
+    int i = 0, timeout = 100;
+    uint32_t tempCommand = 0;
+    if (!swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8)) {
+        return 0;
+    }
+    if (!swd_write_word(RISCV_DM_DATA0 << RISCV_DM_ADDRESS_SHIFT, val)) {
+        return 0;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_TRANSFER_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_WRITE_SHIFT) | n;
+
+    if (!swd_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand)) {
+        return 0;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!swd_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+            return 0;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                return 1;
+            } else {
+                swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8);
+                return 0;
+            }
+        }
+    }
+    return 0;
+}
+#else /* #ifdef HISPARK_TRACE */
 uint8_t swd_write_core_register(uint32_t n, uint32_t val)
 {
     int i = 0, timeout = 100;
@@ -669,6 +944,7 @@
 
     return 0;
 }
+#endif /* #ifdef HISPARK_TRACE */
 
 static uint8_t swd_wait_until_halted(void)
 {
@@ -676,6 +952,15 @@
     uint32_t val, i, timeout = MAX_TIMEOUT;
 
     for (i = 0; i < timeout; i++) {
+#ifdef HISPARK_TRACE
+        if (!swd_read_word(RISCV_DM_DMSTATUS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+            return 0;
+        }
+
+        if (val & (0x1 << RISCV_DM_DMSTATUS_ALLHALTED_SHIFT)) {
+            return 1;
+        }
+#else
         if (!swd_read_word(DBG_HCSR, &val)) {
             return 0;
         }
@@ -683,11 +968,240 @@
         if (val & S_HALT) {
             return 1;
         }
+#endif
+    }
+
+    return 0;
+}
+
+#ifdef HISPARK_TRACE
+static uint32_t swd_csrrw(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+	return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRW;
+}
+
+static uint32_t swd_csrrs(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+    return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRS;
+}
+
+static uint32_t swd_csrrc(unsigned int rd, unsigned int rs, unsigned int csr)
+{
+    return (csr << 20) | (rs << 15) | (rd << 7) | MATCH_CSRRC;
+}
+
+static uint8_t swd_halted(void)
+{
+    /* halt hart */
+    if (!swd_write_word(RISCV_DM_DMCONTROL << RISCV_DM_ADDRESS_SHIFT, 1 << RISCV_DM_DMCONTROL_HALTREQ_SHIFT | 0x1)) {
+        return 0;
+    }
+     if (!swd_wait_until_halted()) {
+        return 0;
+    }
+    return 1;
+}
+
+static uint8_t swd_set_pc(uint32_t pc_addr)
+{
+    uint32_t tempCommand;
+    uint32_t i;
+    uint32_t val;
+    uint32_t timeout = 100;
+    uint32_t temReg;
+    uint32_t s0;
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_read_core_register(temReg,  &s0)) {
+        return 0;
+    }
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_write_core_register(temReg, pc_addr)) {
+        goto SET_PC_ERR;
+    }
+
+    if (!swd_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, swd_csrrw(0,8,RISCV_DM_DPC))) {
+         goto SET_PC_ERR;
+    }
+
+    if (!swd_write_word(RISCV_DM_PROGBUF1 << RISCV_DM_ADDRESS_SHIFT,RISCV_DM_EBREAK_CMD)) {
+         goto SET_PC_ERR;
+    }
+
+    if (!swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8)) {
+         goto SET_PC_ERR;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_POSTEXEC_SHIFT)| 0x1000;
+
+    if (!swd_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand)) {
+         goto SET_PC_ERR;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!swd_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+             goto SET_PC_ERR;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                goto SET_PC_SUCCESS;
+            } else {
+                swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8);
+                 goto SET_PC_ERR;
+            }
+        }
+    }
+
+SET_PC_ERR:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    swd_write_core_register(temReg, s0);
+    return 0;
+
+SET_PC_SUCCESS:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_write_core_register(temReg, s0)) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+
+static uint8_t swd_set_ebreak_mode(uint8_t mode)
+{
+    uint32_t tempCommand;
+    uint32_t i;
+    uint32_t val;
+    uint32_t timeout = 100;
+    uint32_t temReg;
+    uint32_t s0;
+    uint32_t try = 5;
+
+    /* halt hart */
+    for (i = 0; i < try;) {
+        i++;
+        if (swd_halted()) {
+            break;
+        }
+        if (i == try) {
+            return 0;
+        }
+    }
+
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_read_core_register(temReg,  &s0)) {
+        return 0;
+    }
+    if (mode == 0) {
+        val = ~(0x1 << RISCV_DM_DCSR_EBREAK_SHIFT);
+    } else {
+        val = (0x1 << RISCV_DM_DCSR_EBREAK_SHIFT);
+    }
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_write_core_register(temReg, val)) {
+        goto SET_EBREAK_MODE_ERR;
+    }
+
+    if (mode == 0) {
+         if (!swd_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, swd_csrrc(0,8,RISCV_DM_DCSR))) {
+            goto SET_EBREAK_MODE_ERR;
+        }
+    } else {
+        if (!swd_write_word(RISCV_DM_PROGBUF0 << RISCV_DM_ADDRESS_SHIFT, swd_csrrs(0,8,RISCV_DM_DCSR))) {
+            goto SET_EBREAK_MODE_ERR;
+        }
+    }
+
+    if (!swd_write_word(RISCV_DM_PROGBUF1 << RISCV_DM_ADDRESS_SHIFT, RISCV_DM_EBREAK_CMD)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+
+    if (!swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+    tempCommand = (0x2 << RISCV_DM_COMMAND_AARSIZE_SHIFT) |
+                  (0x1 << RISCV_DM_COMMAND_POSTEXEC_SHIFT)| 0x1000;
+
+    if (!swd_write_word(RISCV_DM_COMMAND << RISCV_DM_ADDRESS_SHIFT, tempCommand)) {
+         goto SET_EBREAK_MODE_ERR;
+    }
+
+    // wait for abstractcs busy is 0
+    for (i = 0; i < timeout; i++) {
+        if (!swd_read_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT, &val)) {
+             goto SET_EBREAK_MODE_ERR;;
+        }
+
+        if ((val >> RISCV_DM_ABSTRACTCS_BUSY_SHIFT & 0x1) == 0) {
+            if ((val >> RISCV_DM_ABSTRACTCS_CMDERR_SHIFT & 0x7) == 0) {
+                goto SET_EBREAK_MODE_SUCCESS;
+            } else {
+                swd_write_word(RISCV_DM_ABSTRACTCS << RISCV_DM_ADDRESS_SHIFT,0x7 << 8);
+                 goto SET_EBREAK_MODE_ERR;
+            }
+        }
     }
 
+SET_EBREAK_MODE_ERR:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    swd_write_core_register(temReg, s0);
     return 0;
+
+SET_EBREAK_MODE_SUCCESS:
+    temReg = 8 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_write_core_register(temReg, s0)) {
+        return 0;
+    } else {
+        return 1;
+    }
 }
+#endif /* #ifdef HISPARK_TRACE */
 
+#ifdef HISPARK_TRACE
+/* RISC-V */
+uint8_t swd_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type)
+{
+    uint32_t temReg;
+    volatile DEBUG_STATE state = {{0}};
+    // Call flash algorithm function on target and wait for result.
+    state.r[10]     = arg1;                   // R10: Argument 1
+    state.r[11]     = arg2;                   // R11: Argument 2
+    state.r[12]     = arg3;                   // R12: Argument 3
+    state.r[13]     = arg4;                   // R13: Argument 4
+    state.r[3]      = sysCallParam->static_base;    // SB: Static Base
+    state.r[2]      = sysCallParam->stack_pointer;  // SP: Stack Pointer
+    state.r[1]      = sysCallParam->breakpoint;     // LR: Exit Point
+    state.r[32]     = entry;                        // PC: Entry Point
+
+    if (!swd_write_debug_state((DEBUG_STATE *)&state)) {
+        return 0;
+    }
+    if (!swd_wait_until_halted()) {
+        return 0;
+    }
+    temReg = 10 + RISCV_DM_GPRS_BASE_ADDR;
+    if (!swd_read_core_register(temReg, (uint32_t *)&state.r[10])) {
+        return 0;
+    }
+
+    if ( return_type == FLASHALGO_RETURN_POINTER ) {
+        // Flash verify functions return pointer to byte following the buffer if successful.
+        if (state.r[10] != (arg1 + arg2)) {
+            return 0;
+        }
+    } else {
+        // Flash functions return 0 if successful.
+        if (state.r[10] != 0) {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+#else /* #ifdef HISPARK_TRACE */
+/* ARM */
 uint8_t swd_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type)
 {
     DEBUG_STATE state = {{0}, 0};
@@ -734,6 +1248,7 @@
 
     return 1;
 }
+#endif
 
 // SWD Reset
 static uint8_t swd_reset(void)
@@ -802,6 +1317,7 @@
 uint8_t swd_init_debug(void)
 {
     uint32_t tmp = 0;
+
     int i = 0;
     int timeout = 100;
     // init dap state with fake values
@@ -882,7 +1398,12 @@
             do_abort = 1;
             continue;
         }
-
+#ifdef HISPARK_TRACE
+        if (!swd_set_ebreak_mode(1)) {
+            do_abort = 1;
+            continue;
+        }
+#endif
         return 1;
 
     } while (--retries > 0);
@@ -1034,7 +1555,11 @@
 uint8_t swd_set_target_state_sw(target_state_t state)
 {
     uint32_t val;
+#ifdef HISPARK_TRACE
+
+#else
     int8_t ap_retries = 2;
+#endif
     /* Calling swd_init prior to enterring RUN state causes operations to fail. */
     if (state != RUN) {
         swd_init();
@@ -1050,10 +1575,13 @@
             osDelay(2);
             swd_set_target_reset(0);
             osDelay(2);
+#ifdef HISPARK_TRACE
 
+#else
             if (!swd_init_debug()) {
                 return 0;
             }
+#endif
 
             // Power down
             // Per ADIv6 spec. Clear first CSYSPWRUPREQ followed by CDBGPWRUPREQ
@@ -1087,6 +1615,16 @@
             break;
 
         case RESET_PROGRAM:
+#ifdef HISPARK_TRACE
+            if (!swd_init_debug()) {
+                return 0;
+            }
+            swd_exec_soft_reset();
+            if (!swd_init_debug()) {
+                return 0;
+            }
+            break;
+#else /* #ifdef HISPARK_TRACE */
             if (!swd_init_debug()) {
                 return 0;
             }
@@ -1138,7 +1676,7 @@
             }
 
             break;
-
+#endif /* #ifdef HISPARK_TRACE */
         case NO_DEBUG:
             if (!swd_write_word(DBG_HCSR, DBGKEY)) {
                 return 0;
@@ -1207,4 +1745,51 @@
 
     return 1;
 }
+
+#ifdef HISPARK_TRACE
+void swd_exec_soft_reset(void)
+{
+    uint32_t val;
+    if (!SysSoftResetFlagGet()) {
+        return;
+    }
+    swd_init_debug();
+    /* Set <sc_hrst_res>(0x10100200)  debug flag register */
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    swd_read_dp(DP_RDBUFF,&val);
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_TAR, 0x10100200, 0x1000000);
+    swd_write_ap(AP_DRW, 0xA5A5A5A5, 0x1000000);
+
+    /* Unlock <sc_cfg_lock>(0x10100044)  configuration lock register */
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    swd_read_dp(DP_RDBUFF,&val);
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_TAR, 0x10100044, 0x1000000);
+    swd_write_ap(AP_DRW, 0xEA510000, 0x1000000);
+
+    /* Set<PERI_CRG>  (0x1000001C)  to HOSC (0x1000001C = 0x8) -- bit1~0: 0-HOSC, 1-XTAL, 2-PLL */
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    swd_read_dp(DP_RDBUFF,&val);
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_TAR, 0x1000001C, 0x1000000);
+    swd_write_ap(AP_DRW, 0x00000008, 0x1000000);
+
+    /* Set <sc_sys_res>(0x10100004) system reset register  to reset system */
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_CSW, 0x0000002, 0x1000000);
+    swd_read_dp(DP_RDBUFF,&val);
+    swd_write_dp(DP_SELECT, 0x1000000);
+    swd_write_ap(AP_TAR, 0x10100004, 0x1000000);
+    swd_write_ap(AP_DRW, 0x00000001, 0x1000000);
+
+    /* Add some clocks to ensure the last write operations takes effect  with  jlink */
+    swd_read_dp(DP_RDBUFF,&val);
+     /* Wait until the reset is complete. */
+    osDelay(300);
+}
+#endif /* #ifdef HISPARK_TRACE */
 #endif
diff -uNr old/CA7/source/daplink/interface/swd_host.h new/CA7/source/daplink/interface/swd_host.h
--- old/CA7/source/daplink/interface/swd_host.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/swd_host.h	2023-06-09 15:38:35.689535300 +0800
@@ -36,24 +36,19 @@
 extern "C" {
 #endif
 
-typedef enum {
-    CONNECT_NORMAL,
-    CONNECT_UNDER_RESET,
-} SWD_CONNECT_TYPE;
-
-typedef enum {
-    FLASHALGO_RETURN_BOOL,
-    FLASHALGO_RETURN_POINTER
-} flash_algo_return_t;
-
 uint8_t swd_init(void);
 uint8_t swd_off(void);
 uint8_t swd_init_debug(void);
 uint8_t swd_clear_errors(void);
 uint8_t swd_read_dp(uint8_t adr, uint32_t *val);
 uint8_t swd_write_dp(uint8_t adr, uint32_t val);
+#if defined(HISPARK_TRACE)
+uint8_t swd_read_ap(uint32_t adr, uint32_t *val,uint32_t apsel);
+uint8_t swd_write_ap(uint32_t adr, uint32_t val,uint32_t apsel);
+#else
 uint8_t swd_read_ap(uint32_t adr, uint32_t *val);
 uint8_t swd_write_ap(uint32_t adr, uint32_t val);
+#endif
 uint8_t swd_read_word(uint32_t addr, uint32_t *val);
 uint8_t swd_write_word(uint32_t addr, uint32_t val);
 uint8_t swd_read_byte(uint32_t addr, uint8_t *val);
@@ -67,8 +62,11 @@
 uint8_t swd_set_target_state_sw(target_state_t state);
 uint8_t swd_transfer_retry(uint32_t req, uint32_t *data);
 void int2array(uint8_t *res, uint32_t data, uint8_t len);
-void swd_set_reset_connect(SWD_CONNECT_TYPE type);
+void swd_set_reset_connect(JTAG_SWD_CONNECT_TYPE type);
 void swd_set_soft_reset(uint32_t soft_reset_type);
+#if defined(HISPARK_TRACE)
+void swd_exec_soft_reset(void);
+#endif
 uint8_t JTAG2SWD(void);
 
 #ifdef __cplusplus
diff -uNr old/CA7/source/daplink/interface/target_flash.c new/CA7/source/daplink/interface/target_flash.c
--- old/CA7/source/daplink/interface/target_flash.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/interface/target_flash.c	2023-06-09 15:39:54.224644800 +0800
@@ -28,6 +28,8 @@
 #include "target_config.h"
 #include "intelhex.h"
 #include "swd_host.h"
+#include "jtag_host.h"
+#include "swd_jtag_config.h"
 #include "flash_intf.h"
 #include "util.h"
 #include "settings.h"
@@ -51,6 +53,9 @@
 static uint32_t target_flash_erase_sector_size(uint32_t addr);
 static uint8_t target_flash_busy(void);
 static error_t target_flash_set(uint32_t addr);
+#if defined(HISPARK_TRACE)
+static error_t target_flash_read(uint32_t addr, uint8_t *buf, uint32_t size);
+#endif
 
 static const flash_intf_t flash_intf = {
     target_flash_init,
@@ -62,6 +67,9 @@
     target_flash_erase_sector_size,
     target_flash_busy,
     target_flash_set,
+#if defined(HISPARK_TRACE)
+    target_flash_read,
+#endif
 };
 
 static state_t state = STATE_CLOSED;
@@ -79,6 +87,46 @@
 //saved flash start from flash algo
 static uint32_t flash_start = 0;
 
+#ifdef HISPARK_TRACE
+static uint8_t swd_jtag_read_memory(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint8_t debugPort;
+
+    debugPort = SwdJtagDebugPortGet();
+    if (debugPort == DAP_PORT_JTAG) { 
+        return jtag_read_memory(address, data, size);
+    } else {
+        return swd_read_memory(address, data, size);
+    }
+}
+
+static uint8_t swd_jtag_write_memory(uint32_t address, uint8_t *data, uint32_t size)
+{
+    uint8_t debugPort;
+
+    debugPort = SwdJtagDebugPortGet();
+    if (debugPort == DAP_PORT_JTAG) {
+        return jtag_write_memory(address, data, size);
+    } else {
+        return swd_write_memory(address, data, size);
+    }
+}
+
+static uint8_t swd_jtag_flash_syscall_exec(const program_syscall_t *sysCallParam,
+                                      uint32_t entry, uint32_t arg1, uint32_t arg2,
+                                      uint32_t arg3, uint32_t arg4, flash_algo_return_t return_type)
+{
+    uint8_t debugPort;
+
+    debugPort = SwdJtagDebugPortGet();
+    if (debugPort == DAP_PORT_JTAG) {
+        return jtag_flash_syscall_exec(sysCallParam, entry, arg1, arg2, arg3, arg4, return_type);
+    } else {
+        return swd_flash_syscall_exec(sysCallParam, entry, arg1, arg2, arg3, arg4, return_type);
+    }
+}
+#endif /* HISPARK_TRACE */
+
 static program_target_t * get_flash_algo(uint32_t addr)
 {
     region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
@@ -112,14 +160,22 @@
         // Finish the currently active function.
         if (FLASH_FUNC_NOP != last_flash_func &&
             ((flash->algo_flags & kAlgoSingleInitType) == 0 || FLASH_FUNC_NOP == func ) &&
+#ifdef HISPARK_TRACE
+            0 == swd_jtag_flash_syscall_exec(&flash->sys_call_s, flash->uninit, last_flash_func, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#else
             0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->uninit, last_flash_func, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
             return ERROR_UNINIT;
         }
 
         // Start a new function.
         if (FLASH_FUNC_NOP != func &&
             ((flash->algo_flags & kAlgoSingleInitType) == 0 || FLASH_FUNC_NOP == last_flash_func ) &&
+#ifdef HISPARK_TRACE
+            0 == swd_jtag_flash_syscall_exec(&flash->sys_call_s, flash->init, flash_start, 0, func, 0, FLASHALGO_RETURN_BOOL)) {
+#else
             0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->init, flash_start, 0, func, 0, FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
             return ERROR_INIT;
         }
 
@@ -142,7 +198,11 @@
             return status;
         }
         // Download flash programming algorithm to target
+#ifdef HISPARK_TRACE
+        if (0 == swd_jtag_write_memory(new_flash_algo->algo_start, (uint8_t *)new_flash_algo->algo_blob, new_flash_algo->algo_size)) {
+#else
         if (0 == swd_write_memory(new_flash_algo->algo_start, (uint8_t *)new_flash_algo->algo_blob, new_flash_algo->algo_size)) {
+#endif /* #ifdef HISPARK_TRACE */
             return ERROR_ALGO_DL;
         }
 
@@ -199,7 +259,11 @@
         target_set_state(POST_FLASH_RESET);
 
         state = STATE_CLOSED;
-        swd_off();
+        if (SwdJtagDebugPortGet() == DAP_PORT_JTAG) {
+            jtag_off();
+        } else {
+            swd_off();
+        }
         return ERROR_SUCCESS;
     } else {
         return ERROR_FAILURE;
@@ -233,11 +297,24 @@
             uint32_t write_size = MIN(size, flash->program_buffer_size);
 
             // Write page to buffer
+#ifdef HISPARK_TRACE
+            if (!swd_jtag_write_memory(flash->program_buffer, (uint8_t *)buf, write_size)) {
+#else
             if (!swd_write_memory(flash->program_buffer, (uint8_t *)buf, write_size)) {
+#endif /* #ifdef HISPARK_TRACE */
                 return ERROR_ALGO_DATA_SEQ;
             }
 
             // Run flash programming
+#ifdef HISPARK_TRACE
+            if (!swd_jtag_flash_syscall_exec(&flash->sys_call_s,
+                                        flash->program_page,
+                                        addr,
+                                        write_size,
+                                        flash->program_buffer,
+                                        0,
+                                        FLASHALGO_RETURN_BOOL)) {
+#else
             if (!swd_flash_syscall_exec(&flash->sys_call_s,
                                         flash->program_page,
                                         addr,
@@ -245,6 +322,7 @@
                                         flash->program_buffer,
                                         0,
                                         FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
                 return ERROR_WRITE;
             }
 
@@ -261,6 +339,15 @@
                     } else {
                         return_type = FLASHALGO_RETURN_BOOL;
                     }
+#ifdef HISPARK_TRACE
+                    if (!swd_jtag_flash_syscall_exec(&flash->sys_call_s,
+                                        flash->verify,
+                                        addr,
+                                        write_size,
+                                        flash->program_buffer,
+                                        0,
+                                        return_type)) {
+#else
                     if (!swd_flash_syscall_exec(&flash->sys_call_s,
                                         flash->verify,
                                         addr,
@@ -268,13 +355,18 @@
                                         flash->program_buffer,
                                         0,
                                         return_type)) {
+#endif /* #ifdef HISPARK_TRACE */
                         return ERROR_WRITE_VERIFY;
                     }
                 } else {
                     while (write_size > 0) {
                         uint8_t rb_buf[16];
                         uint32_t verify_size = MIN(write_size, sizeof(rb_buf));
+#ifdef HISPARK_TRACE
+                        if (!swd_jtag_read_memory(addr, rb_buf, verify_size)) {
+#else
                         if (!swd_read_memory(addr, rb_buf, verify_size)) {
+#endif /* #ifdef HISPARK_TRACE */
                             return ERROR_ALGO_DATA_SEQ;
                         }
                         if (memcmp(buf, rb_buf, verify_size) != 0) {
@@ -322,7 +414,11 @@
             return status;
         }
 
+#ifdef HISPARK_TRACE
+        if (0 == swd_jtag_flash_syscall_exec(&flash->sys_call_s, flash->erase_sector, addr, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#else
         if (0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->erase_sector, addr, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
             return ERROR_ERASE_SECTOR;
         }
 
@@ -352,7 +448,11 @@
             if (status != ERROR_SUCCESS) {
                 return status;
             }
+#ifdef HISPARK_TRACE
+            if (0 == swd_jtag_flash_syscall_exec(&current_flash_algo->sys_call_s, current_flash_algo->erase_chip, 0, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#else
             if (0 == swd_flash_syscall_exec(&current_flash_algo->sys_call_s, current_flash_algo->erase_chip, 0, 0, 0, 0, FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
                 return ERROR_ERASE_ALL;
             }
         }
@@ -399,7 +499,61 @@
         return 0;
     }
 }
+#if defined(HISPARK_TRACE)
+static error_t target_flash_read(uint32_t addr, uint8_t *buf, uint32_t size)
+{
+    if (g_board_info.target_cfg) {
+        error_t status = ERROR_SUCCESS;
+        program_target_t * flash = current_flash_algo;
+
+        if (!flash) {
+            return ERROR_INTERNAL;
+        }
+
+        status = flash_func_start(FLASH_FUNC_READ);
+        if (status != ERROR_SUCCESS) {
+            return status;
+        }
+
+        while (size > 0) {
+            uint32_t read_size = MIN(size, flash->program_buffer_size);
 
+            // Read page to buffer
+#ifdef HISPARK_TRACE
+            if (!swd_jtag_flash_syscall_exec(&flash->sys_call_s,
+                                        flash->read,
+                                        addr,
+                                        read_size,
+                                        flash->program_buffer,
+                                        0,
+                                        FLASHALGO_RETURN_BOOL)) {
+#else
+            if (!swd_flash_syscall_exec(&flash->sys_call_s,
+                                        flash->read,
+                                        addr,
+                                        read_size,
+                                        flash->program_buffer,
+                                        0,
+                                        FLASHALGO_RETURN_BOOL)) {
+#endif /* #ifdef HISPARK_TRACE */
+                        return ERROR_READ;
+            }
+#ifdef HISPARK_TRACE
+            if (!swd_jtag_read_memory(flash->program_buffer, buf, read_size)) {
+#else
+            if (!swd_read_memory(flash->program_buffer, buf, read_size)) {
+#endif /* #ifdef HISPARK_TRACE */
+                return ERROR_READ;
+            }
+            addr += read_size;
+            buf += read_size;
+            size -= read_size;
+        }
+         return ERROR_SUCCESS;
+    }
+    return ERROR_FAILURE;
+}
+#endif
 static uint8_t target_flash_busy(void){
     return (state == STATE_OPEN);
 }
diff -uNr old/CA7/source/daplink/settings/settings_rom.c new/CA7/source/daplink/settings/settings_rom.c
--- old/CA7/source/daplink/settings/settings_rom.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/settings/settings_rom.c	2023-05-25 15:09:49.000000000 +0800
@@ -18,7 +18,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+#ifndef HISPARK_TRACE
 #include <string.h>
 
 #include "settings.h"
@@ -196,3 +196,4 @@
 {
     return config_rom_copy.detect_incompatible_target;
 }
+#endif
diff -uNr old/CA7/source/daplink/usb2uart/usbd_user_cdc_acm.c new/CA7/source/daplink/usb2uart/usbd_user_cdc_acm.c
--- old/CA7/source/daplink/usb2uart/usbd_user_cdc_acm.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/usb2uart/usbd_user_cdc_acm.c	2023-05-25 15:39:01.000000000 +0800
@@ -149,11 +149,17 @@
  */
 int32_t USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp)
 {
-    uart_set_control_line_state(ctrl_bmp);
-    return (1);
+#ifndef HISPARK_TRACE
+	uart_set_control_line_state(ctrl_bmp);
+#endif
+	return (1);
 }
 
+#ifdef HISPARK_TRACE
+void cdc_process_event(void)
+#else
 void cdc_process_event()
+#endif
 {
     int32_t len_data = 0;
     uint8_t data[64];
diff -uNr old/CA7/source/daplink/util.c new/CA7/source/daplink/util.c
--- old/CA7/source/daplink/util.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/util.c	2023-05-25 15:09:49.000000000 +0800
@@ -28,6 +28,76 @@
 //remove dependency from vfs_manager
 __WEAK void vfs_mngr_fs_remount(void) {}
 
+#if defined(HISPARK_TRACE)
+void int2str(char *str, int num)
+{
+    char buf[12] = {0};
+    int i = 0;
+    int len;
+    if (num == 0) {
+        *str = '0';
+        return;
+    }
+    if (num < 0) {
+        *str++ = '-';
+        num = -num;
+    }
+    while (num) {
+        buf[i++] = '0' + num % 10;
+        num /= 10;
+    }
+
+    len = i;
+    for (i = len - 1; i >= 0; --i) {
+        *str++ = buf[i];
+    }
+    *str = 0;
+}
+
+uint32_t util_write_uint64_with_delimiter(char *str, uint64_t value)
+{
+    uint64_t temp_val;
+    uint32_t digits;
+    uint32_t i;
+    uint32_t delimiter = 0;
+    uint32_t len;
+    char buf[30] = {0};
+    char *p = buf;
+
+    // Count the number of digits
+    digits = 0;
+    temp_val = value;
+
+    while (temp_val > 0) {
+        temp_val /= 10;
+        digits += 1;
+    }
+
+    if (digits <= 0) {
+        digits = 1;
+    }
+
+    // Write the number
+    for (i = 0; i < digits; i++) {
+        if (delimiter) {
+            *p++ = ',';
+            delimiter = 0;
+        }
+        *p++ = '0' + (value % 10);
+        if ((i % 4) == 3) {
+            delimiter = 1;
+        }
+        value /= 10;
+    }
+    len = strlen(buf);
+    for (i = 0; i < len; ++i) {
+        str[i] = buf[len - i - 1];
+    }
+
+    return digits;
+}
+#endif
+
 uint32_t util_write_hex8(char *str, uint8_t value)
 {
     static const char nybble_chars[] = "0123456789abcdef";
diff -uNr old/CA7/source/daplink/util.h new/CA7/source/daplink/util.h
--- old/CA7/source/daplink/util.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/daplink/util.h	2023-05-25 15:09:49.000000000 +0800
@@ -63,6 +63,7 @@
 uint32_t util_write_hex32(char *str, uint32_t value);
 uint32_t util_write_uint32(char *str, uint32_t value);
 uint32_t util_write_uint32(char *str, uint32_t value);
+uint32_t util_write_uint64_with_delimiter(char *str, uint64_t value);
 uint32_t util_write_uint32_zp(char *str, uint32_t value, uint16_t total_size);
 uint32_t util_write_string(char *str, const char *data);
 
@@ -71,6 +72,10 @@
 uint32_t util_write_string_in_region(uint8_t *buf, uint32_t size, uint32_t start,
     uint32_t pos, const char *input);
 
+#if defined(HISPARK_TRACE)
+void int2str(char *str, int num);
+#endif
+
 __STATIC_INLINE uint32_t util_div_round_up(uint32_t dividen, uint32_t divisor)
 {
     return (dividen + divisor - 1) / divisor;
diff -uNr old/CA7/source/family/vendorHM/306x/flash_blob.c new/CA7/source/family/vendorHM/306x/flash_blob.c
--- old/CA7/source/family/vendorHM/306x/flash_blob.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/family/vendorHM/306x/flash_blob.c	2023-06-09 15:40:27.424082900 +0800
@@ -1,5 +1,5 @@
 /* Flash OS Routines (Automagically Generated)
- * Copyright (c) 2009-2019 ARM Limited
+ * Copyright (c) 2009-2015 ARM Limited
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,52 +13,86 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#include "flash_blob.h"
 
-static const uint32_t STM32F103RB_flash_prog_blob[] = {
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4603b510, 0x4c442000, 0x48446020, 0x48446060, 0x46206060, 0xf01069c0, 0xd1080f04, 0x5055f245,
-    0x60204c40, 0x60602006, 0x70fff640, 0x200060a0, 0x4601bd10, 0x69004838, 0x0080f040, 0x61104a36,
-    0x47702000, 0x69004834, 0x0004f040, 0x61084932, 0x69004608, 0x0040f040, 0xe0036108, 0x20aaf64a,
-    0x60084930, 0x68c0482c, 0x0f01f010, 0x482ad1f6, 0xf0206900, 0x49280004, 0x20006108, 0x46014770,
-    0x69004825, 0x0002f040, 0x61104a23, 0x61414610, 0xf0406900, 0x61100040, 0xf64ae003, 0x4a2120aa,
-    0x481d6010, 0xf01068c0, 0xd1f60f01, 0x6900481a, 0x0002f020, 0x61104a18, 0x47702000, 0x4603b510,
-    0xf0201c48, 0xe0220101, 0x69004813, 0x0001f040, 0x61204c11, 0x80188810, 0x480fbf00, 0xf01068c0,
-    0xd1fa0f01, 0x6900480c, 0x0001f020, 0x61204c0a, 0x68c04620, 0x0f14f010, 0x4620d006, 0xf04068c0,
-    0x60e00014, 0xbd102001, 0x1c921c9b, 0x29001e89, 0x2000d1da, 0x0000e7f7, 0x40022000, 0x45670123,
-    0xcdef89ab, 0x40003000, 0x00000000
+
+static uint32_t h306x_flash_prog_blob[] = {
+   0x00100073, 
+    0xd6227179, 0x2e231800, 0x2c23fca4, 0x2a23fcb4, 0x2623fcc4, 0x2783fe04, 0x8b8dfd44, 0x2783cb81,
+    0x8389fd44, 0x22230785, 0xa031fef4, 0xfd442783, 0x22238389, 0x07b7fef4, 0x20231471, 0x2783fef4,
+    0x2623fdc4, 0x2703fef4, 0x07b7fd84, 0x17fd0040, 0x00f776b3, 0xfe042783, 0x00400737, 0x8f75177d,
+    0x43d0070a, 0xff0006b7, 0x8ef1068d, 0xc3d88f55, 0xfe042423, 0x2783a015, 0x4398fec4, 0xfe042783,
+    0x40e7a023, 0xfec42783, 0x26230791, 0x2783fef4, 0x0785fe84, 0xfef42423, 0xfe842703, 0xfd442783,
+    0xfcf76be3, 0xfe442783, 0x03f7f793, 0x0ff7f713, 0xfe042783, 0x03f77713, 0x43900752, 0xfc1006b7,
+    0x8ef116fd, 0xc3988f55, 0xfe042783, 0x77134398, 0x67138ff7, 0xc3982007, 0xfe042783, 0x67134398,
+    0xc3980017, 0x27830001, 0x439cfe04, 0xf7938b85, 0xfbf50ff7, 0x54320001, 0x80826145, 0xd6227179,
+    0x2e231800, 0x2c23fca4, 0x2a23fcb4, 0x07b7fcc4, 0x26231471, 0x2783fef4, 0xc737fec4, 0x0713fedc,
+    0xa023a987, 0x278320e7, 0xa703fec4, 0x9b750807, 0x08e7a023, 0xfec42783, 0x0807a703, 0xa0239b79,
+    0x478108e7, 0x5432853e, 0x80826145, 0xce221101, 0x26231000, 0x4781fea4, 0x4472853e, 0x80826105,
+    0xd6227179, 0x2e231800, 0x2c23fca4, 0x87b2fcb4, 0xfcf40ba3, 0xfdc42783, 0xfef42623, 0xfec42783,
+    0x00178713, 0xfee42623, 0x0007c783, 0x0ff7f793, 0xfd744703, 0x00f70463, 0xa8114785, 0xfd842783,
+    0x2c2317fd, 0x2783fcf4, 0xfbe9fd84, 0x853e4781, 0x61455432, 0x11018082, 0x1000ce22, 0x147107b7,
+    0xfef42623, 0xfec42783, 0x073743d4, 0x070dff00, 0xc3d88f75, 0xfec42783, 0x77134398, 0x67138ff7,
+    0xc3986007, 0xfec42783, 0x67134398, 0xc3980017, 0x27830001, 0x439cfec4, 0xf7938b85, 0xfbf50ff7,
+    0x853e4781, 0x61054472, 0x71798082, 0x1800d622, 0xfca42e23, 0xfe042623, 0x147107b7, 0xfef42423,
+    0xfdc42703, 0x030007b7, 0x00f76e63, 0xfdc42703, 0xfd0007b7, 0x262397ba, 0x2783fef4, 0x8389fec4,
+    0xfef42623, 0xfec42703, 0x004007b7, 0x76b317fd, 0x278300f7, 0x0737fe84, 0x177d0040, 0x070a8f75,
+    0x06b743d0, 0x068dff00, 0x8f558ef1, 0x2783c3d8, 0x4398fe84, 0x8ff77713, 0x40076713, 0x2783c398,
+    0x4398fe84, 0x00176713, 0x0001c398, 0xfe842783, 0x8b85439c, 0x0ff7f793, 0x4781fbf5, 0x5432853e,
+    0x80826145, 0xd6067179, 0x1800d422, 0xfca42e23, 0xfcb42c23, 0xfcc42a23, 0xfe042423, 0xfd442783,
+    0xfef42023, 0xfd842783, 0x22238389, 0x2783fef4, 0x839dfe44, 0xfef42623, 0xfdc42703, 0x030007b7,
+    0x00f76e63, 0xfdc42703, 0xfd0007b7, 0x242397ba, 0x2783fef4, 0x8389fe84, 0xfef42423, 0xfe042783,
+    0x08000613, 0xfe842583, 0x39dd853e, 0xfe042783, 0x20078793, 0xfef42023, 0xfe842783, 0x08078793,
+    0xfef42423, 0xfec42783, 0x262317fd, 0x2783fef4, 0xf7e9fec4, 0xfe442783, 0x07f7f793, 0x2703cf81,
+    0x2783fe04, 0xf793fe44, 0x863e07f7, 0xfe842583, 0x317d853a, 0x853e4781, 0x542250b2, 0x80826145,
+    0xce221101, 0x26231000, 0x2423fea4, 0x2223feb4, 0x4781fec4, 0x4472853e, 0x80826105, 0xd6227179,
+    0x2e231800, 0x2c23fca4, 0x2a23fcb4, 0x2623fcc4, 0x2783fe04, 0x2423fd84, 0x2783fef4, 0xe399fd44,
+    0xa83d4785, 0xfdc42783, 0xfef42623, 0x2783a035, 0x17fdfe84, 0xfef42423, 0xfec42703, 0x00170793,
+    0xfef42623, 0xfd442783, 0x00178693, 0xfcd42a23, 0x00074703, 0x00e78023, 0xfe842783, 0x4781fbe9,
+    0x5432853e, 0x80826145, 0x00000000, 0x00000000
 };
 
+// Start address of flash
+static const uint32_t flash_start = 0x03000000;
+// Size of flash
+static const uint32_t flash_size = 0x00028000;
+
 /**
-* List of start and size for each size of flash sector
+* List of start and size for each size of flash sector - even indexes are start, odd are size
 * The size will apply to all sectors between the listed address and the next address
 * in the list.
 * The last pair in the list will have sectors starting at that address and ending
-* at address start + size.
+* at address flash_start + flash_size.
 */
-static const sector_info_t sectors_info[] = {
-    {0x08000000, 0x400},
+static uint32_t sectors_info[] = {
+    0x03000000, 0x00002000,
 };
 
 static const program_target_t flash = {
-    0x20000021, // Init
-    0x20000053, // UnInit
-    0x20000065, // EraseChip
-    0x2000009f, // EraseSector
-    0x200000dd, // ProgramPage
-    0x0,        // Verify
+    0x02000100, // Init
+    0x02000150, // UnInit
+    0x020001ba, // EraseChip
+    0x0200020e, // EraseSector
+    0x020002a8, // ProgramPage
+    0x02000364, // Verify
+    0x02000380, // Read
 
     // BKPT : start of blob + 1
     // RSB  : blob start + header + rw data offset
     // RSP  : stack pointer
+    // state.r[1]      = sysCallParam->breakpoint;     // LR: Exit Point
+    //state.r[3]      = sysCallParam->static_base;    // SB: Static Base
+    //state.r[2]      = sysCallParam->stack_pointer;  // SP: Stack Pointer
+   
     {
-        0x20000001,
-        0x20000148,
-        0x20000800
+        0x02000001,
+        0x020003f4,
+        0x02000800
     },
 
-    0x20000000 + 0x00000A00,  // mem buffer location
-    0x20000000,               // location to write prog_blob in target RAM
-    sizeof(STM32F103RB_flash_prog_blob),   // prog_blob size
-    STM32F103RB_flash_prog_blob,           // address of prog_blob
-    0x00000400       // ram_to_flash_bytes_to_be_written
-};
+    0x02000000 + 0x00000A00,  // mem buffer location
+    0x02000000,               // location to write prog_blob in target RAM
+    sizeof(h306x_flash_prog_blob),   // prog_blob size
+    h306x_flash_prog_blob,           // address of prog_blob
+    0x00000200       // ram_to_flash_bytes_to_be_written
+};
\ No newline at end of file
diff -uNr old/CA7/source/family/vendorHM/306x/target.c new/CA7/source/family/vendorHM/306x/target.c
--- old/CA7/source/family/vendorHM/306x/target.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/family/vendorHM/306x/target.c	2023-06-09 15:40:36.953182300 +0800
@@ -1,6 +1,6 @@
 /**
  * @file    target.c
- * @brief   Target information for the STM32F103RB
+ * @brief   Target information for the 306x
  *
  * DAPLink Interface Firmware
  * Copyright (c) 2017-2019, ARM Limited, All Rights Reserved
@@ -20,21 +20,47 @@
  */
 
 #include "target_config.h"
+#include "target_family.h"
 
 // The file flash_blob.c must only be included in target.c
 #include "flash_blob.c"
 
 // target information
 target_cfg_t target_device = {
-    .version                        = kTargetConfigVersion,
-    .sectors_info                   = sectors_info,
+    .sectors_info                   = (sector_info_t *)sectors_info,
     .sector_info_length             = (sizeof(sectors_info))/(sizeof(sector_info_t)),
-    .flash_regions[0].start         = 0x08000000,
-    .flash_regions[0].end           = 0x08020000,
+    .flash_regions[0].start         = 0x03000000,
+    .flash_regions[0].end           = 0x03028000,
     .flash_regions[0].flags         = kRegionIsDefault,
     .flash_regions[0].flash_algo    = (program_target_t *) &flash,
     .ram_regions[0].start           = 0x20000000,
-    .ram_regions[0].end             = 0x20005000,
-    .target_vendor                  = "STMicroelectronics",
-    .target_part_number             = "STM32F103RB",
+    .ram_regions[0].end             = 0x20004000,
 };
+
+#define H306x_BIN_HEAD1        0xBD
+#define H306x_BIN_HEAD2        0x95
+#define H306x_BIN_HEAD3        0x7E
+#define H306x_BIN_HEAD4        0xA3
+uint8_t H306xBinParse(const uint8_t *buf)
+{
+    uint8_t temp[] = {
+        H306x_BIN_HEAD1,
+        H306x_BIN_HEAD2,
+        H306x_BIN_HEAD3,
+        H306x_BIN_HEAD4
+    };
+    for (int i = 0; i < 4; i++) {
+        if (temp[i] != buf[i]) {
+            return 0;
+        }
+    }
+    return 1;
+}
+const target_family_descriptor_t g_target_family_306x = {
+    .validate_bin_nvic = &H306xBinParse,
+    .default_reset_type = kSoftwareReset,
+    //.apsel = 0x1000000,
+    .apsel = 0x0000000,  
+};
+
+const target_family_descriptor_t *g_target_family = &g_target_family_306x;
diff -uNr old/CA7/source/hic_hal/device.h new/CA7/source/hic_hal/device.h
--- old/CA7/source/hic_hal/device.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/device.h	2023-05-25 15:09:49.000000000 +0800
@@ -42,6 +42,8 @@
 #include "stm32f1xx.h"
 #elif defined (INTERFACE_M48SSIDAE)
 #include "M480.h"
+#elif defined (INTERFACE_STM32MP153)
+#include "stm32mp1xx.h"
 #elif defined (INTERFACE_NRF52820)
 #include "nrf52820.h"
 #else
diff -uNr old/CA7/source/hic_hal/flash_blob.h new/CA7/source/hic_hal/flash_blob.h
--- old/CA7/source/hic_hal/flash_blob.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/flash_blob.h	2023-05-25 15:09:49.000000000 +0800
@@ -44,6 +44,22 @@
 } program_syscall_t;
 
 typedef struct __attribute__((__packed__)) {
+#ifdef HISPARK_TRACE
+    uint32_t  init;
+    uint32_t  uninit;
+    uint32_t  erase_chip;
+    uint32_t  erase_sector;
+    uint32_t  program_page;
+    uint32_t  verify;
+    uint32_t  read;
+    program_syscall_t sys_call_s;
+    uint32_t  program_buffer;
+    uint32_t  algo_start;
+    uint32_t  algo_size;
+    uint32_t *algo_blob;
+    uint32_t  program_buffer_size;
+    uint32_t  algo_flags;         /*!< Combination of kAlgoVerifyReturnsAddress, kAlgoSingleInitType and kAlgoSkipChipErase*/
+#else /* #ifdef HISPARK_TRACE */
     const uint32_t  init;
     const uint32_t  uninit;
     const uint32_t  erase_chip;
@@ -57,11 +73,17 @@
     const uint32_t *algo_blob;
     const uint32_t  program_buffer_size;
     const uint32_t  algo_flags;         /*!< Combination of kAlgoVerifyReturnsAddress, kAlgoSingleInitType and kAlgoSkipChipErase*/
+#endif /* #ifdef HISPARK_TRACE */
 } program_target_t;
 
 typedef struct __attribute__((__packed__)) {
+#ifdef HISPARK_TRACE
+    uint32_t start;
+    uint32_t size;
+#else
     const uint32_t start;
     const uint32_t size;
+#endif
 } sector_info_t;
 
 #ifdef __cplusplus
diff -uNr old/CA7/source/hic_hal/FlashPrg.h new/CA7/source/hic_hal/FlashPrg.h
--- old/CA7/source/hic_hal/FlashPrg.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/FlashPrg.h	2023-05-25 15:09:49.000000000 +0800
@@ -77,6 +77,8 @@
  */
 uint32_t Verify(uint32_t adr, uint32_t sz, uint32_t *buf);
 
+uint32_t FlashRead(uint32_t adr, uint32_t sz, uint8_t *buf);
+
 #ifdef __cplusplus
 }
 #endif
diff -uNr old/CA7/source/hic_hal/gpio.h new/CA7/source/hic_hal/gpio.h
--- old/CA7/source/hic_hal/gpio.h	2022-02-05 13:12:28.000000000 +0800
+++ new/CA7/source/hic_hal/gpio.h	2023-05-25 15:36:28.000000000 +0800
@@ -51,6 +51,10 @@
     return gpio_get_reset_btn_no_fwrd() || gpio_get_reset_btn_fwrd();
 }
 
+#ifdef HISPARK_TRACE
+void gpio_set_daplink_run(gpio_led_state_t state);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/stm32mp1xx_hal_msp.c new/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/stm32mp1xx_hal_msp.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/stm32mp1xx_hal_msp.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/stm32mp1xx_hal_msp.c	2023-05-25 15:09:49.000000000 +0800
@@ -18,7 +18,14 @@
   ******************************************************************************
   */
 /* Includes ------------------------------------------------------------------*/
+#ifdef HISPARK_TRACE
+#include "stm32mp1xx.h"
+
+#define PERIPH_LOCK(x)
+#define PERIPH_UNLOCK(x)
+#else
 #include "main.h"
+#endif
 
 /* USER CODE BEGIN 0 */
 
@@ -48,8 +55,14 @@
   /* USER CODE END QUADSPI_MspInit 0 */
     /* Peripheral clock enable */
     __HAL_RCC_QSPI_CLK_ENABLE();
-  
-    /**QUADSPI GPIO Configuration    
+#ifdef HISPARK_TRACE
+    __HAL_RCC_GPIOE_CLK_ENABLE();
+    __HAL_RCC_GPIOB_CLK_ENABLE();
+    __HAL_RCC_GPIOC_CLK_ENABLE();
+    __HAL_RCC_GPIOF_CLK_ENABLE();
+#endif
+
+    /**QUADSPI GPIO Configuration
     PC0     ------> QUADSPI_BK2_NCS
     PF10     ------> QUADSPI_CLK
     PB6     ------> QUADSPI_BK1_NCS
@@ -91,9 +104,11 @@
     HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
     PERIPH_UNLOCK(GPIOF);
 
+#ifndef HISPARK_TRACE
     /* QUADSPI interrupt Init */
     HAL_NVIC_SetPriority(QUADSPI_IRQn, DEFAULT_IRQ_PRIO, 0);
     HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
+#endif
   /* USER CODE BEGIN QUADSPI_MspInit 1 */
     /* Reset the QuadSPI memory interface */
     __HAL_RCC_QSPI_FORCE_RESET();
@@ -113,12 +128,12 @@
     /* Reset the QuadSPI memory interface */
     __HAL_RCC_QSPI_FORCE_RESET();
     __HAL_RCC_QSPI_RELEASE_RESET();
-    
+
   /* USER CODE END QUADSPI_MspDeInit 0 */
     /* Peripheral clock disable */
     __HAL_RCC_QSPI_CLK_DISABLE();
-  
-    /**QUADSPI GPIO Configuration    
+
+    /**QUADSPI GPIO Configuration
     PC0     ------> QUADSPI_BK2_NCS
     PF10     ------> QUADSPI_CLK
     PB6     ------> QUADSPI_BK1_NCS
@@ -129,7 +144,7 @@
     PF6     ------> QUADSPI_BK1_IO3
     PH2     ------> QUADSPI_BK2_IO0
     PF8     ------> QUADSPI_BK1_IO0
-    PF9     ------> QUADSPI_BK1_IO1 
+    PF9     ------> QUADSPI_BK1_IO1
     */
 
     PERIPH_LOCK(GPIOF);
@@ -141,9 +156,10 @@
     HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10);
     PERIPH_UNLOCK(GPIOB);
 
-
+#ifndef HISPARK_TRACE
     /* QUADSPI interrupt DeInit */
     HAL_NVIC_DisableIRQ(QUADSPI_IRQn);
+#endif
   /* USER CODE BEGIN QUADSPI_MspDeInit 1 */
 
   /* USER CODE END QUADSPI_MspDeInit 1 */
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/system_stm32mp1xx.c new/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/system_stm32mp1xx.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/system_stm32mp1xx.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/cmsis/system_stm32mp1xx.c	2023-05-25 15:09:49.000000000 +0800
@@ -14,7 +14,7 @@
   *                                  be used by the user application to setup
   *                                  the SysTick timer or configure other
   *                                  parameters.
-  *                                     
+  *
   *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
   *                                 be called whenever the core clock is changed
   *                                 during program execution.
@@ -76,7 +76,7 @@
 /*!< Uncomment the following line if you need to relocate your vector Table in
      Internal SRAM. */
 /* #define VECT_TAB_SRAM */
-#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
+#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field.
                                    This value must be a multiple of 0x400. */
 /******************************************************************************/
 
@@ -103,7 +103,11 @@
                then there is no need to call the first functions listed above,
                since SystemCoreClock variable is updated automatically.
   */
+#ifdef HISPARK_TRACE
+  unsigned int SystemCoreClock = HSI_VALUE;
+#else
   uint32_t SystemCoreClock = HSI_VALUE;
+#endif
 /**
   * @}
   */
@@ -112,8 +116,8 @@
   * @{
   */
 
-#if defined (DATA_IN_ExtSRAM) 
-  static void SystemInit_ExtMemCtl(void); 
+#if defined (DATA_IN_ExtSRAM)
+  static void SystemInit_ExtMemCtl(void);
 #endif /* DATA_IN_ExtSRAM */
 
 /**
@@ -126,7 +130,7 @@
 
   /**
   * @brief  Setup the microcontroller system
-  *         Initialize the FPU setting, vector table location and External memory 
+  *         Initialize the FPU setting, vector table location and External memory
   *         configuration.
   * @param  None
   * @retval None
@@ -151,8 +155,10 @@
   CLEAR_REG(EXTI_C2->EMR2);
   CLEAR_REG(EXTI_C2->EMR3);
 #else
+#ifndef HISPARK_TRACE
 #error Please #define CORE_CM4
-#endif	                         
+#endif
+#endif
 }
 
 /**
@@ -166,7 +172,7 @@
   *         based on this variable will be incorrect.
   *
   * @note   - The system frequency computed by this function is not the real
-  *           frequency in the chip. It is calculated based on the predefined 
+  *           frequency in the chip. It is calculated based on the predefined
   *           constant and the selected clock source:
   *
   *           - If SYSCLK source is HSI, SystemCoreClock will contain the
@@ -272,10 +278,10 @@
   */
 void SystemInit_ExtMemCtl(void)
 {
-  
+
 }
 #endif /* DATA_IN_ExtSRAM */
-  
+
 /**
   * @}
   */
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/DAP_config.h new/CA7/source/hic_hal/stm32/stm32mp1xx/DAP_config.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/DAP_config.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/DAP_config.h	2023-12-27 14:14:40.636039904 +0800
@@ -57,11 +57,11 @@
 
 /// Indicate that JTAG communication mode is available at the Debug Port.
 /// This information is returned by the command \ref DAP_Info as part of <b>Capabilities</b>.
-#define DAP_JTAG                0               ///< JTAG Mode: 1 = available, 0 = not available.
+#define DAP_JTAG                1               ///< JTAG Mode: 1 = available, 0 = not available.
 
 /// Configure maximum number of JTAG devices on the scan chain connected to the Debug Access Port.
 /// This setting impacts the RAM requirements of the Debug Unit. Valid range is 1 .. 255.
-#define DAP_JTAG_DEV_CNT        0               ///< Maximum number of JTAG devices on scan chain
+#define DAP_JTAG_DEV_CNT        4               ///< Maximum number of JTAG devices on scan chain
 
 /// Default communication mode on the Debug Access Port.
 /// Used for the command \ref DAP_Connect when Port Default mode is selected.
@@ -83,27 +83,24 @@
 #endif
 
 /// Maximum Package Buffers for Command and Response data.
-/// This configuration settings is used to optimize the communication performance with the
+/// This configuration settings is used to optimized the communication performance with the
 /// debugger and depends on the USB peripheral. For devices with limited RAM or USB buffer the
 /// setting can be reduced (valid range is 1 .. 255). Change setting to 4 for High-Speed USB.
-#define DAP_PACKET_COUNT       4              ///< Buffers: 64 = Full-Speed, 4 = High-Speed.
+#define DAP_PACKET_COUNT       8              ///< Buffers: 64 = Full-Speed, 4 = High-Speed.
 
 /// Indicate that UART Serial Wire Output (SWO) trace is available.
 /// This information is returned by the command \ref DAP_Info as part of <b>Capabilities</b>.
 #define SWO_UART                0               ///< SWO UART:  1 = available, 0 = not available
 
-/// USART Driver instance number for the UART SWO.
-#define SWO_UART_DRIVER         0               ///< USART Driver instance number (Driver_USART#).
-
 /// Maximum SWO UART Baudrate
 #define SWO_UART_MAX_BAUDRATE   10000000U       ///< SWO UART Maximum Baudrate in Hz
 
 /// Indicate that Manchester Serial Wire Output (SWO) trace is available.
 /// This information is returned by the command \ref DAP_Info as part of <b>Capabilities</b>.
-#define SWO_MANCHESTER          0               ///< SWO Manchester:  1 = available, 0 = not available.
+#define SWO_MANCHESTER          0               ///< SWO Manchester:  1 = available, 0 = not available
 
 /// SWO Trace Buffer Size.
-#define SWO_BUFFER_SIZE         4096U           ///< SWO Trace Buffer Size in bytes (must be 2^n).
+#define SWO_BUFFER_SIZE         4096U           ///< SWO Trace Buffer Size in bytes (must be 2^n)
 
 /// SWO Streaming Trace.
 #define SWO_STREAM              0               ///< SWO Streaming Trace: 1 = available, 0 = not available.
@@ -115,84 +112,30 @@
 /// This information is returned by the command \ref DAP_Info as part of <b>Capabilities</b>.
 #define DAP_UART                0               ///< DAP UART:  1 = available, 0 = not available.
 
-/// USART Driver instance number for the UART Communication Port.
-#define DAP_UART_DRIVER         1               ///< USART Driver instance number (Driver_USART#).
-
-/// UART Receive Buffer Size.
-#define DAP_UART_RX_BUFFER_SIZE 1024U           ///< Uart Receive Buffer Size in bytes (must be 2^n).
-
-/// UART Transmit Buffer Size.
-#define DAP_UART_TX_BUFFER_SIZE 1024U           ///< Uart Transmit Buffer Size in bytes (must be 2^n).
-
-/// Indicate that UART Communication via USB COM Port is available.
-/// This information is returned by the command \ref DAP_Info as part of <b>Capabilities</b>.
-#define DAP_UART_USB_COM_PORT   1               ///< USB COM Port:  1 = available, 0 = not available.
-
 /// Debug Unit is connected to fixed Target Device.
 /// The Debug Unit may be part of an evaluation board and always connected to a fixed
-/// known device. In this case a Device Vendor, Device Name, Board Vendor and Board Name strings
-/// are stored and may be used by the debugger or IDE to configure device parameters.
-#define TARGET_FIXED            0               ///< Target: 1 = known, 0 = unknown;
+/// known device.  In this case a Device Vendor and Device Name string is stored which
+/// may be used by the debugger or IDE to configure device parameters.
+#define TARGET_DEVICE_FIXED     0               ///< Target Device: 1 = known, 0 = unknown;
+
+#if TARGET_DEVICE_FIXED
+#define TARGET_DEVICE_VENDOR    ""              ///< String indicating the Silicon Vendor
+#define TARGET_DEVICE_NAME      ""              ///< String indicating the Target Device
+#endif
 
 ///@}
 
 
 __STATIC_INLINE void pin_out_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
 {
-    if(pin_bit >= 8)
-    {
-        GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
-        GPIOx->CRH |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit-8) << 2) );
-    }
-    else
-    {
-        GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
-        GPIOx->CRL |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit) << 2) );
-    }
 }
 
 __STATIC_INLINE void pin_out_od_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
 {
-    if(pin_bit >= 8)
-    {
-        GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
-        GPIOx->CRH |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit-8) << 2) );
-    }
-    else
-    {
-        GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
-        GPIOx->CRL |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit) << 2) );
-    }
 }
 
 __STATIC_INLINE void pin_in_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit, uint8_t mode)
 {
-    uint8_t config;
-    if(mode == 1)
-        config = 0x08; //Up
-    else if(mode == 2)
-        config = 0x08; //down
-    else
-        config = 0x00; //GPIO_Mode_AIN
-
-    if(pin_bit >= 8)
-    {
-        GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
-        GPIOx->CRH |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit-8) << 2) );
-        if(mode == 1)
-            GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
-        else if(mode == 2)
-            GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
-    }
-    else
-    {
-        GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
-        GPIOx->CRL |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit) << 2) );
-        if(mode == 1)
-            GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
-        else if(mode == 2)
-            GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
-    }
 }
 //**************************************************************************************************
 /**
@@ -240,7 +183,12 @@
 __STATIC_INLINE void PORT_JTAG_SETUP(void)
 {
 #if (DAP_JTAG != 0)
-
+    SWDIO_INOUT_OE_PORT->BSRR = (SWDIO_INOUT_OE_PIN << 16);
+    JTAG_TDI_PIN_PORT->BSRR = JTAG_TDI_PIN;
+    SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
+    JTAG_TRST_PIN_PORT->BSRR = JTAG_TRST_PIN;
+    JTAG_TARGET_RST_PIN_PORT->BSRR = JTAG_TARGET_RST_PIN;
+    SWDIO_OUT_TMS_PIN_PORT->BSRR = SWDIO_OUT_TMS_PIN;
 #endif
 }
 
@@ -251,17 +199,7 @@
 */
 __STATIC_INLINE void PORT_SWD_SETUP(void)
 {
-    // Set SWCLK HIGH
-    pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
-    SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
-    // Set SWDIO HIGH
-    pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
-    SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
-
-    pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
-    // Set RESET HIGH
-    pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);//TODO - fix reset logic
-    nRESET_PIN_PORT->BSRR = nRESET_PIN;
+    ;             // Not available
 }
 
 /** Disable JTAG/SWD I/O Pins.
@@ -270,9 +208,7 @@
 */
 __STATIC_INLINE void PORT_OFF(void)
 {
-    pin_in_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit, 0);
-    pin_in_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit, 0);
-    pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 0);
+    ;             // Not available
 }
 
 // SWCLK/TCK I/O pin -------------------------------------
@@ -298,7 +234,7 @@
 */
 __STATIC_FORCEINLINE void PIN_SWCLK_TCK_CLR(void)
 {
-    SWCLK_TCK_PIN_PORT->BRR = SWCLK_TCK_PIN;
+    SWCLK_TCK_PIN_PORT->BSRR = (SWCLK_TCK_PIN << 16);
 }
 
 // SWDIO/TMS Pin I/O --------------------------------------
@@ -308,7 +244,7 @@
 */
 __STATIC_FORCEINLINE uint32_t PIN_SWDIO_TMS_IN(void)
 {
-    return ((SWDIO_IN_PIN_PORT->IDR & SWDIO_IN_PIN) ? 1 : 0);
+    return ((SWDIO_OUT_TMS_PIN_PORT->IDR & SWDIO_OUT_TMS_PIN) ? 1 : 0);
 }
 
 /** SWDIO/TMS I/O pin: Set Output to High.
@@ -316,7 +252,7 @@
 */
 __STATIC_FORCEINLINE void PIN_SWDIO_TMS_SET(void)
 {
-    SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
+    SWDIO_OUT_TMS_PIN_PORT->BSRR = SWDIO_OUT_TMS_PIN;
 }
 
 /** SWDIO/TMS I/O pin: Set Output to Low.
@@ -324,7 +260,7 @@
 */
 __STATIC_FORCEINLINE void PIN_SWDIO_TMS_CLR(void)
 {
-    SWDIO_OUT_PIN_PORT->BRR = SWDIO_OUT_PIN;
+    SWDIO_OUT_TMS_PIN_PORT->BSRR = (SWDIO_OUT_TMS_PIN << 16);
 }
 
 /** SWDIO I/O pin: Get Input (used in SWD mode only).
@@ -340,10 +276,11 @@
 */
 __STATIC_FORCEINLINE void PIN_SWDIO_OUT(uint32_t bit)
 {
+
     if (bit & 1)
-        SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
+        SWDIO_OUT_TMS_PIN_PORT->BSRR = SWDIO_OUT_TMS_PIN;
     else
-        SWDIO_OUT_PIN_PORT->BRR = SWDIO_OUT_PIN;
+        SWDIO_OUT_TMS_PIN_PORT->BSRR = (SWDIO_OUT_TMS_PIN << 16);
 }
 
 /** SWDIO I/O pin: Switch to Output mode (used in SWD mode only).
@@ -352,8 +289,7 @@
 */
 __STATIC_FORCEINLINE void PIN_SWDIO_OUT_ENABLE(void)
 {
-    pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
-    SWDIO_OUT_PIN_PORT->BRR = SWDIO_OUT_PIN;
+    SWDIO_INOUT_OE_PORT->BSRR = (SWDIO_INOUT_OE_PIN << 16);
 }
 
 /** SWDIO I/O pin: Switch to Input mode (used in SWD mode only).
@@ -362,8 +298,8 @@
 */
 __STATIC_FORCEINLINE void PIN_SWDIO_OUT_DISABLE(void)
 {
-    pin_in_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit, 0);
-    SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
+    SWDIO_OUT_TMS_PIN_PORT->BSRR = (SWDIO_OUT_TMS_PIN<< 16);
+    SWDIO_INOUT_OE_PORT->BSRR = SWDIO_INOUT_OE_PIN;
 }
 
 
@@ -374,7 +310,7 @@
 */
 __STATIC_FORCEINLINE uint32_t PIN_TDI_IN(void)
 {
-    return (0);   // Not available
+    return ((JTAG_TDI_PIN_PORT->IDR & JTAG_TDI_PIN) ? 1 : 0);
 }
 
 /** TDI I/O pin: Set Output.
@@ -382,7 +318,10 @@
 */
 __STATIC_FORCEINLINE void PIN_TDI_OUT(uint32_t bit)
 {
-    ;             // Not available
+    if (bit & 1)
+        JTAG_TDI_PIN_PORT->BSRR = JTAG_TDI_PIN;
+    else
+        JTAG_TDI_PIN_PORT->BSRR = (JTAG_TDI_PIN << 16);
 }
 
 
@@ -393,7 +332,7 @@
 */
 __STATIC_FORCEINLINE uint32_t PIN_TDO_IN(void)
 {
-    return (0);   // Not available
+    return ((JTAG_TDO_PIN_PORT->IDR & JTAG_TDO_PIN) ? 1 : 0);
 }
 
 
@@ -404,7 +343,7 @@
 */
 __STATIC_FORCEINLINE uint32_t PIN_nTRST_IN(void)
 {
-    return (0);   // Not available
+    return ((JTAG_TRST_PIN_PORT->IDR & JTAG_TRST_PIN) ? 1 : 0);
 }
 
 /** nTRST I/O pin: Set Output.
@@ -414,7 +353,10 @@
 */
 __STATIC_FORCEINLINE void PIN_nTRST_OUT(uint32_t bit)
 {
-    ;             // Not available
+    if (bit & 1)
+        JTAG_TRST_PIN_PORT->BSRR = JTAG_TRST_PIN;
+    else
+        JTAG_TRST_PIN_PORT->BSRR = (JTAG_TRST_PIN << 16);
 }
 
 // nRESET Pin I/O------------------------------------------
@@ -424,7 +366,7 @@
 */
 __STATIC_FORCEINLINE uint32_t PIN_nRESET_IN(void)
 {
-    return ((nRESET_PIN_PORT->IDR >> nRESET_PIN_Bit) & 1);
+    return ((JTAG_TARGET_RST_PIN_PORT->IDR >> JTAG_TARGET_RST_PIN_BIT) & 1);
 }
 
 /** nRESET I/O pin: Set Output.
@@ -432,14 +374,13 @@
            - 0: issue a device hardware reset.
            - 1: release device hardware reset.
 */
-// TODO - sw specific implementation should be created
-
-__STATIC_FORCEINLINE void     PIN_nRESET_OUT(uint32_t bit)
+__STATIC_FORCEINLINE void PIN_nRESET_OUT(uint32_t bit)
 {
-    if (bit & 1)
-        nRESET_PIN_PORT->BSRR = nRESET_PIN;
-    else
-        nRESET_PIN_PORT->BRR = nRESET_PIN;
+    if (bit & 1) {
+        JTAG_TARGET_RST_PIN_PORT->BSRR = (JTAG_TARGET_RST_PIN << 16); // DIR pin low -> nRST goes high
+    } else {
+        JTAG_TARGET_RST_PIN_PORT->BSRR = JTAG_TARGET_RST_PIN; // DIR pin high -> nRST goes low
+    }
 }
 
 //**************************************************************************************************
@@ -462,10 +403,7 @@
 */
 __STATIC_INLINE void LED_CONNECTED_OUT(uint32_t bit)
 {
-    if (bit & 1)
-        CONNECTED_LED_PORT->BRR = CONNECTED_LED_PIN; // LED on
-    else
-        CONNECTED_LED_PORT->BSRR = CONNECTED_LED_PIN;// LED off
+    ;   // Not available
 }
 
 /** Debug Unit: Set status Target Running LED.
@@ -497,7 +435,11 @@
 \return Current timestamp value.
 */
 __STATIC_INLINE uint32_t TIMESTAMP_GET (void) {
-  return (DWT->CYCCNT) / (CPU_CLOCK / TIMESTAMP_CLOCK);
+#if defined(HISPARK_TRACE)
+    return 100;  // delete by xuyong, 只有M核才有DWT,A核需要其他的寄存器
+#else
+    return (DWT->CYCCNT) / (CPU_CLOCK / TIMESTAMP_CLOCK);
+#endif
 }
 
 ///@}
@@ -522,25 +464,19 @@
 */
 __STATIC_INLINE void DAP_SETUP(void)
 {
-    /* Enable port clock */
-    __HAL_RCC_GPIOA_CLK_ENABLE();
-    __HAL_RCC_GPIOB_CLK_ENABLE();
-    __HAL_RCC_GPIOC_CLK_ENABLE();
-    __HAL_RCC_GPIOD_CLK_ENABLE();
-    /* Configure I/O pin SWCLK */
-    pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
-    SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
-
-    pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
-    SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
-
-    pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
+#ifndef HISPARK_TRACE
+    GPIO_InitTypeDef gpio_init =
+    {
+        .Pin = CONNECTED_LED_PIN,
+        .Mode = GPIO_MODE_OUTPUT_PP,
+        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
+    };
 
-    pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);
-    nRESET_PIN_PORT->BSRR = nRESET_PIN;
+    PORT_SWD_SETUP();
 
-    pin_out_init(CONNECTED_LED_PORT, CONNECTED_LED_PIN_Bit);
-    CONNECTED_LED_PORT->BSRR = CONNECTED_LED_PIN;
+    HAL_GPIO_Init(CONNECTED_LED_PORT, &gpio_init);
+    HAL_GPIO_WritePin(CONNECTED_LED_PORT, CONNECTED_LED_PIN, GPIO_PIN_SET);
+#endif
 }
 
 /** Reset Target Device with custom specific I/O pin or command sequence.
@@ -557,5 +493,4 @@
 
 ///@}
 
-
 #endif /* __DAP_CONFIG_H__ */
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/daplink_addr.h new/CA7/source/hic_hal/stm32/stm32mp1xx/daplink_addr.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/daplink_addr.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/daplink_addr.h	2023-05-25 15:09:49.000000000 +0800
@@ -23,39 +23,70 @@
 #define DAPLINK_ADDR_H
 
 /* Device sizes */
+#define UPGRADE_LOADERBOOT 0
 
-#define DAPLINK_ROM_START               0x08000000
-#define DAPLINK_ROM_SIZE                0x00020000
+#define DAPLINK_ROM_START               0x10048000
+#define DAPLINK_ROM_SIZE                0x001000000 // has to be a multiple of the sector size, only bank 1 is used, the datasheet says under table 7 in the notes section that the memory boundary is limited to this on each bank
 
-#define DAPLINK_RAM_START               0x20000000
-#define DAPLINK_RAM_SIZE                0x00005000
+#define DAPLINK_RAM_START               0x2FFF8500 // Execute from AXI SRAM, because it's powered on by default and the app is quite large due to the sector_buf static variable that is used to hold one sector (128Kb)
+#define DAPLINK_RAM_SIZE                0x0002000 // divisible by DAPLINK_MIN_WRITE_SIZE
+
+/* Flash Programming Info */
+
+#define DAPLINK_SECTOR_SIZE             0x0001000 // this chip has a large 128Kb sector erase
+#define DAPLINK_MIN_WRITE_SIZE          0x00000100
 
 /* ROM sizes */
 
-#define DAPLINK_ROM_BL_START            0x08000000
-#define DAPLINK_ROM_BL_SIZE             0x0000BC00
+#define DAPLINK_ROM_BL_START            0x10048000
+#define DAPLINK_ROM_BL_SIZE             0x10000000                // 0x00020000 // 128 kB bootloader -- 1 sector modified by xuyong, 临时不支持bootloader
 
-#define DAPLINK_ROM_IF_START            0x0800C000
-#define DAPLINK_ROM_IF_SIZE             0x00013C00
+#define DAPLINK_ROM_CONFIG_ADMIN_START  0x08020000
+#define DAPLINK_ROM_CONFIG_ADMIN_SIZE   0x00020000 // 1 sector
 
-#define DAPLINK_ROM_CONFIG_USER_START   0x0801FC00
-#define DAPLINK_ROM_CONFIG_USER_SIZE    0x00000400
+#if defined(DAPLINK_BASEADDR) && (DAPLINK_BASEADDR != 0)
+#define DAPLINK_ROM_IF_START            DAPLINK_BASEADDR
+#else
+#error "Please set daplink base address"
+#endif
+#define DAPLINK_ROM_IF_SIZE             0x00010000 // 5 sectors
 
-/* RAM sizes */
 
-#define DAPLINK_RAM_APP_START           0x20000000
-#define DAPLINK_RAM_APP_SIZE            0x00004F00
+#if defined(UPGRADE_LOADERBOOT) && (UPGRADE_LOADERBOOT == 1)
+#define DAPLINK_ROM_IF_OFFSET_A         0x0000
+#else
+#define DAPLINK_ROM_IF_OFFSET_A         0xc000
+#endif
 
-#define DAPLINK_RAM_SHARED_START        0x20004F00
-#define DAPLINK_RAM_SHARED_SIZE         0x00000100
+#define DAPLINK_ROM_IF_START_A          (0x10048000 + DAPLINK_ROM_IF_OFFSET_A)
+#define DAPLINK_ROM_IF_SIZE_A           0x1000000
 
-/* Flash Programming Info */
+#define DAPLINK_ROM_IF_OFFSET_B         0x10c000
+#define DAPLINK_ROM_IF_START_B          (0x10048000 + DAPLINK_ROM_IF_OFFSET_B)
+#define DAPLINK_ROM_IF_SIZE_B           0x1000000
 
-#define DAPLINK_SECTOR_SIZE             0x00000400
-#define DAPLINK_MIN_WRITE_SIZE          0x00000400
 
-/* Current build */
+#define DAPLINK_ROM_TARGET_IMAGE_START  0x70000000
+#define DAPLINK_ROM_TARGET_IMAGE_SIZE   0x00010000
+
+#define DAPLINK_ROM_TARGET_ALGO_START  0x70010000
+#define DAPLINK_ROM_TARGET_ALGO_SIZE   0x00010000
 
+#define DAPLINK_ROM_CONFIG_USER_START   0x080E0000
+#define DAPLINK_ROM_CONFIG_USER_SIZE    0x00020000 // 1 sector
+
+/* RAM sizes */
+
+#define DAPLINK_RAM_APP_START           DAPLINK_RAM_START
+#define DAPLINK_RAM_APP_SIZE            (DAPLINK_RAM_SIZE - DAPLINK_MIN_WRITE_SIZE) // leave space for RAM_SHARED
+
+#define DAPLINK_RAM_SHARED_START        (DAPLINK_RAM_APP_START + DAPLINK_RAM_APP_SIZE)
+#define DAPLINK_RAM_SHARED_SIZE         (DAPLINK_RAM_SIZE - DAPLINK_RAM_APP_SIZE) // fill the rest of RAM
+
+#ifndef DAPLINK_IF
+#define DAPLINK_IF
+#endif
+/* Current build */
 #if defined(DAPLINK_BL)
 
 #define DAPLINK_ROM_APP_START            DAPLINK_ROM_BL_START
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/flash.c new/CA7/source/hic_hal/stm32/stm32mp1xx/flash.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/flash.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/flash.c	2023-05-25 15:09:49.000000000 +0800
@@ -1,5 +1,5 @@
 /**
- * @file    flash_hal_stm32f103xb.c
+ * @file    flash_hal_stm32h743ii.c
  * @brief
  *
  * DAPLink Interface Firmware
@@ -19,12 +19,72 @@
  * limitations under the License.
  */
 
+#ifdef HISPARK_BOOT
+#include "flash_hal.h"        // FlashOS Structures
+#include "stm32mp1xx.h"
+#include "util.h"
+#include "string.h"
+#include "daplink_addr.h"
+#else
 #include "flash_hal.h"        // FlashOS Structures
 #include "target_config.h"    // target_device
-#include "stm32f1xx.h"
+#include "stm32mp1xx.h"
 #include "util.h"
 #include "string.h"
 #include "target_board.h"
+#include "daplink_addr.h"
+#include "debug.h"
+#endif
+
+#define FLASH_BASE_SHIFT             DAPLINK_ROM_BL_START
+
+#define PRG_PAGE_SIZE_SHIFT          4
+#define QSPI_DUMMY_CYCLES            0
+#define DUMMY_CLOCK_CYCLES_READ_QUAD 10
+#define DUMMY_CLOCK_CYCLES_READ_MAP  10
+
+#define QSPI_OK                 0
+#define QSPI_ERROR              1
+
+#define FLASH_STATUS_NO_READY   0
+#define FLASH_STATUS_IS_READY   1
+
+/* Read/Write/erase Array Commands */
+#define NORMAL_READ_CMD        0x03
+#define FAST_READ_CMD          0x0B
+#define TWO_READ_READ_CMD      0xBB
+#define DREAD_READ_CMD         0x3B
+#define FOUR_READ_READ_CMD     0xEB
+#define QUAD_OUT_FAST_READ_CMD 0x6B
+#define PAGE_PROGRAM_CMD       0x02
+#define QUAD_PAGE_PROGRAM_CMD  0x38
+#define SECTOR_ERASE_CMD       0x20
+#define BLOCK_ERASE_32K_CMD    0x52
+#define BLOCK_ERASE_64K_CMD    0xD8
+#define CHIP_ERASE_CMD         0x60 /*0x60 or 0xC7*/
+
+/* Reagister/Setting Commands */
+#define WRITE_ENABLE_CMD               0x06
+#define WRITE_DISABLE_CMD              0x04
+#define READ_STATUS_REG_CMD            0x05
+#define READ_CFG_REG_CMD               0x15
+#define WRITE_STATUS_REG_CMD           0x01
+#define WRITE_PROTECT_SEL_CMD          0x68
+#define ENABLE_QPI_CMD                 0x35
+#define RESET_QPI_CMD                  0xF5
+#define PE_SUSPEND_CMD                 0xB0
+#define PE_RESUME_CMD                  0x30
+#define DEEP_POWER_DOWN_CMD            0xB9
+#define RELEASE_DEEP_POWER_DOWN_CMD    0xAB
+#define SET_BURST_LENGTH_CMD           0xC0
+#define READ_FAST_BOOT_REG_CMD         0x16
+#define WRITE_FAST_BOOT_REG_CMD        0x17
+#define ERASE_FAST_BOOT_REG_CMD        0x18
+
+/* Reset Commands */
+#define NOP_OP_CMD            0x00
+#define RESET_ENABLE_CMD      0x66
+#define RESET_MEMORY_CMD      0x99
 
 /*********************************************************************
 *
@@ -32,6 +92,209 @@
 *
 **********************************************************************
 */
+static QSPI_HandleTypeDef g_flashQspiHandle;
+static uint32_t g_flashReadyStatus = FLASH_STATUS_NO_READY;
+
+static uint32_t QSPI_ResetChip(void)
+{
+    QSPI_CommandTypeDef sCommand;
+    uint32_t temp = 0;
+    /* Erasing Sequence ---------------------------------*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= RESET_ENABLE_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.Address= 0;
+    sCommand.DataMode= QSPI_DATA_NONE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)	!= HAL_OK)
+    {
+        return 1;
+    }
+    for(temp = 0; temp < 0x2f; temp++)
+    {
+        __NOP();
+    }
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= RESET_MEMORY_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.Address= 0;
+    sCommand.DataMode= QSPI_DATA_NONE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)!= HAL_OK)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static uint32_t QSPI_AutoPollingMemReady(uint32_t timeout)
+{
+    QSPI_CommandTypeDef sCommand;
+    QSPI_AutoPollingTypeDef sConfig;
+    memset(&sCommand, 0, sizeof(sCommand));
+    memset(&sConfig, 0, sizeof(sConfig));
+    /* Configure automatic polling mode to wait for memory ready ------*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.Instruction= READ_STATUS_REG_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DataMode= QSPI_DATA_1_LINE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sConfig.Match= 0x00;
+    sConfig.Mask= 0x01;
+    sConfig.MatchMode= QSPI_MATCH_MODE_AND;
+    sConfig.StatusBytesSize= 1;
+    sConfig.Interval= 0x10;
+    sConfig.AutomaticStop= QSPI_AUTOMATIC_STOP_ENABLE;
+    if(HAL_QSPI_AutoPolling(&g_flashQspiHandle, &sCommand, &sConfig, timeout) != HAL_OK)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static uint32_t QSPI_Configuration(void)
+{
+    QSPI_CommandTypeDef sCommand;
+    uint8_t test_buffer[4] = { 0 };
+    /*read status register*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.Instruction= READ_STATUS_REG_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DataMode= QSPI_DATA_1_LINE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.NbData= 1;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)	!= HAL_OK)
+    {
+        return 1;
+    }
+    if(HAL_QSPI_Receive(&g_flashQspiHandle, test_buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
+    {
+        return 1;
+    }
+    /*read configuration register*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.Instruction= READ_CFG_REG_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DataMode= QSPI_DATA_1_LINE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.NbData= 1;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)	!= HAL_OK)
+    {
+        return 1;
+    }
+
+    if(HAL_QSPI_Receive(&g_flashQspiHandle, &(test_buffer[1]),	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
+    {
+        return 1;
+    }
+
+    /*modify buffer to enable quad mode*/
+    test_buffer[0] |= 0x40;
+    /*set dummy cycles*/
+    test_buffer[1] |= 0xC0;
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= WRITE_STATUS_REG_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.DataMode= QSPI_DATA_1_LINE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    sCommand.NbData= 2;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
+    {
+        return 1;
+    }
+    if(HAL_QSPI_Transmit(&g_flashQspiHandle, test_buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+    return 0;
+}
+
+uint32_t QSPI_EnableMemoryMappedMode(void)
+{
+    QSPI_CommandTypeDef sCommand;
+    QSPI_MemoryMappedTypeDef sMemMappedCfg;
+    /* Enable Memory-Mapped mode------------------------------------------*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_1_LINE;
+    sCommand.DataMode= QSPI_DATA_4_LINES;
+    sCommand.NbData= 0;
+    sCommand.Address= 0;
+    sCommand.Instruction= QUAD_OUT_FAST_READ_CMD;
+    sCommand.DummyCycles= DUMMY_CLOCK_CYCLES_READ_MAP;
+    sMemMappedCfg.TimeOutActivation= QSPI_TIMEOUT_COUNTER_DISABLE;
+    if(HAL_QSPI_MemoryMapped(&g_flashQspiHandle, &sCommand, &sMemMappedCfg) != HAL_OK)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static uint32_t QSPI_WriteEnable(void)
+{
+    QSPI_CommandTypeDef sCommand;
+    QSPI_AutoPollingTypeDef sConfig;
+    memset(&sCommand, 0, sizeof(sCommand));
+    memset(&sConfig, 0, sizeof(sConfig));
+    /* Enable write operations ------------------------------------------*/
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.Instruction= WRITE_ENABLE_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_NONE;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DataMode= QSPI_DATA_NONE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    if(HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)!= HAL_OK)
+    {
+        return QSPI_ERROR;
+    }
+    /* Configure automatic polling mode to wait for write enabling ----*/
+    sConfig.Match = 0x02;
+    sConfig.Mask = 0x02;
+    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
+    sConfig.StatusBytesSize = 1;
+    sConfig.Interval = 0x10;
+    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
+    sCommand.Instruction = READ_STATUS_REG_CMD;
+    sCommand.DataMode = QSPI_DATA_1_LINE;
+    if(HAL_QSPI_AutoPolling(&g_flashQspiHandle, &sCommand, &sConfig, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
+    {
+        return QSPI_ERROR;
+    }
+    return QSPI_OK;
+}
 
 /*********************************************************************
 *
@@ -39,11 +302,43 @@
 *
 **********************************************************************
 */
+
 uint32_t Init(uint32_t adr, uint32_t clk, uint32_t fnc)
 {
-    //
-    // No special init required
-    //
+    uint32_t ret;
+    g_flashQspiHandle.Instance = QUADSPI;
+    g_flashQspiHandle.Init.ClockPrescaler = 1;
+    g_flashQspiHandle.Init.FifoThreshold = 4;
+    g_flashQspiHandle.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
+    g_flashQspiHandle.Init.FlashSize = 23;
+    g_flashQspiHandle.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
+    g_flashQspiHandle.Init.ClockMode = QSPI_CLOCK_MODE_0;
+    g_flashQspiHandle.Init.FlashID = QSPI_FLASH_ID_1;
+    g_flashQspiHandle.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
+    if (HAL_QSPI_Init(&g_flashQspiHandle) != HAL_OK){
+        return 1;
+    }
+    
+    ret =  QSPI_ResetChip();
+    if (ret != 0) {
+        return 1;
+    }
+
+    ret = QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE);
+    if (ret != 0) {
+        return 1;
+    }
+
+    ret = QSPI_WriteEnable();
+    if (ret != 0) {
+        return 1;
+    }
+
+    ret = QSPI_Configuration();
+    if (ret != 0) {
+        return 1;
+    }
+    g_flashReadyStatus = FLASH_STATUS_IS_READY;
     return (0);
 }
 
@@ -52,69 +347,193 @@
     //
     // No special uninit required
     //
+    HAL_QSPI_DeInit(&g_flashQspiHandle);
+    g_flashReadyStatus = FLASH_STATUS_NO_READY;
     return (0);
 }
 
 uint32_t EraseChip(void)
 {
-    FLASH_EraseInitTypeDef erase_init;
-    uint32_t error;
-    uint32_t ret = 0;  // O.K.
-    if (g_board_info.target_cfg) {
-        HAL_FLASH_Unlock();
-        //bootloader, interface flashing only concerns 1 flash region
-        util_assert((g_board_info.target_cfg->flash_regions[0].end - g_board_info.target_cfg->flash_regions[0].start) %
-                    FLASH_PAGE_SIZE == 0);
-        memset(&erase_init, 0, sizeof(erase_init));
-        erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
-        erase_init.PageAddress = g_board_info.target_cfg->flash_regions[0].start;
-        erase_init.NbPages = (g_board_info.target_cfg->flash_regions[0].end - g_board_info.target_cfg->flash_regions[0].start) % FLASH_PAGE_SIZE;
-        if (HAL_FLASHEx_Erase(&erase_init, &error) != HAL_OK) {
-            ret = 1;
+    QSPI_CommandTypeDef sCommand;
+
+    if (g_flashReadyStatus != FLASH_STATUS_IS_READY) {
+        if (Init(0,0,0) != QSPI_OK) {
+             return QSPI_ERROR;
         }
-        
-        HAL_FLASH_Lock();
-    }else{
-        ret = 1;
     }
-    return ret;
+
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+
+    if (QSPI_WriteEnable() != HAL_OK) {
+        return QSPI_ERROR;
+    }
+    
+    sCommand.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressMode       = QSPI_ADDRESS_NONE;
+    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DataMode          = QSPI_DATA_NONE;
+    sCommand.DummyCycles       = QSPI_DUMMY_CYCLES;
+    sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
+
+    sCommand.Instruction = CHIP_ERASE_CMD;
+
+    if (HAL_QSPI_Command(&g_flashQspiHandle, &sCommand,HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+    
+    
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE * 16) != QSPI_OK) {
+            return QSPI_ERROR;
+    }
+    return 0;
 }
 
 uint32_t EraseSector(uint32_t adr)
 {
-    FLASH_EraseInitTypeDef erase_init;
-    uint32_t error;
-    uint32_t ret = 0;  // O.K.
+    QSPI_CommandTypeDef sCommand;
+    uint32_t tmpAddr = 0;
 
-    HAL_FLASH_Unlock();
-    
-    memset(&erase_init, 0, sizeof(erase_init));
-    erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
-    erase_init.PageAddress = adr;
-    erase_init.NbPages = 1;
-    if (HAL_FLASHEx_Erase(&erase_init, &error) != HAL_OK) {
-        ret = 1;
+    if (g_flashReadyStatus != FLASH_STATUS_IS_READY) {
+        if (Init(0,0,0) != QSPI_OK) {
+             return QSPI_ERROR;
+        }
     }
 
-    HAL_FLASH_Lock();
-    return ret;
+    if (adr >= FLASH_BASE_SHIFT) {
+        tmpAddr = adr - FLASH_BASE_SHIFT;
+    }
+
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+
+    if (QSPI_WriteEnable() != HAL_OK) {
+        return QSPI_ERROR;
+    }
+
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= SECTOR_ERASE_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_1_LINE;
+    sCommand.DataMode= QSPI_DATA_NONE;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+
+    sCommand.Address = tmpAddr;
+
+    if (HAL_QSPI_Command(&g_flashQspiHandle, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)	!= HAL_OK) {
+            return QSPI_ERROR;
+    }
+    
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+            return QSPI_ERROR;
+    }
+    return 0;
 }
 
 uint32_t ProgramPage(uint32_t adr, uint32_t sz, uint32_t *buf)
 {
-    uint32_t i;
-    uint32_t ret = 0;  // O.K.
-
-    HAL_FLASH_Unlock();
+    QSPI_CommandTypeDef sCommand;
+    uint32_t tmpAddr = 0;
 
-    util_assert(sz % 4 == 0);
-    for (i = 0; i < sz / 4; i++) {
-        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, adr + i * 4, buf[i]) != HAL_OK) {
-            ret = 1;
-            break;
+    if (g_flashReadyStatus != FLASH_STATUS_IS_READY) {
+        if (Init(0,0,0) != QSPI_OK) {
+             return QSPI_ERROR;
         }
     }
 
-    HAL_FLASH_Lock();
-    return ret;
+    if (adr >= FLASH_BASE_SHIFT) {
+        tmpAddr = adr - FLASH_BASE_SHIFT;
+    }
+#ifndef HISPARK_BOOT
+    util_assert(sz % PRG_PAGE_SIZE_SHIFT == 0);
+#endif
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+
+    if (QSPI_WriteEnable() != HAL_OK) {
+        return QSPI_ERROR;
+    }
+
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= QUAD_PAGE_PROGRAM_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_4_LINES;
+    sCommand.DataMode= QSPI_DATA_4_LINES;
+    sCommand.NbData = sz;
+    sCommand.Address = tmpAddr;
+    sCommand.DummyCycles= QSPI_DUMMY_CYCLES;
+    if (HAL_QSPI_Command(&g_flashQspiHandle, &sCommand,HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+
+    if (HAL_QSPI_Transmit(&g_flashQspiHandle, (uint8_t *)buf, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+
+    return 0;
 }
+
+uint32_t FlashRead(uint32_t adr, uint32_t sz, uint8_t *buf)
+{
+    QSPI_CommandTypeDef sCommand;
+    uint32_t tmpAddr = 0;
+
+    if (g_flashReadyStatus != FLASH_STATUS_IS_READY) {
+        if (Init(0,0,0) != QSPI_OK) {
+             return QSPI_ERROR;
+        }
+    }
+
+    if (adr >= FLASH_BASE_SHIFT) {
+        tmpAddr = adr - FLASH_BASE_SHIFT;
+    }
+
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+
+    if (QSPI_WriteEnable() != HAL_OK) {
+        return QSPI_ERROR;
+    }
+    sCommand.InstructionMode= QSPI_INSTRUCTION_1_LINE;
+    sCommand.AddressSize= QSPI_ADDRESS_24_BITS;
+    sCommand.AlternateByteMode= QSPI_ALTERNATE_BYTES_NONE;
+    sCommand.DdrMode= QSPI_DDR_MODE_DISABLE;
+    sCommand.DdrHoldHalfCycle= QSPI_DDR_HHC_ANALOG_DELAY;
+    sCommand.SIOOMode= QSPI_SIOO_INST_EVERY_CMD;
+    sCommand.Instruction= FOUR_READ_READ_CMD;
+    sCommand.AddressMode= QSPI_ADDRESS_4_LINES;
+    sCommand.DataMode= QSPI_DATA_4_LINES;
+    sCommand.NbData = sz;
+    sCommand.Address = tmpAddr;
+    sCommand.DummyCycles= DUMMY_CLOCK_CYCLES_READ_QUAD;
+    if (HAL_QSPI_Command(&g_flashQspiHandle, &sCommand,HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+
+    if (HAL_QSPI_Receive(&g_flashQspiHandle, (uint8_t *)buf, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
+        return 1;
+    }
+
+    if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {
+        return QSPI_ERROR;
+    }
+    return 0;
+}
\ No newline at end of file
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/gpio.c new/CA7/source/hic_hal/stm32/stm32mp1xx/gpio.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/gpio.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/gpio.c	2023-06-09 15:41:16.791334600 +0800
@@ -19,7 +19,7 @@
  * limitations under the License.
  */
 
-#include "stm32f1xx.h"
+#include "stm32mp1xx.h"
 #include "DAP_config.h"
 #include "gpio.h"
 #include "daplink.h"
@@ -40,11 +40,11 @@
 static uint32_t tim1_clk_div(uint32_t apb2clkdiv)
 {
     switch (apb2clkdiv) {
-        case RCC_CFGR_PPRE2_DIV2:
+        case RCC_APB2_DIV1:
             return 1;
-        case RCC_CFGR_PPRE2_DIV4:
+        case RCC_APB2_DIV4:
             return 2;
-        case RCC_CFGR_PPRE2_DIV8:
+        case RCC_APB2_DIV8:
             return 4;
         default: // RCC_CFGR_PPRE2_DIV1
             return 1;
@@ -63,7 +63,7 @@
     HAL_RCC_GetClockConfig(&clk_init, &unused);
 
     /* Compute the period value to have TIMx counter clock equal to 8000000 Hz */
-    source_clock = SystemCoreClock / tim1_clk_div(clk_init.APB2CLKDivider);
+    source_clock = SystemCoreClock / tim1_clk_div(clk_init.APB2_Div);
     period = (uint32_t)(source_clock / 8000000) - 1;
 
     /* Set TIMx instance */
@@ -112,6 +112,35 @@
     return;
 }
 
+void gpio_init_buffered_dut_pin(GPIO_TypeDef *dir_port, uint16_t dir_pin, GPIO_TypeDef *input_port, uint16_t input_pin, bool activeHigh)
+{
+    // Initialize GPIO signals to DUT
+    //
+    // These are "open drain/open collector" signals, with an external buffer (with a direction pin for each line).
+    // The buffer direction is normally an input (to the MCU) so the DUT can pull high/low as needed and a butten can
+    // also pull hi/low manually.
+    // To "activate" the signal the MCU pin has a weak IO pullup/down so when the buffer becomes an output (from the MCU)
+    // the DUT line is driven high/low as needed.
+
+    GPIO_InitTypeDef GPIO_InitStructure;
+
+    HAL_GPIO_WritePin(dir_port, dir_pin, GPIO_PIN_RESET);  //input to MCU
+
+    GPIO_InitStructure.Pin = dir_pin;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    HAL_GPIO_Init(dir_port, &GPIO_InitStructure);
+
+    //MCU pin is initialized as an input with pulldown (active low) or pullup (active high)
+    GPIO_InitStructure.Pin = input_pin;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = activeHigh ? GPIO_PULLUP : GPIO_PULLDOWN;
+    HAL_GPIO_Init(input_port, &GPIO_InitStructure);
+    GPIO_InitStructure.Pull = GPIO_NOPULL;
+}
+
+
 void gpio_init(void)
 {
     GPIO_InitTypeDef GPIO_InitStructure;
@@ -120,24 +149,124 @@
     __HAL_RCC_GPIOB_CLK_ENABLE();
     __HAL_RCC_GPIOC_CLK_ENABLE();
     __HAL_RCC_GPIOD_CLK_ENABLE();
+    __HAL_RCC_GPIOE_CLK_ENABLE();  //gpio, spi, etc
+    __HAL_RCC_GPIOF_CLK_ENABLE();  //gpio direction, etc.
+    __HAL_RCC_GPIOG_CLK_ENABLE();  //elee: udb led's
+    __HAL_RCC_GPIOH_CLK_ENABLE();  //elee: usb hub signals, SPI, I2C
+	__HAL_RCC_GPIOI_CLK_ENABLE();  //udb usb ulpi dir, spi, jtag
     // Enable USB connect pin
-    __HAL_RCC_AFIO_CLK_ENABLE();
-    // Disable JTAG to free pins for other uses
+	__HAL_RCC_SYSCFG_CLK_ENABLE();   //elee: this macro maps to the same as __HAL_RCC_AFIO_CLK_ENABLE(); (in the F1) and still exists.  Try it...
+
+		// Disable JTAG to free pins for other uses
     // Note - SWD is still enabled
-    __HAL_AFIO_REMAP_SWJ_NOJTAG();
+		//ToDo: elee: this doesn't exist in the H7 hal.  Can it be skipped, or need to find a replacement?  Skip it for now...
+		//__HAL_AFIO_REMAP_SWJ_NOJTAG();
 
     USB_CONNECT_PORT_ENABLE();
     USB_CONNECT_OFF();
-    GPIO_InitStructure.Pin = USB_CONNECT_PIN;
+	GPIO_InitStructure.Pin = USB_CONNECT_PIN;  //elee: WHAT does this pin do?  PA15?  what board is it from?  stm429?  discovery?  MB1075.pdf doesn't have it.  I guess USB power (to detect if connected?).  Or LED to show USB connected?
     GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
     HAL_GPIO_Init(USB_CONNECT_PORT, &GPIO_InitStructure);
-    // configure LEDs
-    HAL_GPIO_WritePin(RUNNING_LED_PORT, RUNNING_LED_PIN, GPIO_PIN_SET);
-    GPIO_InitStructure.Pin = RUNNING_LED_PIN;
-    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+
+    //config SWD
+    GPIO_InitStructure.Pin = SWDIO_INOUT_OE_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(SWDIO_INOUT_OE_PORT, &GPIO_InitStructure);
+
+    GPIO_InitStructure.Pin = SWCLK_TCK_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLDOWN;
+    HAL_GPIO_Init(SWCLK_TCK_PIN_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN, GPIO_PIN_SET);
+
+    GPIO_InitStructure.Pin = SWDIO_OUT_TMS_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(SWDIO_OUT_TMS_PIN_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(SWDIO_OUT_TMS_PIN_PORT, SWDIO_OUT_TMS_PIN, GPIO_PIN_SET);
+
+    GPIO_InitStructure.Pin = SWDIO_IN_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(SWDIO_IN_PIN_PORT, &GPIO_InitStructure);
+
+
+    GPIO_InitStructure.Pin = JTAG_TDI_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(JTAG_TDI_PIN_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(JTAG_TDI_PIN_PORT, JTAG_TDI_PIN, GPIO_PIN_SET);
+
+    GPIO_InitStructure.Pin = JTAG_TDO_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(JTAG_TDO_PIN_PORT, &GPIO_InitStructure);
+
+    GPIO_InitStructure.Pin = JTAG_TRST_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLDOWN;
+    HAL_GPIO_Init(JTAG_TRST_PIN_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(JTAG_TRST_PIN_PORT, JTAG_TRST_PIN, GPIO_PIN_SET);
+
+    GPIO_InitStructure.Pin = JTAG_TARGET_RST_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(JTAG_TARGET_RST_PIN_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(JTAG_TARGET_RST_PIN_PORT, JTAG_TARGET_RST_PIN, GPIO_PIN_SET);
+
+    //config LED
+    GPIO_InitStructure.Pin = OFFLINE_DOWNLOAD_STATUS_LED_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
     GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
-    HAL_GPIO_Init(RUNNING_LED_PORT, &GPIO_InitStructure);
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(OFFLINE_DOWNLOAD_STATUS_LED_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(OFFLINE_DOWNLOAD_STATUS_LED_PORT, OFFLINE_DOWNLOAD_STATUS_LED_PIN, GPIO_PIN_SET);
+
+    //config power switch
+    GPIO_InitStructure.Pin = POWER_SWITCH_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStructure.Pull = GPIO_PULLDOWN;
+    HAL_GPIO_Init(POWER_SWITCH_PORT, &GPIO_InitStructure);
+    HAL_GPIO_WritePin(POWER_SWITCH_PORT, POWER_SWITCH_PIN, GPIO_PIN_RESET);
+
+    //config board ID
+    GPIO_InitStructure.Pin = BOARD_ID0_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(BOARD_ID0_PORT, &GPIO_InitStructure);
+
+    GPIO_InitStructure.Pin = BOARD_ID1_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(BOARD_ID1_PORT, &GPIO_InitStructure);
+
+    GPIO_InitStructure.Pin = BOARD_ID2_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Pull = GPIO_PULLUP;
+    HAL_GPIO_Init(BOARD_ID2_PORT, &GPIO_InitStructure);
+
+    // configure LEDs
+    // HAL_GPIO_WritePin(RUNNING_LED_PORT, RUNNING_LED_PIN, GPIO_PIN_SET);
+    // GPIO_InitStructure.Pin = RUNNING_LED_PIN;
+    // GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+    // GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    // HAL_GPIO_Init(RUNNING_LED_PORT, &GPIO_InitStructure);
+    // // HAL_GPIO_WritePin(RUNNING_LED_PORT, RUNNING_LED_PIN, GPIO_PIN_RESET);
+    // // while(1);
 
     HAL_GPIO_WritePin(CONNECTED_LED_PORT, CONNECTED_LED_PIN, GPIO_PIN_SET);
     GPIO_InitStructure.Pin = CONNECTED_LED_PIN;
@@ -145,39 +274,73 @@
     GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
     HAL_GPIO_Init(CONNECTED_LED_PORT, &GPIO_InitStructure);
 
-    HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, GPIO_PIN_SET);
-    GPIO_InitStructure.Pin = PIN_CDC_LED;
-    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
-    HAL_GPIO_Init(PIN_CDC_LED_PORT, &GPIO_InitStructure);
+    // HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, GPIO_PIN_SET);
+    // GPIO_InitStructure.Pin = PIN_CDC_LED;
+    // GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+    // GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    // HAL_GPIO_Init(PIN_CDC_LED_PORT, &GPIO_InitStructure);
+
+    // HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, GPIO_PIN_SET);
+    // GPIO_InitStructure.Pin = PIN_MSC_LED;
+    // GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+    // GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    // HAL_GPIO_Init(PIN_MSC_LED_PORT, &GPIO_InitStructure);
+
+    // Reset (to DUT):
+    gpio_init_buffered_dut_pin(nRESET_DIR_PIN_PORT, nRESET_DIR_PIN, nRESET_PIN_PORT, nRESET_PIN, false);
+
+    // Setup the MCO.  MCO2 for UDB
+    // GPIO_InitStructure.Pin = GPIO_PIN_9;
+    // GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    // GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+    // HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
+    output_clock_enable();
 
-    HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, GPIO_PIN_SET);
-    GPIO_InitStructure.Pin = PIN_MSC_LED;
-    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+    // Setup the USB Hub to be "self powered" (very common setting, even if not strictly compliant).
+    GPIO_InitStructure.Pin = USBHUB_SELFPWR_PIN;
+    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;
     GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
-    HAL_GPIO_Init(PIN_MSC_LED_PORT, &GPIO_InitStructure);
+    HAL_GPIO_Init(USBHUB_SELFPWR_PORT, &GPIO_InitStructure);
+    //HAL_GPIO_WritePin(USBHUB_SELFPWR_PORT, USBHUB_SELFPWR_PIN, GPIO_PIN_RESET);
 
-    // reset button configured as gpio open drain output with a pullup
-    HAL_GPIO_WritePin(nRESET_PIN_PORT, nRESET_PIN, GPIO_PIN_SET);
-    GPIO_InitStructure.Pin = nRESET_PIN;
-    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_OD;
-    GPIO_InitStructure.Pull = GPIO_PULLUP;
-    HAL_GPIO_Init(nRESET_PIN_PORT, &GPIO_InitStructure);
+    //Initialize bidir buffer control signals
+    // GPIO_InitStructure.Pin = SWD_BUFFER_EN_PIN;
+    // GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;
+    // GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    // HAL_GPIO_WritePin(SWD_BUFFER_EN_PORT, SWD_BUFFER_EN_PIN, GPIO_PIN_RESET);
+    //HAL_GPIO_Init(SWD_BUFFER_EN_PORT, &GPIO_InitStructure);
+
+    //These are "open drain/open collector" style, with an external buffer.
+    //UDC0_RST_L is configured by the nRESET section above...
+    //UDC0_BOOT_L
+    gpio_init_buffered_dut_pin(UDC0_BOOT_L_DIR_PORT, UDC0_BOOT_L_DIR_PIN, UDC0_BOOT_L_PORT, UDC0_BOOT_L_PIN, false);
+    //UDC0_BUTTON_L
+    gpio_init_buffered_dut_pin(UDC0_BUTTON_L_DIR_PORT, UDC0_BUTTON_L_DIR_PIN, UDC0_BUTTON_L_PORT, UDC0_BUTTON_L_PIN, false);
+    //UDC1_RST
+    gpio_init_buffered_dut_pin(UDC1_RST_DIR_PORT, UDC1_RST_DIR_PIN, UDC1_RST_PORT, UDC1_RST_PIN, true);
+    //UDC1_BOOT
+    gpio_init_buffered_dut_pin(UDC1_BOOT_DIR_PORT, UDC1_BOOT_DIR_PIN, UDC1_BOOT_PORT, UDC1_BOOT_PIN, true);
+    //UDC1_BUTTON
+    gpio_init_buffered_dut_pin(UDC1_BUTTON_DIR_PORT, UDC1_BUTTON_DIR_PIN, UDC1_BUTTON_PORT, UDC1_BUTTON_PIN, true);
 
     // Turn on power to the board. When the target is unpowered
     // it holds the reset line low.
+    // This switched the DUT USB port, using UDC_DUT_USB_EN_L_PIN
     HAL_GPIO_WritePin(POWER_EN_PIN_PORT, POWER_EN_PIN, GPIO_PIN_RESET);
     GPIO_InitStructure.Pin = POWER_EN_PIN;
     GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
     HAL_GPIO_Init(POWER_EN_PIN_PORT, &GPIO_InitStructure);
 
-    // Setup the 8MHz MCO
-    GPIO_InitStructure.Pin = GPIO_PIN_8;
+    //Initialize external relay (turned on)
+    HAL_GPIO_WritePin(UDC_EXT_RELAY_PORT, UDC_EXT_RELAY_PIN, GPIO_PIN_SET);
+    GPIO_InitStructure.Pin = UDC_EXT_RELAY_PIN;
     GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
-    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
-    output_clock_enable();
+    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+    HAL_GPIO_Init(UDC_EXT_RELAY_PORT, &GPIO_InitStructure);
+
+
+    //ToDo(elee): Update delay as needed for core clk speed.  This is the value from the stm32f1.
 
     // Let the voltage rails stabilize.  This is especailly important
     // during software resets, since the target's 3.3v rail can take
@@ -188,22 +351,23 @@
     busy_wait(1000000);
 }
 
+void gpio_set_daplink_run(gpio_led_state_t state)
+{
+}
+
 void gpio_set_hid_led(gpio_led_state_t state)
 {
-    // LED is active low
-    HAL_GPIO_WritePin(PIN_HID_LED_PORT, PIN_HID_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
+    //  LED is active low
 }
 
 void gpio_set_cdc_led(gpio_led_state_t state)
 {
     // LED is active low
-    HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
 }
 
 void gpio_set_msc_led(gpio_led_state_t state)
 {
     // LED is active low
-    HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
 }
 
 uint8_t gpio_get_reset_btn_no_fwrd(void)
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/IO_Config.h new/CA7/source/hic_hal/stm32/stm32mp1xx/IO_Config.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/IO_Config.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/IO_Config.h	2023-12-27 14:15:07.543397210 +0800
@@ -22,11 +22,49 @@
 #ifndef __IO_CONFIG_H__
 #define __IO_CONFIG_H__
 
-#include "stm32f1xx.h"
+#include "stm32mp1xx.h"
 #include "compiler.h"
 #include "daplink.h"
 
-COMPILER_ASSERT(DAPLINK_HIC_ID == DAPLINK_HIC_ID_STM32F103XB);
+COMPILER_ASSERT(DAPLINK_HIC_ID == DAPLINK_HIC_ID_STM32MP153);
+
+//OLED SPI & button Pin
+#define SPI4_CLK_PORT               GPIOE
+#define SPI4_CLK_PIN                GPIO_PIN_2
+#define SPI4_MOSI_PORT              GPIOE
+#define SPI4_MOSI_PIN               GPIO_PIN_6
+#define RESET_OLED_PORT             GPIOE
+#define RESET_OLED_PIN              GPIO_PIN_3
+#define SPI4_MISO_DC_PORT           GPIOE
+#define SPI4_MISO_DC_PIN            GPIO_PIN_5
+#define SPI4_CS_PORT                GPIOE
+#define SPI4_CS_PIN                 GPIO_PIN_4
+#define BUTTON_BACK_PORT            GPIOB
+#define BUTTON_BACK_PIN             GPIO_PIN_9
+#define BUTTON_NEXT_PORT            GPIOC
+#define BUTTON_NEXT_PIN             GPIO_PIN_8
+#define BUTTON_VIEW_PORT            GPIOC
+#define BUTTON_VIEW_PIN             GPIO_PIN_9
+
+//SPI NOR Flash PIN
+#define QUAAD_BK1_NCS_PORT          GPIOB
+#define QUAAD_BK1_NCS_PIN           GPIO_PIN_6
+#define QUAAD_CLK_PORT              GPIOF
+#define QUAAD_CLK_PIN               GPIO_PIN_10
+#define QUAAD_BK1_IO0_PORT          GPIOF
+#define QUAAD_BK1_IO0_PIN           GPIO_PIN_8
+#define QUAAD_BK1_IO1_PORT          GPIOF
+#define QUAAD_BK1_IO1_PIN           GPIO_PIN_9
+#define QUAAD_BK1_IO2_PORT          GPIOF
+#define QUAAD_BK1_IO2_PIN           GPIO_PIN_7
+#define QUAAD_BK1_IO3_PORT          GPIOF
+#define QUAAD_BK1_IO3_PIN           GPIO_PIN_6
+
+//UART(hiburn) PIN
+#define UART4_TX_PORT               GPIOG
+#define UART4_TX_PIN                GPIO_PIN_11
+#define UART4_RX_PORT               GPIOB
+#define UART4_RX_PIN                GPIO_PIN_2
 
 //USB control pin
 #define USB_CONNECT_PORT_ENABLE()    __HAL_RCC_GPIOA_CLK_ENABLE()
@@ -34,53 +72,235 @@
 #define USB_CONNECT_PORT             GPIOA
 #define USB_CONNECT_PIN              GPIO_PIN_15
 #define USB_CONNECT_ON()             (USB_CONNECT_PORT->BSRR = USB_CONNECT_PIN)
-#define USB_CONNECT_OFF()            (USB_CONNECT_PORT->BRR  = USB_CONNECT_PIN)
+#define USB_CONNECT_OFF()            (USB_CONNECT_PORT->BSRR  = ((uint32_t)USB_CONNECT_PIN << 16))
 
 //Connected LED
-#define CONNECTED_LED_PORT           GPIOB
-#define CONNECTED_LED_PIN            GPIO_PIN_6
-#define CONNECTED_LED_PIN_Bit        6
 
+// #define CONNECTED_LED_PORT           GPIOA		//elee: LED1 on eval board
+// #define CONNECTED_LED_PIN            GPIO_PIN_4  //elee: LED1 on eval board
+// #define CONNECTED_LED_PIN_Bit        4
+
+#define CONNECTED_LED_PORT           GPIOG		//elee: LED0 on UDB board
+#define CONNECTED_LED_PIN            GPIO_PIN_0  //elee: LED0 on UDB board
+#define CONNECTED_LED_PIN_Bit        0
+
+// ToDo(elee):
 //When bootloader, disable the target port(not used)
-#define POWER_EN_PIN_PORT            GPIOB
-#define POWER_EN_PIN                 GPIO_PIN_15
-#define POWER_EN_Bit                 15
+#define POWER_EN_PIN_PORT            UDC_DUT_USB_EN_L_PORT
+#define POWER_EN_PIN                 UDC_DUT_USB_EN_L_PIN
+#define POWER_EN_Bit                 UDC_DUT_USB_EN_L_PIN_Bit
 
 // nRESET OUT Pin
-#define nRESET_PIN_PORT              GPIOB
-#define nRESET_PIN                   GPIO_PIN_0
-#define nRESET_PIN_Bit               0
-
-//SWD
-#define SWCLK_TCK_PIN_PORT           GPIOB
-#define SWCLK_TCK_PIN                GPIO_PIN_13
-#define SWCLK_TCK_PIN_Bit            13
-
-#define SWDIO_OUT_PIN_PORT           GPIOB
-#define SWDIO_OUT_PIN                GPIO_PIN_14
-#define SWDIO_OUT_PIN_Bit            14
-
-#define SWDIO_IN_PIN_PORT            GPIOB
-#define SWDIO_IN_PIN                 GPIO_PIN_12
-#define SWDIO_IN_PIN_Bit             12
+// JTAG0_MCU_UDC_RESET_L, UDC0_RST_L
+#define nRESET_PIN_PORT              GPIOI
+#define nRESET_PIN                   GPIO_PIN_4
+#define nRESET_PIN_Bit               4
+
+// nRESET DIR Pin
+// JTAG0_NRESET_DIR
+#define nRESET_DIR_PIN_PORT          GPIOF
+#define nRESET_DIR_PIN               GPIO_PIN_8
+#define nRESET_DIR_PIN_Bit           8
+
+//SWD/JTAG
+// JTAG0_MCU_UDC_TCK_SWDCLK
+#define SWCLK_TCK_PIN_PORT           GPIOA
+#define SWCLK_TCK_PIN                GPIO_PIN_9
+#define SWCLK_TCK_PIN_BIT            9
+
+#define SWDIO_OUT_TMS_PIN_PORT       GPIOA
+#define SWDIO_OUT_TMS_PIN            GPIO_PIN_8
+#define SWDIO_OUT_TMS_PIN_BIT        8
+
+#define SWDIO_IN_PIN_PORT            GPIOA
+#define SWDIO_IN_PIN                 GPIO_PIN_0
+#define SWDIO_IN_PIN_BIT             0
+
+#define SWDIO_INOUT_OE_PORT          GPIOA
+#define SWDIO_INOUT_OE_PIN           GPIO_PIN_3
+#define SWDIO_INOUT_OE_PIN_BIT       3
+
+#define JTAG_TDI_PIN_PORT            GPIOA
+#define JTAG_TDI_PIN                 GPIO_PIN_1
+#define JTAG_TDI_PIN_BIT             1
+
+#define JTAG_TDO_PIN_PORT            GPIOA
+#define JTAG_TDO_PIN                 GPIO_PIN_2
+#define JTAG_TDO_PIN_BIT             2
+
+#define JTAG_TRST_PIN_PORT          GPIOA
+#define JTAG_TRST_PIN               GPIO_PIN_14
+#define JTAG_TPST_PIN_BIT           14
+
+#define JTAG_TARGET_RST_PIN_PORT    GPIOA
+#define JTAG_TARGET_RST_PIN         GPIO_PIN_13
+#define JTAG_TARGET_RST_PIN_BIT     13
 
 //LEDs
-//USB status LED
-#define RUNNING_LED_PORT             GPIOA
-#define RUNNING_LED_PIN              GPIO_PIN_9
-#define RUNNING_LED_Bit              9
-
-#define PIN_HID_LED_PORT             GPIOA
-#define PIN_HID_LED                  GPIO_PIN_9
-#define PIN_HID_LED_Bit              9
-
-#define PIN_CDC_LED_PORT             GPIOA
-#define PIN_CDC_LED                  GPIO_PIN_9
-#define PIN_CDC_LED_Bit              9
-
-#define PIN_MSC_LED_PORT             GPIOA
-#define PIN_MSC_LED                  GPIO_PIN_9
-#define PIN_MSC_LED_Bit              9
+#define OFFLINE_DOWNLOAD_STATUS_LED_PORT GPIOA
+#define OFFLINE_DOWNLOAD_STATUS_LED_PIN  GPIO_PIN_6
+#define OFFLINE_DOWNLOAD_STATUS_LED_Bit  6
+
+#define POWER_SWITCH_PORT  GPIOA
+#define POWER_SWITCH_PIN   GPIO_PIN_7
+#define POWER_SWITCH_Bit   7
+
+//Board ID
+#define BOARD_ID0_PORT     GPIOB
+#define BOARD_ID0_PIN      GPIO_PIN_0
+#define BOARD_ID0_Bit      0
+
+#define BOARD_ID1_PORT     GPIOB
+#define BOARD_ID1_PIN      GPIO_PIN_1
+#define BOARD_ID1_Bit      1
+
+#define BOARD_ID2_PORT     GPIOC
+#define BOARD_ID2_PIN      GPIO_PIN_5
+#define BOARD_ID2_Bit      5
+
+//UDB specific signals
+#define USBHUB_SELFPWR_PORT          GPIOH
+#define USBHUB_SELFPWR_PIN           GPIO_PIN_14
+#define USBHUB_SELFPWR_PIN_Bit       14
+
+
+//DUT USB port power switch
+//VBUS_DUT_EN_L
+#define UDC_DUT_USB_EN_L_PORT        GPIOH
+#define UDC_DUT_USB_EN_L_PIN         GPIO_PIN_10
+#define UDC_DUT_USB_EN_L_PIN_Bit     10
+
+//External power relay control
+//EXT_RELAY_EN
+#define UDC_EXT_RELAY_PORT           GPIOE
+#define UDC_EXT_RELAY_PIN            GPIO_PIN_11
+#define UDC_EXT_RELAY_PIN_Bit        11
+
+
+//GPIO LINES
+//Open Drain/Collector usage: MCU IO has pulldown/up enabled.
+//External buffer set to OUT to pull low/high, and IN to be high-z
+//JTAG0_MCU_UDC_RESET_L, JTAG0_NRESET_DIR
+#define UDC0_RST_L_PORT               nRESET_PIN_PORT
+#define UDC0_RST_L_PIN                nRESET_PIN
+#define UDC0_RST_L_PIN_Bit            nRESET_PIN_Bit
+#define UDC0_RST_L_DIR_PORT           nRESET_DIR_PIN_PORT
+#define UDC0_RST_L_DIR_PIN            nRESET_DIR_PIN
+#define UDC0_RST_L_DIR_PIN_Bit        nRESET_DIR_PIN_Bit
+
+//MCU_BOOT0_UDC_L, BOOT0_DIR
+#define UDC0_BOOT_L_PORT               GPIOE
+#define UDC0_BOOT_L_PIN                GPIO_PIN_7
+#define UDC0_BOOT_L_PIN_Bit            7
+#define UDC0_BOOT_L_DIR_PORT           GPIOE
+#define UDC0_BOOT_L_DIR_PIN            GPIO_PIN_15
+#define UDC0_BOOT_L_DIR_PIN_Bit        15
+
+//MCU_BUT_USR0_UDC_L, BUT_USR0_DIR
+#define UDC0_BUTTON_L_PORT             GPIOE
+#define UDC0_BUTTON_L_PIN              GPIO_PIN_8
+#define UDC0_BUTTON_L_PIN_Bit          8
+#define UDC0_BUTTON_L_DIR_PORT         GPIOF
+#define UDC0_BUTTON_L_DIR_PIN          GPIO_PIN_2
+#define UDC0_BUTTON_L_DIR_PIN_Bit      2
+
+//JTAG1_MCU_UDC_RESET, JTAG1_RESET_DIR
+#define UDC1_RST_PORT               GPIOI
+#define UDC1_RST_PIN                GPIO_PIN_9
+#define UDC1_RST_PIN_Bit            9
+#define UDC1_RST_DIR_PORT           GPIOB
+#define UDC1_RST_DIR_PIN            GPIO_PIN_4
+#define UDC1_RST_DIR_PIN_Bit        4
+
+//MCU_BOOT1_UDC, BOOT1_DIR
+#define UDC1_BOOT_PORT               GPIOE
+#define UDC1_BOOT_PIN                GPIO_PIN_1
+#define UDC1_BOOT_PIN_Bit            1
+#define UDC1_BOOT_DIR_PORT           GPIOE
+#define UDC1_BOOT_DIR_PIN            GPIO_PIN_13
+#define UDC1_BOOT_DIR_PIN_Bit        13
+
+//MCU_BUT_USR1_UDC, BUT_USR1_DIR
+#define UDC1_BUTTON_PORT             GPIOE
+#define UDC1_BUTTON_PIN              GPIO_PIN_3
+#define UDC1_BUTTON_PIN_Bit          3
+#define UDC1_BUTTON_DIR_PORT         GPIOE
+#define UDC1_BUTTON_DIR_PIN          GPIO_PIN_14
+#define UDC1_BUTTON_DIR_PIN_Bit      14
+
+// ehassman
+// From MX_Device.h
+/*-------------------------------- I2C1       --------------------------------*/
+// I2C1
+// #define MX_I2C1                                 1
+/* Pin PB6 */
+#define MX_I2C1_SCL_GPIO_Speed                  GPIO_SPEED_FREQ_LOW
+#define MX_I2C1_SCL_GPIO_FM6                    __NULL
+#define MX_I2C1_SCL_Pin                         PB6
+#define MX_I2C1_SCL_GPIOx                       GPIOB
+#define MX_I2C1_SCL_GPIO_PuPd                   GPIO_NOPULL
+#define MX_I2C1_SCL_GPIO_Pin                    GPIO_PIN_6
+#define MX_I2C1_SCL_GPIO_AF                     GPIO_AF4_I2C1
+#define MX_I2C1_SCL_GPIO_Mode                   GPIO_MODE_AF_OD
+
+/* Pin PB7 */
+#define MX_I2C1_SDA_GPIO_Speed                  GPIO_SPEED_FREQ_LOW
+#define MX_I2C1_SDA_Pin                         PB7
+#define MX_I2C1_SDA_GPIOx                       GPIOB
+#define MX_I2C1_SDA_GPIO_PuPd                   GPIO_NOPULL
+#define MX_I2C1_SDA_GPIO_Pin                    GPIO_PIN_7
+#define MX_I2C1_SDA_GPIO_AF                     GPIO_AF4_I2C1
+#define MX_I2C1_SDA_GPIO_FM7                    __NULL
+#define MX_I2C1_SDA_GPIO_Mode                   GPIO_MODE_AF_OD
+
+
+// I2C2
+#define MX_I2C2                                 1
+
+/* Pin PF1 */
+#define MX_I2C2_SCL_GPIO_Speed                  GPIO_SPEED_FREQ_LOW
+#define MX_I2C2_SCL_GPIO_FM6                    __NULL
+#define MX_I2C2_SCL_Pin                         PF1
+#define MX_I2C2_SCL_GPIOx                       GPIOF
+#define MX_I2C2_SCL_GPIO_PuPd                   GPIO_NOPULL
+#define MX_I2C2_SCL_GPIO_Pin                    GPIO_PIN_1
+#define MX_I2C2_SCL_GPIO_AF                     GPIO_AF4_I2C2
+#define MX_I2C2_SCL_GPIO_Mode                   GPIO_MODE_AF_OD
+
+/* Pin PF0 */
+#define MX_I2C2_SDA_GPIO_Speed                  GPIO_SPEED_FREQ_LOW
+#define MX_I2C2_SDA_Pin                         PF0
+#define MX_I2C2_SDA_GPIOx                       GPIOF
+#define MX_I2C2_SDA_GPIO_PuPd                   GPIO_NOPULL
+#define MX_I2C2_SDA_GPIO_Pin                    GPIO_PIN_0
+#define MX_I2C2_SDA_GPIO_AF                     GPIO_AF4_I2C2
+#define MX_I2C2_SDA_GPIO_FM7                    __NULL
+#define MX_I2C2_SDA_GPIO_Mode                   GPIO_MODE_AF_OD
+
+
+/*---------------------------- Clock Configuration ---------------------------*/
+
+#define MX_LSI_VALUE                            32000
+#define MX_LSE_VALUE                            32768
+#define MX_HSI_VALUE                            64000000
+#define MX_HSE_VALUE                            25000000
+#define MX_EXTERNAL_CLOCK_VALUE                 12288000
+#define MX_PLLDSIFreq_Value                     500000000
+#define MX_SYSCLKFreq_VALUE                     400000000
+#define MX_HCLKFreq_Value                       100000000
+#define MX_CortexFreq_Value                     400000000
+#define MX_APB1Freq_Value                       25000000
+#define MX_APB2Freq_Value                       25000000
+#define MX_CECFreq_Value                        32000
+#define MX_RTCFreq_Value                        32000
+#define MX_USBFreq_Value                        400000000
+#define MX_WatchDogFreq_Value                   32000
+#define MX_DSIFreq_Value                        96000000
+#define MX_DSIPHYCLKFreq_Value                  96000000
+#define MX_DSITXEscFreq_Value                   20000000
+#define MX_SPDIFRXFreq_Value                    400000000
+#define MX_MCO1PinFreq_Value                    64000000
+#define MX_MCO2PinFreq_Value                    400000000
 
 
 #endif
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/read_uid.c new/CA7/source/hic_hal/stm32/stm32mp1xx/read_uid.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/read_uid.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/read_uid.c	2023-05-25 15:09:49.000000000 +0800
@@ -18,18 +18,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
- 
-#include "stm32f1xx.h"
+
+#include "stm32mp1xx.h"
 #include "read_uid.h"
 
 void read_unique_id(uint32_t *id)
 {
-    uint32_t Device_Serial0, Device_Serial1, Device_Serial2;    
-    
-    Device_Serial0 = *(uint32_t*)(0x1FFFF7E8); 
-    Device_Serial1 = *(uint32_t*)(0x1FFFF7EC); 
-    Device_Serial2 = *(uint32_t*)(0x1FFFF7F0);    
-  
+    uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
+
+    Device_Serial0 = *(uint32_t*)(0x5C005234);
+    Device_Serial1 = *(uint32_t*)(0x5C005238);
+    Device_Serial2 = *(uint32_t*)(0x5C00523C);
+
     id[0] = Device_Serial0;
     id[1] = Device_Serial1;
     id[2] = Device_Serial2;
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/sdk.c new/CA7/source/hic_hal/stm32/stm32mp1xx/sdk.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/sdk.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/sdk.c	2023-05-25 15:09:49.000000000 +0800
@@ -19,17 +19,36 @@
  * limitations under the License.
  */
 
-#include "stm32f1xx.h"
+#include "stm32mp1xx.h"
+#include "stm32mp1xx_hal.h"
+#ifndef HISPARK_BOOT
 #include "DAP_config.h"
 #include "gpio.h"
 #include "daplink.h"
+#endif
 #include "util.h"
-#include "cortex_m.h"
+#include "sdk.h"
+#ifndef HISPARK_BOOT
+#include "interrupt.h"
+#endif
+#include "oled.h"
+#include "display.h"
+#include "key.h"
+
+
+extern void SystemCoreClockUpdate(void);
+extern void MX_USB_OTG_FS_PCD_Init(void);
+extern void MX_USB_OTG_HS_PCD_Init(void);
+void SystemClock_Config(void);
+void Error_Handler(void);
 
 TIM_HandleTypeDef timer;
 uint32_t time_count;
 
-static uint32_t tim2_clk_div(uint32_t apb1clkdiv);
+void MX_GPIO_Init(void)
+{
+}
+
 
 /**
     * @brief  Switch the PLL source from HSI to HSE bypass, and select the PLL as SYSCLK
@@ -50,84 +69,42 @@
   */
 void sdk_init()
 {
-    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
-    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
-
-    SystemCoreClockUpdate();
+    //todo: elee:  Review this some more.  For now just call the stm32cube startup files (from the cube generated main).
     HAL_Init();
+    /* USER CODE BEGIN Init */
+    /* USER CODE END Init */
+    /* Configure the system clock */
+#ifndef HISPARK_BOOT
+    SystemClock_Config();
+    SystemCoreClockUpdate();
 
-    /* Select HSI as system clock source to allow modification of the PLL configuration */
-    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;
-    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
-    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) {
-        /* Initialization Error */
-        util_assert(0);
-    }
-
-    /* Enable HSE bypass Oscillator, select it as PLL source and finally activate the PLL */
-    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
-    RCC_OscInitStruct.HSEState = RCC_CR_HSEON;
-    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
-    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
-    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
-    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
-    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
-        /* Initialization Error */
-        util_assert(0);
-    }
-
-    /* Select the PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
-    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
-    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
-    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
-    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
-    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
-    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
-        /* Initialization Error */
-        util_assert(0);
-    }
+    IRQ_Init();
+#endif
+    /* USER CODE BEGIN SysInit */
+    /* USER CODE END SysInit */
+    /* Initialize all configured peripherals */
+    MX_GPIO_Init();
+
+    OledInit();
+    KeyInit();
+
+#ifndef HISPARK_BOOT
+    pin_out_init(CONNECTED_LED_PORT, CONNECTED_LED_PIN_Bit);
+    CONNECTED_LED_PORT->BSRR = CONNECTED_LED_PIN;
+
+    //elee: toggle the pin, see the LED do something.
+    HAL_Delay(100);
+    CONNECTED_LED_PORT->BSRR = (CONNECTED_LED_PIN << 16);
+#endif
 }
 
 HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
 {
-    HAL_StatusTypeDef ret;
-    RCC_ClkInitTypeDef clk_init;
-    uint32_t unused;
-    uint32_t prescaler;
-    uint32_t source_clock;
-
-    HAL_RCC_GetClockConfig(&clk_init, &unused);
-
-    /* Compute the prescaler value to have TIMx counter clock equal to 4000 Hz */
-    source_clock = SystemCoreClock / tim2_clk_div(clk_init.APB1CLKDivider);
-    prescaler = (uint32_t)(source_clock / 4000) - 1;
-
-    /* Set TIMx instance */
-    timer.Instance = TIM2;
-
-    timer.Init.Period            = 0xFFFF;
-    timer.Init.Prescaler         = prescaler;
-    timer.Init.ClockDivision     = 0;
-    timer.Init.CounterMode       = TIM_COUNTERMODE_UP;
-    timer.Init.RepetitionCounter = 0;
-
-    __HAL_RCC_TIM2_CLK_ENABLE();
-
-    ret = HAL_TIM_Base_DeInit(&timer);
-    if (ret != HAL_OK) {
-        return ret;
-    }
-
-    time_count = 0;
-    ret = HAL_TIM_Base_Init(&timer);
-    if (ret != HAL_OK) {
-        return ret;
-    }
-
-    ret = HAL_TIM_Base_Start(&timer);
-    if (ret != HAL_OK) {
-        return ret;
-    }
+    STGENC_TypeDef *stgenc = (STGENC_TypeDef *)STGENC;
+    stgenc->CNTCR = 0;
+    stgenc->CNTCVL = 0;
+    stgenc->CNTCVU = 0;
+    stgenc->CNTCR = 1;
 
     return HAL_OK;
 }
@@ -140,11 +117,29 @@
 
 uint32_t HAL_GetTick(void)
 {
-    cortex_int_state_t state;
-    state = cortex_int_get_and_disable();
-    const uint32_t ticks = __HAL_TIM_GET_COUNTER(&timer) / 4;
-    time_count += (ticks - time_count) & 0x3FFF;
-    cortex_int_restore(state);
+    //HAL_InitTick在系统HSE起来前就被调用，因此使用了HSI的时钟
+    STGENC_TypeDef *stgenc = (STGENC_TypeDef *)STGENC;
+    const uint32_t ticks = HSI_VALUE / 1000;
+    uint64_t ts = stgenc->CNTCVU;
+    ts <<= 32;
+    ts += stgenc->CNTCVL;
+    ts /= ticks;
+    time_count = (uint32_t)(ts & 0xFFFFFFFF);
+
+    return time_count;
+}
+
+uint32_t HAL_GetTickUs(void)
+{
+    //HAL_InitTick在系统HSE起来前就被调用，因此使用了HSI的时钟
+    STGENC_TypeDef *stgenc = (STGENC_TypeDef *)STGENC;
+    const uint32_t ticks = HSI_VALUE / 1000000;
+    uint64_t ts = stgenc->CNTCVU;
+    ts <<= 32;
+    ts += stgenc->CNTCVL;
+    ts /= ticks;
+    time_count = (uint32_t)(ts & 0xFFFFFFFF);
+
     return time_count;
 }
 
@@ -158,18 +153,122 @@
     HAL_TIM_Base_Stop(&timer);
 }
 
-static uint32_t tim2_clk_div(uint32_t apb1clkdiv)
+/**
+  * @brief System Clock Configuration
+  * @retval None
+  */
+void SystemClock_Config(void)
 {
-    switch (apb1clkdiv) {
-        case RCC_CFGR_PPRE1_DIV2:
-            return 1;
-        case RCC_CFGR_PPRE1_DIV4:
-            return 2;
-        case RCC_CFGR_PPRE1_DIV8:
-            return 4;
-        case RCC_CFGR_PPRE1_DIV16:
-            return 8;
-        default:
-            return 1;
-    }
+  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
+  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
+
+  HAL_RCC_DeInit();
+  /**Configure LSE Drive Capability
+  */
+  HAL_PWR_EnableBkUpAccess();
+  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_MEDIUMHIGH);
+
+  /**Initializes the CPU, AHB and APB busses clocks
+  */
+  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_HSE;
+  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
+  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
+  RCC_OscInitStruct.HSICalibrationValue = 16;
+  RCC_OscInitStruct.HSIDivValue = RCC_HSI_DIV1;
+
+  /**PLL1 Config
+  */
+  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL.PLLSource = RCC_PLL12SOURCE_HSE;
+  RCC_OscInitStruct.PLL.PLLM = 3;
+  RCC_OscInitStruct.PLL.PLLN = 100;
+  RCC_OscInitStruct.PLL.PLLP = 1;
+  RCC_OscInitStruct.PLL.PLLQ = 1;
+  RCC_OscInitStruct.PLL.PLLR = 1;
+  RCC_OscInitStruct.PLL.PLLFRACV = 0;
+  RCC_OscInitStruct.PLL.PLLMODE = RCC_PLL_FRACTIONAL;
+  RCC_OscInitStruct.PLL.RPDFN_DIS = RCC_RPDFN_DIS_DISABLED;
+  RCC_OscInitStruct.PLL.TPDFN_DIS = RCC_TPDFN_DIS_DISABLED;
+
+    /**PLL2 Config
+    */
+  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLL12SOURCE_HSE;
+  RCC_OscInitStruct.PLL2.PLLM = 3;
+  RCC_OscInitStruct.PLL2.PLLN = 66;
+  RCC_OscInitStruct.PLL2.PLLP = 2;
+  RCC_OscInitStruct.PLL2.PLLQ = 1;
+  RCC_OscInitStruct.PLL2.PLLR = 1;
+  RCC_OscInitStruct.PLL2.PLLFRACV = 5120;
+  RCC_OscInitStruct.PLL2.PLLMODE = RCC_PLL_FRACTIONAL;
+  RCC_OscInitStruct.PLL2.RPDFN_DIS = RCC_RPDFN_DIS_DISABLED;
+  RCC_OscInitStruct.PLL2.TPDFN_DIS = RCC_TPDFN_DIS_DISABLED;
+
+    /**PLL3 Config
+    */
+  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLL3SOURCE_HSE;
+  RCC_OscInitStruct.PLL3.PLLM = 2;
+  RCC_OscInitStruct.PLL3.PLLN = 34;
+  RCC_OscInitStruct.PLL3.PLLP = 2;
+  RCC_OscInitStruct.PLL3.PLLQ = 17;
+  RCC_OscInitStruct.PLL3.PLLR = 37;
+  RCC_OscInitStruct.PLL3.PLLRGE = RCC_PLL3IFRANGE_1;
+  RCC_OscInitStruct.PLL3.PLLFRACV = 0x1A04;
+  RCC_OscInitStruct.PLL3.PLLMODE = RCC_PLL_FRACTIONAL;
+  RCC_OscInitStruct.PLL3.RPDFN_DIS = RCC_RPDFN_DIS_DISABLED;
+  RCC_OscInitStruct.PLL3.TPDFN_DIS = RCC_TPDFN_DIS_DISABLED;
+
+    /**PLL4 Config
+    */
+  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLL4SOURCE_HSE;
+  RCC_OscInitStruct.PLL4.PLLM = 4;
+  RCC_OscInitStruct.PLL4.PLLN = 99;
+  RCC_OscInitStruct.PLL4.PLLP = 6;
+  RCC_OscInitStruct.PLL4.PLLQ = 8;
+  RCC_OscInitStruct.PLL4.PLLR = 8;
+  RCC_OscInitStruct.PLL4.PLLRGE = RCC_PLL4IFRANGE_0;
+  RCC_OscInitStruct.PLL4.PLLFRACV = 0;
+  RCC_OscInitStruct.PLL4.PLLMODE = RCC_PLL_INTEGER;
+  RCC_OscInitStruct.PLL4.RPDFN_DIS = RCC_RPDFN_DIS_DISABLED;
+  RCC_OscInitStruct.PLL4.TPDFN_DIS = RCC_TPDFN_DIS_DISABLED;
+
+  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
+  {
+  Error_Handler();
+  }
+  /**RCC Clock Config
+  */
+  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_ACLK
+                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
+                |RCC_CLOCKTYPE_PCLK3|RCC_CLOCKTYPE_PCLK4
+                |RCC_CLOCKTYPE_PCLK5|RCC_CLOCKTYPE_MPU;
+  RCC_ClkInitStruct.MPUInit.MPU_Clock = RCC_MPUSOURCE_PLL1;
+  RCC_ClkInitStruct.MPUInit.MPU_Div = RCC_MPU_DIV2;
+  RCC_ClkInitStruct.AXISSInit.AXI_Clock = RCC_AXISSOURCE_PLL2;
+  RCC_ClkInitStruct.AXISSInit.AXI_Div = RCC_AXI_DIV1;
+  RCC_ClkInitStruct.MCUInit.MCU_Clock = RCC_MCUSSOURCE_PLL3;
+  RCC_ClkInitStruct.MCUInit.MCU_Div = RCC_MCU_DIV1;
+  RCC_ClkInitStruct.APB4_Div = RCC_APB4_DIV2;
+  RCC_ClkInitStruct.APB5_Div = RCC_APB5_DIV4;
+  RCC_ClkInitStruct.APB1_Div = RCC_APB1_DIV2;
+  RCC_ClkInitStruct.APB2_Div = RCC_APB2_DIV2;
+  RCC_ClkInitStruct.APB3_Div = RCC_APB3_DIV2;
+
+  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
+  {
+    Error_Handler();
+  }
+
+  /**Set the HSE division factor for RTC clock
+  */
+ // __HAL_RCC_RTC_HSEDIV(24);
 }
+
+
+void Error_Handler(void)
+{
+  /* USER CODE BEGIN Error_Handler_Debug */
+  /* USER CODE END Error_Handler_Debug */
+}
\ No newline at end of file
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp153dxx_ca7.h new/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp153dxx_ca7.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp153dxx_ca7.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp153dxx_ca7.h	2023-05-25 15:09:49.000000000 +0800
@@ -269,8 +269,13 @@
 #define GIC_DISTRIBUTOR_BASE GIC_BASE
 #define GIC_INTERFACE_BASE   (GIC_BASE+0x1000)
 
+#ifdef HISPARK_TRACE
+#include "cmsis_compiler.h"
+#endif
 #include "core_ca.h"
+#ifndef HISPARK_TRACE
 #include "system_stm32mp1xx_A7.h"
+#endif
 
 
 
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp1xx.h new/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp1xx.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp1xx.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/stm32mp1xx.h	2023-05-25 15:09:49.000000000 +0800
@@ -42,6 +42,10 @@
  extern "C" {
 #endif /* __cplusplus */
 
+#ifdef HISPARK_TRACE
+extern unsigned int SystemCoreClock;
+#endif
+
 /** @addtogroup Library_configuration_section
   * @{
   */
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/STM32MP1xx_HAL_Driver/stm32mp1xx_hal_conf.h new/CA7/source/hic_hal/stm32/stm32mp1xx/STM32MP1xx_HAL_Driver/stm32mp1xx_hal_conf.h
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/STM32MP1xx_HAL_Driver/stm32mp1xx_hal_conf.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/STM32MP1xx_HAL_Driver/stm32mp1xx_hal_conf.h	2023-05-25 15:09:49.000000000 +0800
@@ -46,31 +46,47 @@
 /*#define HAL_DFSDM_MODULE_ENABLED   */
 /*#define HAL_FDCAN_MODULE_ENABLED   */
 /*#define HAL_HASH_MODULE_ENABLED   */
+#define HAL_HSEM_MODULE_ENABLED
 /*#define HAL_I2C_MODULE_ENABLED   */
+/*#define HAL_I2S_MODULE_ENABLED   */
 /*#define HAL_IPCC_MODULE_ENABLED   */
 /*#define HAL_LPTIM_MODULE_ENABLED   */
-/*#define HAL_QSPI_MODULE_ENABLED   */
+#define HAL_QSPI_MODULE_ENABLED
 /*#define HAL_RNG_MODULE_ENABLED   */
 /*#define HAL_SAI_MODULE_ENABLED   */
 /*#define HAL_SD_MODULE_ENABLED   */
-/*#define HAL_MMC_MODULE_ENABLED   */
+/*#define HAL_SMARTCARD_MODULE_ENABLED   */
 /*#define HAL_RTC_MODULE_ENABLED   */
 /*#define HAL_SMBUS_MODULE_ENABLED   */
 /*#define HAL_SPDIFRX_MODULE_ENABLED   */
 /*#define HAL_SPI_MODULE_ENABLED   */
-/*#define HAL_TIM_MODULE_ENABLED   */
-/*#define HAL_UART_MODULE_ENABLED   */
-/*#define HAL_USART_MODULE_ENABLED   */
+/*#define HAL_SRAM_MODULE_ENABLED   */
+#define HAL_TIM_MODULE_ENABLED
+ #define HAL_UART_MODULE_ENABLED
+#define HAL_USART_MODULE_ENABLED
 /*#define HAL_WWDG_MODULE_ENABLED   */
-#define HAL_EXTI_MODULE_ENABLED
-#define HAL_HSEM_MODULE_ENABLED
 #define HAL_GPIO_MODULE_ENABLED
+#define HAL_EXTI_MODULE_ENABLED
 #define HAL_DMA_MODULE_ENABLED
-/*#define HAL_MDMA_MODULE_ENABLED   */
+#define HAL_MDMA_MODULE_ENABLED
 #define HAL_RCC_MODULE_ENABLED
 #define HAL_PWR_MODULE_ENABLED
 #define HAL_CORTEX_MODULE_ENABLED
 
+/* ########################## Register Callbacks selection ############################## */
+/**
+  * @brief This is the list of modules where register callback can be used
+  */
+#define USE_HAL_ADC_REGISTER_CALLBACKS    0u
+#define USE_HAL_CEC_REGISTER_CALLBACKS    0u
+#define USE_HAL_DAC_REGISTER_CALLBACKS    0u
+#define USE_HAL_I2C_REGISTER_CALLBACKS    0u
+#define USE_HAL_RNG_REGISTER_CALLBACKS    0u
+#define USE_HAL_SPI_REGISTER_CALLBACKS    0u
+#define USE_HAL_UART_REGISTER_CALLBACKS   0u
+#define USE_HAL_USART_REGISTER_CALLBACKS  0u
+#define USE_HAL_WWDG_REGISTER_CALLBACKS   0u
+
 /* ########################## Oscillator Values adaptation ####################*/
 /**
   * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
@@ -95,6 +111,14 @@
 #endif /* HSI_VALUE */
 
 /**
+  * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup
+  *        Timeout value
+  */
+#if !defined  (HSI_STARTUP_TIMEOUT)
+  #define HSI_STARTUP_TIMEOUT  5000U     /*!< Time out for HSI start up */
+#endif /* HSI_STARTUP_TIMEOUT */
+
+/**
   * @brief Internal Low Speed oscillator (LSI) value.
   */
 #if !defined  (LSI_VALUE) 
@@ -124,6 +148,9 @@
 #endif /* CSI_VALUE */
 
 /**
+  * @brief External clock source for I2S peripheral
+  *        This value is used by the I2S HAL module to compute the I2S clock source 
+  *        frequency, this source is inserted directly through I2S_CKIN pad. 
   */
 #if !defined  (EXTERNAL_CLOCK_VALUE)
   #define EXTERNAL_CLOCK_VALUE    12288000U /*!< Value of the External clock in Hz*/
@@ -212,10 +239,6 @@
  #include "stm32mp1xx_hal_dfsdm.h"
 #endif /* HAL_DFSDM_MODULE_ENABLED */
 
-#ifdef HAL_EXTI_MODULE_ENABLED
- #include "stm32mp1xx_hal_exti.h"
-#endif /* HAL_EXTI_MODULE_ENABLED */
-
 #ifdef HAL_FDCAN_MODULE_ENABLED
  #include "stm32mp1xx_hal_fdcan.h"
 #endif /* HAL_FDCAN_MODULE_ENABLED */
@@ -248,6 +271,10 @@
  #include "stm32mp1xx_hal_rng.h"
 #endif /* HAL_RNG_MODULE_ENABLED */
 
+#ifdef HAL_RTC_MODULE_ENABLED
+ #include "stm32mp1xx_hal_rtc.h"
+#endif /* HAL_RTC_MODULE_ENABLED */
+
 #ifdef HAL_SAI_MODULE_ENABLED
  #include "stm32mp1xx_hal_sai.h"
 #endif /* HAL_SAI_MODULE_ENABLED */
@@ -256,9 +283,9 @@
  #include "stm32mp1xx_hal_sd.h"
 #endif /* HAL_SD_MODULE_ENABLED */
 
-#ifdef HAL_MMC_MODULE_ENABLED
- #include "stm32mp1xx_hal_mmc.h"
-#endif /* HAL_MMC_MODULE_ENABLED */
+#ifdef HAL_SMARTCARD_MODULE_ENABLED
+  #include "stm32mp1xx_hal_smartcard.h"
+#endif /* HAL_SMARTCARD_MODULE_ENABLED */
 
 #ifdef HAL_SMBUS_MODULE_ENABLED
  #include "stm32mp1xx_hal_smbus.h"
@@ -272,9 +299,9 @@
  #include "stm32mp1xx_hal_spi.h"
 #endif /* HAL_SPI_MODULE_ENABLED */
 
-#ifdef HAL_RTC_MODULE_ENABLED
- #include "stm32mp1xx_hal_rtc.h"
-#endif /* HAL_RTC_MODULE_ENABLED */
+#ifdef HAL_SRAM_MODULE_ENABLED
+ #include "stm32mp1xx_hal_sram.h"
+#endif /* HAL_SRAM_MODULE_ENABLED */
 
 #ifdef HAL_TIM_MODULE_ENABLED
  #include "stm32mp1xx_hal_tim.h"
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/uart.c new/CA7/source/hic_hal/stm32/stm32mp1xx/uart.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/uart.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/uart.c	2023-12-27 14:15:37.337658991 +0800
@@ -21,70 +21,113 @@
 
 #include "string.h"
 
-#include "stm32f1xx.h"
+#include "stm32mp1xx.h"
 #include "uart.h"
 #include "gpio.h"
 #include "util.h"
 #include "circ_buf.h"
+#ifdef HISPARK_TRACE
+#include "interrupt.h"
+#include "settings.h"
+#endif
 #include "IO_Config.h"
 
-// For usart
-#define CDC_UART                     USART2
-#define CDC_UART_ENABLE()            __HAL_RCC_USART2_CLK_ENABLE()
-#define CDC_UART_DISABLE()           __HAL_RCC_USART2_CLK_DISABLE()
-#define CDC_UART_IRQn                USART2_IRQn
-#define CDC_UART_IRQn_Handler        USART2_IRQHandler
-
-#define UART_PINS_PORT_ENABLE()      __HAL_RCC_GPIOA_CLK_ENABLE()
-#define UART_PINS_PORT_DISABLE()     __HAL_RCC_GPIOA_CLK_DISABLE()
-
-#define UART_TX_PORT                 GPIOA
-#define UART_TX_PIN                  GPIO_PIN_2
-
-#define UART_RX_PORT                 GPIOA
-#define UART_RX_PIN                  GPIO_PIN_3
-
-#define UART_CTS_PORT                GPIOA
-#define UART_CTS_PIN                 GPIO_PIN_0
-
-#define UART_RTS_PORT                GPIOA
-#define UART_RTS_PIN                 GPIO_PIN_1
+// UDB: USART3, UART0_MCU_UDC_TXD or UART0_UDC_TXD
+// pd8=USART3_TX pd9=USART3_RX
 
+#define CDC_UART                     UART4
+#define CDC_UART_ENABLE()            __HAL_RCC_UART4_CLK_ENABLE()
+#define CDC_UART_DISABLE()           __HAL_RCC_UART4_CLK_DISABLE()
+#define CDC_UART_IRQn                UART4_IRQn
+//#define CDC_UART_IRQn_Handler        UART4_IRQHandler
+
+#define CDC_UART_RXFIFO_THRESHOLD   UART_RXFIFO_THRESHOLD_3_4
+#define UART_PINS_PORT_ENABLE()      do{__HAL_RCC_GPIOG_CLK_ENABLE();__HAL_RCC_GPIOB_CLK_ENABLE();}while(0)
+#define UART_PINS_PORT_DISABLE()     do{__HAL_RCC_GPIOG_CLK_DISABLE();__HAL_RCC_GPIOB_CLK_DISABLE();}while(0)
+
+#define UART_TX_PORT                 GPIOG
+#define UART_TX_PIN                  GPIO_PIN_11
+#define UART_TX_ALTFUNC              GPIO_AF6_UART4  //Select the correct alt func
+
+#define UART_RX_PORT                 GPIOB
+#define UART_RX_PIN                  GPIO_PIN_2
+#define UART_RX_ALTFUNC              GPIO_AF8_UART4  //Select the correct alt func
+
+//ToDo(elee): CTS/RTS not used on main UDC uarts.  How to ensure they are not used?  Just don't set the Alternate function?
+// Just choose one of the possible pins for CTS/RTS for usart3 for now.
+//#define UART_CTS_PORT                GPIOD
+//#define UART_CTS_PIN                 GPIO_PIN_11
+//
+//#define UART_RTS_PORT                GPIOD
+//#define UART_RTS_PIN                 GPIO_PIN_12
+#define CDC_UART_BAUDRATE_DEFAULT   (115200)
 
 #define RX_OVRF_MSG         "<DAPLink:Overflow>\n"
 #define RX_OVRF_MSG_SIZE    (sizeof(RX_OVRF_MSG) - 1)
 #define BUFFER_SIZE         (512)
 
-circ_buf_t write_buffer;
-uint8_t write_buffer_data[BUFFER_SIZE];
-circ_buf_t read_buffer;
-uint8_t read_buffer_data[BUFFER_SIZE];
+static circ_buf_t s_write_buffer;
+static uint8_t s_write_buffer_data[BUFFER_SIZE];
+static circ_buf_t s_read_buffer;
+static uint8_t s_read_buffer_data[BUFFER_SIZE];
 
-static UART_Configuration configuration = {
-    .Baudrate = 9600,
+static UART_Configuration s_configuration =
+{
+    .Baudrate = CDC_UART_BAUDRATE_DEFAULT,
     .DataBits = UART_DATA_BITS_8,
     .Parity = UART_PARITY_NONE,
     .StopBits = UART_STOP_BITS_1,
     .FlowControl = UART_FLOW_CONTROL_NONE,
 };
 
-extern uint32_t SystemCoreClock;
-
+static UART_HandleTypeDef s_uart_handle;
 
+void CDC_UART_IRQn_Handler(void);
 
 static void clear_buffers(void)
 {
-    circ_buf_init(&write_buffer, write_buffer_data, sizeof(write_buffer_data));
-    circ_buf_init(&read_buffer, read_buffer_data, sizeof(read_buffer_data));
+    circ_buf_init(&s_write_buffer, s_write_buffer_data, sizeof(s_write_buffer_data));
+    circ_buf_init(&s_read_buffer, s_read_buffer_data, sizeof(s_read_buffer_data));
+}
+
+static void uart_read_from_fifo_in_isr(void)
+{
+    uint16_t size = circ_buf_count_free(&s_read_buffer);
+    uint8_t data;
+    while (CDC_UART->ISR & USART_ISR_RXNE_RXFNE)
+    {
+        data = CDC_UART->RDR;
+        if (size > RX_OVRF_MSG_SIZE)
+        {
+            circ_buf_push(&s_read_buffer, data);
+        }
+        else if (config_get_overflow_detect())
+        {
+            if (RX_OVRF_MSG_SIZE == size)
+            {
+                circ_buf_write(&s_read_buffer, (uint8_t*)RX_OVRF_MSG, RX_OVRF_MSG_SIZE);
+            }
+            else
+            {
+                // drop characters
+            }
+            break;
+        }
+        else
+        {
+            // drop characters
+            break;
+        }
+        --size;
+    }
+
+    main_cdc_send_event();
 }
 
 int32_t uart_initialize(void)
 {
     GPIO_InitTypeDef GPIO_InitStructure;
 
-    CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
-    clear_buffers();
-
     CDC_UART_ENABLE();
     UART_PINS_PORT_ENABLE();
 
@@ -92,171 +135,213 @@
     GPIO_InitStructure.Pin = UART_TX_PIN;
     GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
+	GPIO_InitStructure.Pull = GPIO_NOPULL;
+	GPIO_InitStructure.Alternate = UART_TX_ALTFUNC;
     HAL_GPIO_Init(UART_TX_PORT, &GPIO_InitStructure);
     //RX pin
     GPIO_InitStructure.Pin = UART_RX_PIN;
     GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+    GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStructure.Pull = GPIO_PULLUP;
+	  GPIO_InitStructure.Alternate = UART_RX_ALTFUNC;
     HAL_GPIO_Init(UART_RX_PORT, &GPIO_InitStructure);
-    //CTS pin, input
-    GPIO_InitStructure.Pin = UART_CTS_PIN;
-    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
-    GPIO_InitStructure.Pull = GPIO_PULLUP;
-    HAL_GPIO_Init(UART_CTS_PORT, &GPIO_InitStructure);
-    //RTS pin, output low
-    HAL_GPIO_WritePin(UART_RTS_PORT, UART_RTS_PIN, GPIO_PIN_RESET);
-    GPIO_InitStructure.Pin = UART_RTS_PIN;
-    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
-    HAL_GPIO_Init(UART_RTS_PORT, &GPIO_InitStructure);
+//    //CTS pin, input
+//    GPIO_InitStructure.Pin = UART_CTS_PIN;
+//    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+//    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
+//    GPIO_InitStructure.Pull = GPIO_PULLUP;
+//    //GPIO_InitStructure.Alternate = UART_ALTFUNC;  //cts is not used?
+//    HAL_GPIO_Init(UART_CTS_PORT, &GPIO_InitStructure);
+//    //RTS pin, output low
+//    HAL_GPIO_WritePin(UART_RTS_PORT, UART_RTS_PIN, GPIO_PIN_RESET);
+//    GPIO_InitStructure.Pin = UART_RTS_PIN;
+//    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
+//    GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
+//	GPIO_InitStructure.Pull = GPIO_NOPULL;
+//    //GPIO_InitStructure.Alternate = UART_ALTFUNC;  //rts is not used?
+//    HAL_GPIO_Init(UART_RTS_PORT, &GPIO_InitStructure);
 
-    NVIC_EnableIRQ(CDC_UART_IRQn);
+//    NVIC_EnableIRQ(CDC_UART_IRQn);
+    IRQ_Enable(UART4_IRQn, 6, CDC_UART_IRQn_Handler);
 
     return 1;
 }
 
 int32_t uart_uninitialize(void)
 {
-    CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
+    NVIC_DisableIRQ(CDC_UART_IRQn);
     clear_buffers();
+
+    HAL_GPIO_DeInit(UART_RX_PORT, UART_RX_PIN);
+    HAL_GPIO_DeInit(UART_TX_PORT, UART_TX_PIN);
+
+    CDC_UART_DISABLE();
+
     return 1;
 }
 
 int32_t uart_reset(void)
 {
     const uint32_t cr1 = CDC_UART->CR1;
-    CDC_UART->CR1 = cr1 & ~(USART_IT_TXE | USART_IT_RXNE);
+    CDC_UART->CR1 = cr1 & ~(USART_ISR_TXE_TXFNF | USART_ISR_RXNE_RXFNE);
     clear_buffers();
-    CDC_UART->CR1 = cr1 & ~USART_IT_TXE;
+    CDC_UART->CR1 = cr1 & ~USART_ISR_TXE_TXFNF;
     return 1;
 }
 
 int32_t uart_set_configuration(UART_Configuration *config)
 {
-    UART_HandleTypeDef uart_handle;
     HAL_StatusTypeDef status;
 
-    memset(&uart_handle, 0, sizeof(uart_handle));
-    uart_handle.Instance = CDC_UART;
+    s_uart_handle.Instance = CDC_UART;
+    status = HAL_UART_DeInit(&s_uart_handle);
 
+    util_assert(status != HAL_ERROR);
     // parity
-    configuration.Parity = config->Parity;
-    if(config->Parity == UART_PARITY_ODD) {
-        uart_handle.Init.Parity = HAL_UART_PARITY_ODD;
-    } else if(config->Parity == UART_PARITY_EVEN) {
-        uart_handle.Init.Parity = HAL_UART_PARITY_EVEN;
-    } else if(config->Parity == UART_PARITY_NONE) {
-        uart_handle.Init.Parity = HAL_UART_PARITY_NONE;
+    s_configuration.Parity = config->Parity;
+    if(config->Parity == UART_PARITY_ODD_DAPLINK) {
+        s_uart_handle.Init.Parity = UART_PARITY_ODD;
+    } else if(config->Parity == UART_PARITY_EVEN_DAPLINK) {
+        s_uart_handle.Init.Parity = UART_PARITY_EVEN;
+    } else if(config->Parity == UART_PARITY_NONE_DAPLINK) {
+        s_uart_handle.Init.Parity = UART_PARITY_NONE;
     } else {   //Other not support
-        uart_handle.Init.Parity = HAL_UART_PARITY_NONE;
-        configuration.Parity = UART_PARITY_NONE;
+        // not support other parity
+        util_assert(false);
     }
 
     // stop bits
-    configuration.StopBits = config->StopBits;
+    s_configuration.StopBits = config->StopBits;
     if(config->StopBits == UART_STOP_BITS_2) {
-        uart_handle.Init.StopBits = UART_STOPBITS_2;
+        s_uart_handle.Init.StopBits = UART_STOPBITS_2;
     } else if(config->StopBits == UART_STOP_BITS_1_5) {
-        uart_handle.Init.StopBits = UART_STOPBITS_2;
-        configuration.StopBits = UART_STOP_BITS_2;
+        s_uart_handle.Init.StopBits = UART_STOPBITS_2;
+        s_configuration.StopBits = UART_STOP_BITS_2;
     } else if(config->StopBits == UART_STOP_BITS_1) {
-        uart_handle.Init.StopBits = UART_STOPBITS_1;
+        s_uart_handle.Init.StopBits = UART_STOPBITS_1;
     } else {
-        uart_handle.Init.StopBits = UART_STOPBITS_1;
-        configuration.StopBits = UART_STOP_BITS_1;
+        s_uart_handle.Init.StopBits = UART_STOPBITS_1;
+        s_configuration.StopBits = UART_STOP_BITS_1;
     }
 
     //Only 8 bit support
-    configuration.DataBits = UART_DATA_BITS_8;
-    if (uart_handle.Init.Parity == HAL_UART_PARITY_ODD || uart_handle.Init.Parity == HAL_UART_PARITY_EVEN) {
-        uart_handle.Init.WordLength = UART_WORDLENGTH_9B;
+    util_assert(config->DataBits == UART_DATA_BITS_8);
+    s_configuration.DataBits = config->DataBits;
+    if (s_uart_handle.Init.Parity == UART_PARITY_ODD || s_uart_handle.Init.Parity == UART_PARITY_EVEN) {
+        s_uart_handle.Init.WordLength = UART_WORDLENGTH_9B;
     } else {
-        uart_handle.Init.WordLength = UART_WORDLENGTH_8B;
+        s_uart_handle.Init.WordLength = UART_WORDLENGTH_8B;
     }
 
     // No flow control
-    configuration.FlowControl = UART_FLOW_CONTROL_NONE;
-    uart_handle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
-    
+    s_configuration.FlowControl = UART_FLOW_CONTROL_NONE;
+    s_uart_handle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
+
     // Specified baudrate
-    configuration.Baudrate = config->Baudrate;
-    uart_handle.Init.BaudRate = config->Baudrate;
+    s_configuration.Baudrate = config->Baudrate;
+    s_uart_handle.Init.BaudRate = config->Baudrate;
 
     // TX and RX
-    uart_handle.Init.Mode = UART_MODE_TX_RX;
-    
-    // Disable uart and tx/rx interrupt
-    CDC_UART->CR1 &= ~(USART_IT_TXE | USART_IT_RXNE);
+    s_uart_handle.Init.Mode = UART_MODE_TX_RX;
 
-    clear_buffers();
+    status = HAL_UART_Init(&s_uart_handle);
+    util_assert(status != HAL_ERROR);
+
+    status = HAL_UARTEx_EnableFifoMode(&s_uart_handle);
+    util_assert(status != HAL_ERROR);
 
-    status = HAL_UART_DeInit(&uart_handle);
-    util_assert(HAL_OK == status);
-    status = HAL_UART_Init(&uart_handle);
-    util_assert(HAL_OK == status);
-    (void)status;
+    status = HAL_UARTEx_SetRxFifoThreshold(&s_uart_handle, CDC_UART_RXFIFO_THRESHOLD);
+    util_assert(status != HAL_ERROR);
+
+    clear_buffers();
 
-    CDC_UART->CR1 |= USART_IT_RXNE;
+    CDC_UART->CR1 |= USART_CR1_IDLEIE;
+    CDC_UART->CR3 |= USART_CR3_RXFTIE;
 
     return 1;
 }
 
 int32_t uart_get_configuration(UART_Configuration *config)
 {
-    config->Baudrate = configuration.Baudrate;
-    config->DataBits = configuration.DataBits;
-    config->Parity   = configuration.Parity;
-    config->StopBits = configuration.StopBits;
+    config->Baudrate    = s_configuration.Baudrate;
+    config->DataBits    = s_configuration.DataBits;
+    config->Parity      = s_configuration.Parity;
+    config->StopBits    = s_configuration.StopBits;
     config->FlowControl = UART_FLOW_CONTROL_NONE;
 
     return 1;
 }
 
-void uart_set_control_line_state(uint16_t ctrl_bmp)
+int UART_Out(int ch)
 {
+    while ((CDC_UART->ISR & 0X40) == 0);    /* ȴһַ */
+
+    CDC_UART->TDR = (uint8_t)ch;            /* Ҫ͵ַ ch д뵽DRĴ */
+    return ch;
 }
 
+
 int32_t uart_write_free(void)
 {
-    return circ_buf_count_free(&write_buffer);
+    return circ_buf_count_free(&s_write_buffer);
 }
 
 int32_t uart_write_data(uint8_t *data, uint16_t size)
 {
-    uint32_t cnt = circ_buf_write(&write_buffer, data, size);
-    CDC_UART->CR1 |= USART_IT_TXE;
-
+    uint32_t cnt = circ_buf_write(&s_write_buffer, data, size);
+    if (cnt > 0)
+    {
+        CDC_UART->CR1 |= USART_CR1_TXEIE_TXFNFIE;
+    }
     return cnt;
 }
 
 int32_t uart_read_data(uint8_t *data, uint16_t size)
 {
-    return circ_buf_read(&read_buffer, data, size);
+    return circ_buf_read(&s_read_buffer, data, size);
 }
 
 void CDC_UART_IRQn_Handler(void)
 {
-    const uint32_t sr = CDC_UART->SR;
+    const uint32_t isr_reg = CDC_UART->ISR;
+    const uint32_t cr1 = CDC_UART->CR1;
+    const uint32_t cr3 = CDC_UART->CR3;
 
-    if (sr & USART_SR_RXNE) {
-        uint8_t dat = CDC_UART->DR;
-        uint32_t free = circ_buf_count_free(&read_buffer);
-        if (free > RX_OVRF_MSG_SIZE) {
-            circ_buf_push(&read_buffer, dat);
-        } else if (RX_OVRF_MSG_SIZE == free) {
-            circ_buf_write(&read_buffer, (uint8_t*)RX_OVRF_MSG, RX_OVRF_MSG_SIZE);
-        } else {
-            // Drop character
-        }
+    // UART Rx
+    if ((isr_reg & USART_ISR_RXFT) && (cr3 & USART_CR3_RXFTIE))
+    {
+        uart_read_from_fifo_in_isr();
+    }
+    else if((cr1 & USART_CR1_IDLEIE) && (isr_reg & USART_ISR_IDLE))
+    {
+        // Handle IDLE interrupt to deal with the data left in FIFO,
+        // which is less than CDC_UART_FIFO_SIZE and cannot trigger
+        // USART_ISR_RXFT
+        CDC_UART->ICR |= USART_ICR_IDLECF;
+        uart_read_from_fifo_in_isr();
     }
 
-    if (sr & USART_SR_TXE) {
-        if (circ_buf_count_used(&write_buffer) > 0) {
-            CDC_UART->DR = circ_buf_pop(&write_buffer);
-        } else {
-            CDC_UART->CR1 &= ~USART_IT_TXE;
+    // UART Tx
+    if ((isr_reg & USART_ISR_TXE_TXFNF) && (cr1 & USART_CR1_TXEIE_TXFNFIE))
+    {
+        uint16_t size = circ_buf_count_used(&s_write_buffer);
+        if (size > 0)
+        {
+            while (size && (CDC_UART->ISR & USART_ISR_TXE_TXFNF))
+            {
+                CDC_UART->TDR = circ_buf_pop(&s_write_buffer);
+                --size;
+            }
+
+            if (size == 0)
+            {
+                CDC_UART->CR1 &= ~USART_CR1_TXEIE_TXFNFIE;
+            }
+        }
+        else
+        {
+            // transmission is done
+            CDC_UART->CR1 &= ~USART_CR1_TXEIE_TXFNFIE;
         }
     }
 }
diff -uNr old/CA7/source/hic_hal/stm32/stm32mp1xx/usb_config.c new/CA7/source/hic_hal/stm32/stm32mp1xx/usb_config.c
--- old/CA7/source/hic_hal/stm32/stm32mp1xx/usb_config.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/stm32/stm32mp1xx/usb_config.c	2023-05-25 15:16:40.000000000 +0800
@@ -23,14 +23,16 @@
 
 // <e> USB Device
 //   <i> Enable the USB Device functionality
+#ifndef USBD_ENABLE
 #define USBD_ENABLE                 1
+#endif
 #define USBD_RTX_CORE_STACK         0
 #define USBD_RTX_DEVICE_STACK       0
 #define USBD_RTX_ENDPOINT0_STACK    0
 
 //   <o0.0> High-speed
 //     <i> Enable high-speed functionality (if device supports it)
-#define USBD_HS_ENABLE              0
+#define USBD_HS_ENABLE              1	//elee: Beagle analyzer shows HS traffic, maybe set this to match?
 #if (defined(WEBUSB_INTERFACE) || defined(WINUSB_INTERFACE) || defined(BULK_ENDPOINT))
 #define USBD_BOS_ENABLE             1
 #else
@@ -54,9 +56,12 @@
 //   </h>
 #define USBD_POWER                  0
 #define USBD_MAX_PACKET0            64
-#define USBD_DEVDESC_IDVENDOR       0x0D28
-#define USBD_DEVDESC_IDPRODUCT      0x0204
-#define USBD_DEVDESC_BCDDEVICE      0x0100
+// #define USBD_DEVDESC_IDVENDOR       0x0483
+// #define USBD_DEVDESC_IDPRODUCT      0x5720
+// #define USBD_DEVDESC_BCDDEVICE      0x0200
+#define USBD_DEVDESC_IDVENDOR       0x4701
+#define USBD_DEVDESC_IDPRODUCT      0x0290
+#define USBD_DEVDESC_BCDDEVICE      0x0200 //was 0x0100
 
 //   <h> Configuration Settings
 //     <i> These settings affect Configuration Descriptor
@@ -91,13 +96,7 @@
 //   </h>
 #define USBD_STRDESC_LANGID         0x0409
 #define USBD_STRDESC_MAN            L"Arm"
-#ifndef USB_PROD_STR
 #define USBD_STRDESC_PROD           L"DAPLink CMSIS-DAP"
-#else
-#define _TOWIDE(x)                   L ## #x
-#define TOWIDE(x)                   _TOWIDE(x)
-#define USBD_STRDESC_PROD           TOWIDE(USB_PROD_STR)
-#endif
 #define USBD_STRDESC_SER_ENABLE     1
 #define USBD_STRDESC_SER            L"0001A0000000"
 
@@ -153,12 +152,6 @@
 #define WEBUSB_INTERFACE 1
 #endif
 
-#ifndef WINUSB_INTERFACE
-#define WINUSB_INTERFACE 0
-#else
-#define WINUSB_INTERFACE 1
-#endif
-
 #define USBD_HID_ENABLE             HID_ENDPOINT
 #ifndef BULK_ENDPOINT               //check if bulk endpoint is not enabled
 #define USBD_HID_EP_INTIN           1
@@ -170,7 +163,7 @@
 #define USBD_HID_EP_INTIN_STACK     0
 #define USBD_HID_WMAXPACKETSIZE     64
 #define USBD_HID_BINTERVAL          1
-#define USBD_HID_HS_ENABLE          0
+#define USBD_HID_HS_ENABLE          1	//elee: enable
 #define USBD_HID_HS_WMAXPACKETSIZE  64
 #define USBD_HID_HS_BINTERVAL       6
 #define USBD_HID_STRDESC            L"CMSIS-DAP v1"
@@ -221,7 +214,7 @@
 #define USBD_MSC_EP_BULKOUT         2
 #define USBD_MSC_EP_BULKIN_STACK    0
 #define USBD_MSC_WMAXPACKETSIZE     64
-#define USBD_MSC_HS_ENABLE          0
+#define USBD_MSC_HS_ENABLE          1	//elee: enable
 #define USBD_MSC_HS_WMAXPACKETSIZE  512
 #define USBD_MSC_HS_BINTERVAL       0
 #define USBD_MSC_STRDESC            L"USB_MSC"
@@ -341,20 +334,20 @@
 #define USBD_CDC_ACM_EP_INTIN_STACK     0
 #define USBD_CDC_ACM_WMAXPACKETSIZE     16
 #define USBD_CDC_ACM_BINTERVAL          32
-#define USBD_CDC_ACM_HS_ENABLE          0
+#define USBD_CDC_ACM_HS_ENABLE          1	//elee: enable
 #define USBD_CDC_ACM_HS_WMAXPACKETSIZE  16
 #define USBD_CDC_ACM_HS_BINTERVAL       2
 #define USBD_CDC_ACM_EP_BULKIN          4
 #define USBD_CDC_ACM_EP_BULKOUT         4
 #define USBD_CDC_ACM_EP_BULKIN_STACK    0
 #define USBD_CDC_ACM_WMAXPACKETSIZE1    16
-#define USBD_CDC_ACM_HS_ENABLE1         0
-#define USBD_CDC_ACM_HS_WMAXPACKETSIZE1 16
-#define USBD_CDC_ACM_HS_BINTERVAL1      0
+#define USBD_CDC_ACM_HS_ENABLE1         1	//elee: enable
+#define USBD_CDC_ACM_HS_WMAXPACKETSIZE1 512
+#define USBD_CDC_ACM_HS_BINTERVAL1      3
 #define USBD_CDC_ACM_CIF_STRDESC        L"mbed Serial Port"
 #define USBD_CDC_ACM_DIF_STRDESC        L"mbed Serial Port"
-#define USBD_CDC_ACM_SENDBUF_SIZE       64
-#define USBD_CDC_ACM_RECEIVEBUF_SIZE    64
+#define USBD_CDC_ACM_SENDBUF_SIZE       512
+#define USBD_CDC_ACM_RECEIVEBUF_SIZE    1024
 #if (((USBD_CDC_ACM_HS_ENABLE1) && (USBD_CDC_ACM_SENDBUF_SIZE    < USBD_CDC_ACM_HS_WMAXPACKETSIZE1)) || (USBD_CDC_ACM_SENDBUF_SIZE    < USBD_CDC_ACM_WMAXPACKETSIZE1))
 #error "Send Buffer size must be larger or equal to Bulk In maximum packet size!"
 #endif
@@ -362,6 +355,37 @@
 #error "Receive Buffer size must be larger or equal to Bulk Out maximum packet size!"
 #endif
 
+#ifndef CDCB_ENDPOINT
+#define CDCB_ENDPOINT 0
+#else
+#define CDCB_ENDPOINT 1
+#endif
+#define USBD_CDCB_ACM_ENABLE             CDCB_ENDPOINT
+#define USBD_CDCB_ACM_EP_INTIN           1  // Mutually exclusive with non-bulk HID
+#define USBD_CDCB_ACM_EP_INTIN_STACK     0
+#define USBD_CDCB_ACM_WMAXPACKETSIZE     16
+#define USBD_CDCB_ACM_BINTERVAL          32
+#define USBD_CDCB_ACM_HS_ENABLE          1   //elee: enable
+#define USBD_CDCB_ACM_HS_WMAXPACKETSIZE  16
+#define USBD_CDCB_ACM_HS_BINTERVAL       2
+#define USBD_CDCB_ACM_EP_BULKIN          2  // Mutually exclusive with MSC
+#define USBD_CDCB_ACM_EP_BULKOUT         2  // Mutually exclusive with MSC
+#define USBD_CDCB_ACM_EP_BULKIN_STACK    0
+#define USBD_CDCB_ACM_WMAXPACKETSIZE1    16
+#define USBD_CDCB_ACM_HS_ENABLE1         1   //elee: enable
+#define USBD_CDCB_ACM_HS_WMAXPACKETSIZE1 16
+#define USBD_CDCB_ACM_HS_BINTERVAL1      0
+#define USBD_CDCB_ACM_CIF_STRDESC        L"mbed Serial Port"
+#define USBD_CDCB_ACM_DIF_STRDESC        L"mbed Serial Port"
+#define USBD_CDCB_ACM_SENDBUF_SIZE       64
+#define USBD_CDCB_ACM_RECEIVEBUF_SIZE    64
+#if (((USBD_CDCB_ACM_HS_ENABLE1) && (USBD_CDCB_ACM_SENDBUF_SIZE    < USBD_CDCB_ACM_HS_WMAXPACKETSIZE1)) || (USBD_CDCB_ACM_SENDBUF_SIZE    < USBD_CDCB_ACM_WMAXPACKETSIZE1))
+#error "Send Buffer size must be larger or equal to Bulk In maximum packet size!"
+#endif
+#if (((USBD_CDCB_ACM_HS_ENABLE1) && (USBD_CDCB_ACM_RECEIVEBUF_SIZE < USBD_CDCB_ACM_HS_WMAXPACKETSIZE1)) || (USBD_CDCB_ACM_RECEIVEBUF_SIZE < USBD_CDCB_ACM_WMAXPACKETSIZE1))
+#error "Receive Buffer size must be larger or equal to Bulk Out maximum packet size!"
+#endif
+
 //     <e0> Custom Class Device
 //       <i> Enables USB Custom Class Requests
 //       <i> Class IDs:
@@ -387,6 +411,12 @@
 #define USBD_WEBUSB_ORIGIN_URL      "os.mbed.com/"
 
 //     Microsoft OS Descriptors 2.0 (WinUSB) support
+#ifndef WINUSB_INTERFACE
+#define WINUSB_INTERFACE 0
+#else
+#define WINUSB_INTERFACE 1
+#endif
+
 #define USBD_WINUSB_ENABLE          WINUSB_INTERFACE
 #define USBD_WINUSB_VENDOR_CODE     0x20
 //   </e>
@@ -402,15 +432,14 @@
 #define USBD_BULK_EP_BULKOUT         1
 #define USBD_BULK_EP_BULKIN_SWO      6
 #define USBD_BULK_WMAXPACKETSIZE     64
-#define USBD_BULK_HS_ENABLE          0
+#define USBD_BULK_HS_ENABLE          1	//elee: enable
 #define USBD_BULK_HS_WMAXPACKETSIZE  512
 #define USBD_BULK_STRDESC            L"CMSIS-DAP v2"
 
-
 /* USB Device Calculations ---------------------------------------------------*/
 
-#define USBD_IF_NUM_MAX             (USBD_BULK_ENABLE+USBD_WEBUSB_ENABLE+USBD_HID_ENABLE+USBD_MSC_ENABLE+(USBD_ADC_ENABLE*2)+(USBD_CDC_ACM_ENABLE*2)+USBD_CLS_ENABLE)
-#define USBD_MULTI_IF               (USBD_CDC_ACM_ENABLE*(USBD_HID_ENABLE|USBD_MSC_ENABLE|USBD_ADC_ENABLE|USBD_CLS_ENABLE|USBD_WEBUSB_ENABLE|USBD_BULK_ENABLE))
+#define USBD_IF_NUM_MAX             (USBD_BULK_ENABLE+USBD_WEBUSB_ENABLE+USBD_HID_ENABLE+USBD_MSC_ENABLE+(USBD_ADC_ENABLE*2)+(USBD_CDC_ACM_ENABLE*2)+(USBD_CDCB_ACM_ENABLE*2)+USBD_CLS_ENABLE)
+#define USBD_MULTI_IF               (USBD_CDC_ACM_ENABLE*(USBD_CDCB_ACM_ENABLE|USBD_HID_ENABLE|USBD_MSC_ENABLE|USBD_ADC_ENABLE|USBD_CLS_ENABLE|USBD_WEBUSB_ENABLE|USBD_BULK_ENABLE))
 // #define MAX(x, y)                   (((x) < (y)) ? (y) : (x))
 #define USBD_EP_NUM_CALC0           MAX((USBD_HID_ENABLE    *(USBD_HID_EP_INTIN     )), (USBD_HID_ENABLE    *(USBD_HID_EP_INTOUT)))
 #define USBD_EP_NUM_CALC1           MAX((USBD_MSC_ENABLE    *(USBD_MSC_EP_BULKIN    )), (USBD_MSC_ENABLE    *(USBD_MSC_EP_BULKOUT)))
@@ -420,14 +449,18 @@
 #define USBD_EP_NUM_CALC5           MAX(USBD_EP_NUM_CALC2, USBD_EP_NUM_CALC3)
 #define USBD_EP_NUM_CALC6           MAX(USBD_EP_NUM_CALC4, USBD_EP_NUM_CALC5)
 #define USBD_EP_NUM_CALC7           MAX((USBD_BULK_ENABLE*(USBD_BULK_EP_BULKIN)), (USBD_BULK_ENABLE*(USBD_BULK_EP_BULKOUT)))
-#define USBD_EP_NUM                 MAX(USBD_EP_NUM_CALC6, USBD_EP_NUM_CALC7)
+#define USBD_EP_NUM_CALC8           MAX(USBD_EP_NUM_CALC6, USBD_EP_NUM_CALC7)
+#define USBD_EP_NUM_CALC9           MAX(USBD_EP_NUM_CALC8, (USBD_CDCB_ACM_ENABLE*(USBD_CDCB_ACM_EP_INTIN)))
+#define USBD_EP_NUM_CALC10          MAX((USBD_CDCB_ACM_ENABLE*(USBD_CDCB_ACM_EP_BULKIN)), (USBD_CDCB_ACM_ENABLE*(USBD_CDCB_ACM_EP_BULKOUT)))
+#define USBD_EP_NUM                 MAX(USBD_EP_NUM_CALC9, USBD_EP_NUM_CALC10)
+
 
 #if    (USBD_HID_ENABLE)
 #if    (USBD_MSC_ENABLE)
-#if ((((USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKIN)      || \
-       (USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKOUT)))   || \
-      ((USBD_HID_EP_INTOUT  != 0)                       && \
-       (USBD_HID_EP_INTOUT  == USBD_MSC_EP_BULKIN)      || \
+#if ((((USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKIN)  || \
+       (USBD_HID_EP_INTIN   == USBD_MSC_EP_BULKIN)))|| \
+      ((USBD_HID_EP_INTOUT  != 0)                   && \
+       (USBD_HID_EP_INTOUT  == USBD_MSC_EP_BULKIN)  || \
        (USBD_HID_EP_INTOUT  == USBD_MSC_EP_BULKOUT)))
 #error "HID and Mass Storage Device Interface can not use same Endpoints!"
 #endif
@@ -450,7 +483,18 @@
 #error "HID and Communication Device Interface can not use same Endpoints!"
 #endif
 #endif
+#if    (USBD_CDCB_ACM_ENABLE)
+#if  (((USBD_HID_EP_INTIN   == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_HID_EP_INTIN   == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_HID_EP_INTIN   == USBD_CDCB_ACM_EP_BULKOUT))|| \
+      ((USBD_HID_EP_INTOUT  != 0)                       && \
+      ((USBD_HID_EP_INTOUT  == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_HID_EP_INTOUT  == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_HID_EP_INTOUT  == USBD_CDCB_ACM_EP_BULKOUT))))
+#error "HID and Communication Device B Interface can not use same Endpoints!"
+#endif
 #endif
+#endif  // USBD_HID_ENABLE
 
 #if    (USBD_MSC_ENABLE)
 #if    (USBD_ADC_ENABLE)
@@ -469,7 +513,17 @@
 #error "Mass Storage Device and Communication Device Interface can not use same Endpoints!"
 #endif
 #endif
+#if    (USBD_CDCB_ACM_ENABLE)
+#if   ((USBD_MSC_EP_BULKIN  == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_MSC_EP_BULKIN  == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_MSC_EP_BULKIN  == USBD_CDCB_ACM_EP_BULKOUT) || \
+       (USBD_MSC_EP_BULKOUT == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_MSC_EP_BULKOUT == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_MSC_EP_BULKOUT == USBD_CDCB_ACM_EP_BULKOUT))
+#error "Mass Storage Device and Communication Device B Interface can not use same Endpoints!"
 #endif
+#endif
+#endif  // USBD_MSC_ENABLE
 
 #if    (USBD_ADC_ENABLE)
 #if    (USBD_CDC_ACM_ENABLE)
@@ -479,21 +533,49 @@
 #error "Audio Device and Communication Device Interface can not use same Endpoints!"
 #endif
 #endif
+#if    (USBD_CDCB_ACM_ENABLE)
+#if   ((USBD_ADC_EP_ISOOUT  == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_ADC_EP_ISOOUT  == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_ADC_EP_ISOOUT  == USBD_CDCB_ACM_EP_BULKOUT))
+#error "Audio Device and Communication Device B Interface can not use same Endpoints!"
+#endif
+#endif
+#endif  // USBD_ADC_ENABLE
+
+#if    (USBD_CDC_ACM_ENABLE)
+#if    (USBD_CDCB_ACM_ENABLE)
+#if   ((USBD_CDC_ACM_EP_INTIN == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_CDC_ACM_EP_INTIN == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_CDC_ACM_EP_INTIN == USBD_CDCB_ACM_EP_BULKOUT) || \
+       (USBD_CDC_ACM_EP_BULKIN == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_CDC_ACM_EP_BULKIN == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_CDC_ACM_EP_BULKIN == USBD_CDCB_ACM_EP_BULKOUT) || \
+       (USBD_CDC_ACM_EP_BULKOUT == USBD_CDCB_ACM_EP_INTIN)   || \
+       (USBD_CDC_ACM_EP_BULKOUT == USBD_CDCB_ACM_EP_BULKIN)  || \
+       (USBD_CDC_ACM_EP_BULKOUT == USBD_CDCB_ACM_EP_BULKOUT))
+#error "Communication Device and Communication Device B Interface can not use same Endpoints!"
+#endif
 #endif
+#endif  // USBD_CDC_ACM_ENABLE
+
 
 #define USBD_ADC_CIF_NUM           (0)
 #define USBD_ADC_SIF1_NUM          (1)
 #define USBD_ADC_SIF2_NUM          (2)
 
+// Index of each interface string
 #define USBD_ADC_CIF_STR_NUM       (3+USBD_STRDESC_SER_ENABLE+0)
 #define USBD_ADC_SIF1_STR_NUM      (3+USBD_STRDESC_SER_ENABLE+1)
 #define USBD_ADC_SIF2_STR_NUM      (3+USBD_STRDESC_SER_ENABLE+2)
 #define USBD_CDC_ACM_CIF_STR_NUM   (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+0)
 #define USBD_CDC_ACM_DIF_STR_NUM   (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+1)
-#define USBD_HID_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2)
-#define USBD_WEBUSB_IF_STR_NUM     (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE)
-#define USBD_MSC_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE)
-#define USBD_BULK_IF_STR_NUM       (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE+USBD_MSC_ENABLE)
+#define USBD_CDCB_ACM_CIF_STR_NUM  (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+0)
+#define USBD_CDCB_ACM_DIF_STR_NUM  (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+1)
+#define USBD_HID_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_CDCB_ACM_ENABLE*2)
+#define USBD_WEBUSB_IF_STR_NUM     (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_CDCB_ACM_ENABLE*2+USBD_HID_ENABLE)
+#define USBD_MSC_IF_STR_NUM        (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_CDCB_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE)
+#define USBD_BULK_IF_STR_NUM       (3+USBD_STRDESC_SER_ENABLE+USBD_ADC_ENABLE*3+USBD_CDC_ACM_ENABLE*2+USBD_CDCB_ACM_ENABLE*2+USBD_HID_ENABLE+USBD_WEBUSB_ENABLE+USBD_MSC_ENABLE)
+
 
 #if    (USBD_HID_ENABLE)
 #if    (USBD_HID_HS_ENABLE)
@@ -537,6 +619,21 @@
 #define USBD_CDC_ACM_MAX_PACKET    (0)
 #define USBD_CDC_ACM_MAX_PACKET1   (0)
 #endif
+#if    (USBD_CDCB_ACM_ENABLE)
+#if    (USBD_CDCB_ACM_HS_ENABLE)
+#define USBD_CDCB_ACM_MAX_PACKET   ((USBD_CDCB_ACM_HS_WMAXPACKETSIZE > USBD_CDCB_ACM_WMAXPACKETSIZE) ? USBD_CDCB_ACM_HS_WMAXPACKETSIZE : USBD_CDCB_ACM_WMAXPACKETSIZE)
+#else
+#define USBD_CDCB_ACM_MAX_PACKET    (USBD_CDCB_ACM_WMAXPACKETSIZE)
+#endif
+#if    (USBD_CDCB_ACM_HS_ENABLE1)
+#define USBD_CDCB_ACM_MAX_PACKET1  ((USBD_CDCB_ACM_HS_WMAXPACKETSIZE1 > USBD_CDCB_ACM_WMAXPACKETSIZE1) ? USBD_CDCB_ACM_HS_WMAXPACKETSIZE1 : USBD_CDCB_ACM_WMAXPACKETSIZE1)
+#else
+#define USBD_CDCB_ACM_MAX_PACKET1   (USBD_CDCB_ACM_WMAXPACKETSIZE1)
+#endif
+#else
+#define USBD_CDCB_ACM_MAX_PACKET    (0)
+#define USBD_CDCB_ACM_MAX_PACKET1   (0)
+#endif
 #if    (USBD_BULK_ENABLE)
 #if    (USBD_BULK_HS_ENABLE)
 #define USBD_BULK_MAX_PACKET       ((USBD_BULK_HS_WMAXPACKETSIZE > USBD_BULK_WMAXPACKETSIZE) ? USBD_BULK_HS_WMAXPACKETSIZE : USBD_BULK_WMAXPACKETSIZE)
@@ -546,18 +643,23 @@
 #else
 #define USBD_BULK_MAX_PACKET        (0)
 #endif
-#define USBD_MAX_PACKET_CALC0     ((USBD_HID_MAX_PACKET   > USBD_HID_MAX_PACKET      ) ? (USBD_HID_MAX_PACKET  ) : (USBD_HID_MAX_PACKET      ))
+
+// TODO(aiw): Simplify (and maybe reorder) for easier maintenance
+#define USBD_MAX_PACKET_CALC0     ((USBD_HID_MAX_PACKET   > USBD_CDCB_ACM_MAX_PACKET ) ? (USBD_HID_MAX_PACKET  ) : (USBD_CDCB_ACM_MAX_PACKET ))
 #define USBD_MAX_PACKET_CALC1     ((USBD_ADC_MAX_PACKET   > USBD_CDC_ACM_MAX_PACKET  ) ? (USBD_ADC_MAX_PACKET  ) : (USBD_CDC_ACM_MAX_PACKET  ))
 #define USBD_MAX_PACKET_CALC2     ((USBD_MAX_PACKET_CALC0 > USBD_MAX_PACKET_CALC1    ) ? (USBD_MAX_PACKET_CALC0) : (USBD_MAX_PACKET_CALC1    ))
-#define USBD_MAX_PACKET_CALC3     ((USBD_BULK_MAX_PACKET > USBD_CDC_ACM_MAX_PACKET1 ) ? (USBD_BULK_MAX_PACKET) : (USBD_CDC_ACM_MAX_PACKET1 ))
-#define USBD_MAX_PACKET           ((USBD_MAX_PACKET_CALC3 > USBD_MAX_PACKET_CALC2    ) ? (USBD_MAX_PACKET_CALC3) : (USBD_MAX_PACKET_CALC2    ))
 
+#define USBD_MAX_PACKET_CALC3     ((USBD_BULK_MAX_PACKET      > USBD_CDC_ACM_MAX_PACKET1 ) ? (USBD_BULK_MAX_PACKET     ) : (USBD_CDC_ACM_MAX_PACKET1 ))
+#define USBD_MAX_PACKET_CALC4     ((USBD_CDCB_ACM_MAX_PACKET1 > USBD_MSC_MAX_PACKET      ) ? (USBD_CDCB_ACM_MAX_PACKET1) : (USBD_MSC_MAX_PACKET      ))
+#define USBD_MAX_PACKET_CALC5     ((USBD_MAX_PACKET_CALC3     > USBD_MAX_PACKET_CALC4    ) ? (USBD_MAX_PACKET_CALC3    ) : (USBD_MAX_PACKET_CALC4    ))
+
+#define USBD_MAX_PACKET           ((USBD_MAX_PACKET_CALC5 > USBD_MAX_PACKET_CALC2 ) ? (USBD_MAX_PACKET_CALC5) : (USBD_MAX_PACKET_CALC2 ))
 
 /*------------------------------------------------------------------------------
  *      USB Config Functions
  *----------------------------------------------------------------------------*/
 
-#ifndef  __USB_CONFIG___
+#ifndef  __USB_CONFIG__
 #define  __USB_CONFIG__
 
 #ifndef  __NO_USB_LIB_C
diff -uNr old/CA7/source/hic_hal/uart.h new/CA7/source/hic_hal/uart.h
--- old/CA7/source/hic_hal/uart.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/hic_hal/uart.h	2023-12-27 14:17:42.910784472 +0800
@@ -31,11 +31,19 @@
 
 /* Parity enumerator */
 typedef enum {
+#ifdef DAPLINK_UART
+    UART_PARITY_NONE_DAPLINK    = 0,
+    UART_PARITY_ODD_DAPLINK     = 1,
+    UART_PARITY_EVEN_DAPLINK    = 2,
+    UART_PARITY_MARK_DAPLINK    = 3,
+    UART_PARITY_SPACE_DAPLINK   = 4
+#else
     UART_PARITY_NONE    = 0,
     UART_PARITY_ODD     = 1,
     UART_PARITY_EVEN    = 2,
     UART_PARITY_MARK    = 3,
-    UART_PARITY_SPACE   = 4
+    UART_PARITY_SPACE   = 4    
+#endif
 } UART_Parity;
 
 /* Stop Bits enumerator */
@@ -87,6 +95,10 @@
 extern void uart_software_flow_control(void);
 extern void uart_enable_flow_control(bool enabled);
 
+#ifdef HISPARK_TRACE
+extern void main_cdc_send_event(void);
+extern int UART_Out(int ch);
+#endif
 #ifdef __cplusplus
 }
 #endif
diff -uNr old/CA7/source/rtos_none/cmsis_os2_port.c new/CA7/source/rtos_none/cmsis_os2_port.c
--- old/CA7/source/rtos_none/cmsis_os2_port.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/rtos_none/cmsis_os2_port.c	2023-05-25 15:09:49.000000000 +0800
@@ -20,6 +20,9 @@
  */
 #include "cmsis_os2.h"
 #include "SysTick_Handler.h"
+#if defined(USE_HAL_TICK) && defined(HISPARK_TRACE)
+#include "stm32mp1xx_hal.h"
+#endif
 
 osStatus_t osKernelInitialize(void)
 {
@@ -47,8 +50,21 @@
 
 osStatus_t osDelay(uint32_t ticks)
 {
+#if defined(USE_HAL_TICK) && defined(HISPARK_TRACE)
+    uint32_t temp;
+    uint32_t pre_tick = 0;
+    uint32_t current_tick = 0;
+    pre_tick = HAL_GetTick();
+    while (1) {
+        current_tick = HAL_GetTick();
+        temp = current_tick - pre_tick;
+        if (temp > ticks) {
+            return osOK;
+        }
+    }
+#else
     sysTickWait(ticks);
-    return osOK;
+#endif
 }
 
 osTimerId_t osTimerNew(osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr)
@@ -87,3 +103,10 @@
 {
     return (osThreadId_t)1;
 }
+
+#if defined(USE_HAL_TICK) && defined(HISPARK_TRACE)
+uint32_t osKernelGetSysTimerCount(void)
+{
+    return HAL_GetTick();
+}
+#endif
\ No newline at end of file
diff -uNr old/CA7/source/rtos_none/SysTick_Handler.c new/CA7/source/rtos_none/SysTick_Handler.c
--- old/CA7/source/rtos_none/SysTick_Handler.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/rtos_none/SysTick_Handler.c	2023-05-25 15:09:49.000000000 +0800
@@ -28,9 +28,15 @@
 #endif
 
 //Set the timer tick value for selected timer.
+#ifdef HISPARK_TRACE
+#ifdef NO_RTOS
+#define OS_TICK 10000
+#endif
+#else
 #ifndef OS_TICK
 #error "OS_TICK should be defined by RTOS configuration"
 #endif
+#endif
 
 #define OS_TRV          ((uint32_t)(((double)OS_CLOCK*(double)OS_TICK)/1E6)-1)
 
diff -uNr old/CA7/source/target/target_config.h new/CA7/source/target/target_config.h
--- old/CA7/source/target/target_config.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/target/target_config.h	2023-05-25 15:09:49.000000000 +0800
@@ -63,11 +63,19 @@
  */
 typedef struct __attribute__((__packed__)) target_cfg {
     uint32_t version;                           /*!< Target configuration version */
+#ifdef HISPARK_TRACE
+    sector_info_t* sectors_info;                /*!< Sector start and length list */
+#else
     const sector_info_t* sectors_info;          /*!< Sector start and length list */
+#endif
     uint32_t sector_info_length;                /*!< Number of entries in the sectors_info array */
     region_info_t flash_regions[MAX_REGIONS];   /*!< Flash regions */
     region_info_t ram_regions[MAX_REGIONS];     /*!< RAM regions  */
+#ifdef HISPARK_TRACE
+    char *rt_board_id;                          /*!< If assigned, this is a flexible board ID */
+#else
     const char *rt_board_id;                    /*!< If assigned, this is a flexible board ID */
+#endif
     uint16_t rt_family_id;                      /*!< If assigned, this is a flexible family ID */
     uint8_t erase_reset;                        /*!< Reset after performing an erase */
     uint8_t pad;
diff -uNr old/CA7/source/target/target_family.c new/CA7/source/target/target_family.c
--- old/CA7/source/target/target_family.c	2022-02-05 13:12:28.000000000 +0800
+++ new/CA7/source/target/target_family.c	2023-06-09 15:09:34.710441100 +0800
@@ -21,7 +21,9 @@
 
 #include "daplink.h"
 #include "DAP_config.h"
+#include "swd_jtag_config.h"
 #include "swd_host.h"
+#include "jtag_host.h"
 #include "target_family.h"
 #include "target_board.h"
 
@@ -133,14 +135,30 @@
             return g_target_family->target_set_state(state);
         } else {
             if (g_target_family->default_reset_type == kHardwareReset) {
-                return swd_set_target_state_hw(state);
+                if (SwdJtagDebugPortGet() == DAP_PORT_JTAG) {
+                    return jtag_set_target_state_hw(state);
+                } else {
+                    return swd_set_target_state_hw(state);
+                }
             } else if (g_target_family->default_reset_type == kSoftwareReset) {
                 if (g_board_info.soft_reset_type) { //board has precedence
-                    swd_set_soft_reset(g_board_info.soft_reset_type);
+                    if (SwdJtagDebugPortGet() == DAP_PORT_JTAG) {
+                        jtag_set_soft_reset(g_board_info.soft_reset_type);
+                    } else {
+                        swd_set_soft_reset(g_board_info.soft_reset_type);
+                    }
                 } else if (g_target_family->soft_reset_type) {
-                    swd_set_soft_reset(g_target_family->soft_reset_type);
+                    if (SwdJtagDebugPortGet() == DAP_PORT_JTAG) {
+                        jtag_set_soft_reset(g_target_family->soft_reset_type);
+                    } else {
+                        swd_set_soft_reset(g_target_family->soft_reset_type);
+                    }
+                }
+                if (SwdJtagDebugPortGet() == DAP_PORT_JTAG) {
+                    return jtag_set_target_state_sw(state);
+                } else {
+                    return swd_set_target_state_sw(state);
                 }
-                return swd_set_target_state_sw(state);
             } else {
                 return 1;
             }
@@ -157,6 +175,15 @@
     } else {
         (asserted) ? PIN_nRESET_OUT(0) : PIN_nRESET_OUT(1);
     }
+}
+
+void jtag_set_target_reset(uint8_t asserted)
+{
+    if (g_target_family && g_target_family->jtag_set_target_reset) {
+        g_target_family->jtag_set_target_reset(asserted);
+    } else {
+        (asserted) ? PIN_nRESET_OUT(0) : PIN_nRESET_OUT(1);
+    }
 }
 
 uint32_t target_get_apsel()
diff -uNr old/CA7/source/target/target_family.h new/CA7/source/target/target_family.h
--- old/CA7/source/target/target_family.h	2022-02-05 13:12:28.000000000 +0800
+++ new/CA7/source/target/target_family.h	2023-06-09 15:09:54.922080300 +0800
@@ -122,6 +122,7 @@
     uint8_t (*validate_bin_nvic)(const uint8_t *buf);       /*!< Validate a bin file to be flash by drag and drop */
     uint8_t (*validate_hexfile)(const uint8_t *buf);        /*!< Validate a hex file to be flash by drag and drop */
     uint32_t apsel;                             /*!< APSEL for the family */
+    void (*jtag_set_target_reset)(uint8_t asserted);
 } target_family_descriptor_t;
 
 //! @brief The active family used by the board.
@@ -145,6 +146,9 @@
 //! @brief Controls reset of the target.
 void swd_set_target_reset(uint8_t asserted);
 
+//! @brief Controls reset of the target.
+void jtag_set_target_reset(uint8_t asserted);
+
 //! @brief Get the APSEL for the AHB-AP to use for controlling the target.
 uint32_t target_get_apsel(void);
 
diff -uNr old/CA7/source/usb/hid/usbd_core_hid.c new/CA7/source/usb/hid/usbd_core_hid.c
--- old/CA7/source/usb/hid/usbd_core_hid.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/usb/hid/usbd_core_hid.c	2023-05-25 15:09:49.000000000 +0800
@@ -35,8 +35,12 @@
 {
     switch (USBD_SetupPacket.wValueH) {
         case HID_HID_DESCRIPTOR_TYPE:
+        #ifdef HISPARK_TRACE
+            if (USBD_SetupPacket.wIndexL != usbd_hid_if_num) {
+        #else
             if (USBD_SetupPacket.wIndexL != usbd_hid_if_num &&
                 USBD_SetupPacket.wIndexL != usbd_webusb_if_num) {
+        #endif
                 return (__FALSE);
             }
 
@@ -55,8 +59,12 @@
             break;
 
         case HID_REPORT_DESCRIPTOR_TYPE:
+        #ifdef HISPARK_TRACE
+            if (USBD_SetupPacket.wIndexL != usbd_hid_if_num) {
+        #else
             if (USBD_SetupPacket.wIndexL != usbd_hid_if_num &&
                 USBD_SetupPacket.wIndexL != usbd_webusb_if_num) {
+        #endif
                 return (__FALSE);
             }
 
@@ -83,8 +91,12 @@
 
 __WEAK BOOL USBD_EndPoint0_Setup_HID_ReqToIF(void)
 {
+#ifdef HISPARK_TRACE
+    if (USBD_SetupPacket.wIndexL == usbd_hid_if_num) {
+#else
     if (USBD_SetupPacket.wIndexL == usbd_hid_if_num ||
         USBD_SetupPacket.wIndexL == usbd_webusb_if_num) {
+#endif
         switch (USBD_SetupPacket.bRequest) {
             case HID_REQUEST_GET_REPORT:
                 if (USBD_HID_GetReport()) {
@@ -157,8 +169,12 @@
 
 __WEAK BOOL USBD_EndPoint0_Out_HID_ReqToIF(void)
 {
+#ifdef HISPARK_TRACE
+    if (USBD_SetupPacket.wIndexL == usbd_hid_if_num) {
+#else
     if (USBD_SetupPacket.wIndexL == usbd_hid_if_num ||
         USBD_SetupPacket.wIndexL == usbd_webusb_if_num) {
+#endif
         switch (USBD_SetupPacket.bRequest) {
             case HID_REQUEST_SET_REPORT:
                 if (USBD_HID_SetReport()) {
diff -uNr old/CA7/source/usb/hid/usbd_user_hid.c new/CA7/source/usb/hid/usbd_user_hid.c
--- old/CA7/source/usb/hid/usbd_user_hid.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/usb/hid/usbd_user_hid.c	2023-05-25 15:24:26.000000000 +0800
@@ -22,7 +22,9 @@
 #include <string.h>
 #include "rl_usb.h"
 #include "usb.h"
+#ifndef HISPARK_TRACE
 #define __NO_USB_LIB_C
+#endif
 #include "usb_config.c"
 #include "DAP_config.h"
 #include "DAP.h"
@@ -42,7 +44,11 @@
 static volatile uint8_t  USB_ResponseIdle;
 static DAP_queue DAP_Cmd_queue;
 
+#ifdef HISPARK_TRACE
+void hid_send_packet(void)
+#else
 void hid_send_packet()
+#endif
 {
     uint8_t * sbuf;
     int slen;
diff -uNr old/CA7/source/usb/usbd_core.c new/CA7/source/usb/usbd_core.c
--- old/CA7/source/usb/usbd_core.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/usb/usbd_core.c	2023-05-25 15:23:34.000000000 +0800
@@ -23,6 +23,9 @@
 #include "rl_usb.h"
 #include "usb_for_lib.h"
 #include "info.h"
+#ifdef HISPARK_TRACE
+#include "interrupt.h"
+#endif
 
 U16 USBD_DeviceStatus;
 U8 USBD_DeviceAddress;
@@ -374,6 +377,11 @@
 
                     USBD_EP0Data.pData = pD;
                     len = ((USB_CONFIGURATION_DESCRIPTOR *)pD)->wTotalLength;
+                #ifdef HISPARK_TRACE
+                    if (len > USBD_SetupPacket.wLength) {
+                        len =  USBD_SetupPacket.wLength;
+                    }
+                #endif
                     break;
 
                 case USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE:
@@ -927,10 +935,11 @@
             case REQUEST_VENDOR:
                 switch (USBD_SetupPacket.bmRequestType.Recipient) {
                     case REQUEST_TO_DEVICE:
+                    #ifndef HISPARK_TRACE
                         if (USBD_EndPoint0_Setup_WebUSB_ReqToDevice()) {
                             goto setup_vendor_ok;
                         }
-
+                    #endif
                         if (USBD_EndPoint0_Setup_WinUSB_ReqToDevice()) {
                             goto setup_vendor_ok;
                         }
diff -uNr old/CA7/source/usb/usbd_hw.h new/CA7/source/usb/usbd_hw.h
--- old/CA7/source/usb/usbd_hw.h	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/usb/usbd_hw.h	2023-05-25 15:09:49.000000000 +0800
@@ -47,5 +47,8 @@
 extern U32 USBD_GetError(void);
 extern void USBD_SignalHandler(void);
 extern void USBD_Handler(void);
+#ifdef HISPARK_TRACE
+extern void OTG_HS_IRQHandler(void);
+#endif
 
 #endif  /* __USBD_HW_H__ */
diff -uNr old/CA7/source/usb/usb_lib.c new/CA7/source/usb/usb_lib.c
--- old/CA7/source/usb/usb_lib.c	2023-05-25 15:09:49.000000000 +0800
+++ new/CA7/source/usb/usb_lib.c	2023-05-25 15:20:09.000000000 +0800
@@ -24,6 +24,9 @@
 #include "usb.h"
 #include "settings.h"
 #include "compiler.h"
+#ifdef HISPARK_TRACE
+#include "usb_config.c"
+#endif
 
 #if defined(__CC_ARM)
 #pragma thumb
@@ -93,7 +96,11 @@
 const U8 usbd_msc_ep_bulkin = USBD_MSC_EP_BULKIN;
 const U8 usbd_msc_ep_bulkout = USBD_MSC_EP_BULKOUT;
 const U16 usbd_msc_maxpacketsize[2] = {USBD_MSC_WMAXPACKETSIZE, USBD_MSC_HS_WMAXPACKETSIZE};
+#ifdef HISPARK_TRACE
+const U8 *usbd_msc_inquiry_data = (U8 *)USBD_MSC_INQUIRY_DATA;
+#else
 const U8 *usbd_msc_inquiry_data = USBD_MSC_INQUIRY_DATA;
+#endif
 const U16 USBD_MSC_BulkBufSize = USBD_MSC_MAX_PACKET;
 U8 USBD_MSC_BulkBuf[USBD_MSC_MAX_PACKET];
 #endif
@@ -2503,6 +2510,7 @@
     return sizeof(start_desc);
 }
 
+#ifndef HISPARK_TRACE
 static U16 hid_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
     U8 * pD = 0;
     const U8 hid_desc[] = {
@@ -2535,6 +2543,7 @@
 #endif
     return sizeof(hid_desc);
 }
+#endif
 
 static U16 acm_cdc_desc_fill(U8 * config_desc, U8 * config_desc_hs, U8 if_num) {
     U8 * pD = 0;
